
==================================================
FILE_NAME: ElectrophoresisGelControl.xaml
PATH: D:\programming\BioSAK\BioSAK\Controls\ElectrophoresisGelControl.xaml
==================================================
<UserControl x:Class="BioSAK.Controls.ElectrophoresisGelControl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="500" d:DesignWidth="300"
             Background="#1a1a2e">
    
    <UserControl.Resources>
        <Style x:Key="MarkerTextStyle" TargetType="TextBlock">
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="FontSize" Value="10"/>
            <Setter Property="FontFamily" Value="Consolas"/>
            <Setter Property="VerticalAlignment" Value="Center"/>
        </Style>
        
        <Style x:Key="BandStyle" TargetType="Border">
            <Setter Property="Height" Value="3"/>
            <Setter Property="CornerRadius" Value="1"/>
            <Setter Property="Margin" Value="5,0"/>
        </Style>
    </UserControl.Resources>
    
    <Grid Margin="10">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="Auto"/>
        </Grid.ColumnDefinitions>
        
        <!-- Sample Lane (Left) -->
        <Border Grid.Column="0" 
                Background="#16213e" 
                BorderBrush="#0f3460" 
                BorderThickness="1" 
                CornerRadius="3"
                Width="80"
                Margin="0,0,10,0">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>
                
                <!-- Well -->
                <Border Grid.Row="0" 
                        Background="#0f3460" 
                        Height="20" 
                        Margin="10,5,10,0"
                        CornerRadius="2">
                    <TextBlock Text="Sample" 
                               Foreground="White" 
                               FontSize="9"
                               HorizontalAlignment="Center"
                               VerticalAlignment="Center"/>
                </Border>
                
                <!-- Bands Canvas -->
                <Canvas x:Name="SampleCanvas" 
                        Grid.Row="1" 
                        Margin="5"/>
            </Grid>
        </Border>
        
        <!-- Gel Background (Middle) -->
        <Border Grid.Column="1" 
                Background="#16213e" 
                BorderBrush="#0f3460" 
                BorderThickness="1" 
                CornerRadius="3"
                Visibility="Collapsed">
            <Canvas x:Name="GelCanvas"/>
        </Border>
        
        <!-- Marker Lane (Right) -->
        <Border Grid.Column="2" 
                Background="#16213e" 
                BorderBrush="#0f3460" 
                BorderThickness="1" 
                CornerRadius="3"
                Width="80"
                Margin="10,0,0,0">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>
                
                <!-- Well -->
                <Border Grid.Row="0" 
                        Background="#0f3460" 
                        Height="20" 
                        Margin="10,5,10,0"
                        CornerRadius="2">
                    <TextBlock Text="Marker" 
                               Foreground="White" 
                               FontSize="9"
                               HorizontalAlignment="Center"
                               VerticalAlignment="Center"/>
                </Border>
                
                <!-- Marker Bands Canvas -->
                <Canvas x:Name="MarkerCanvas" 
                        Grid.Row="1" 
                        Margin="5"/>
            </Grid>
        </Border>
    </Grid>
</UserControl>


==================================================
FILE_NAME: ElectrophoresisGelControl.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Controls\ElectrophoresisGelControl.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;
using BioSAK.Models;

namespace BioSAK.Controls
{
    /// <summary>
    /// ?餅陶?隞?    /// </summary>
    public partial class ElectrophoresisGelControl : UserControl
    {
        // Marker 憿?
        public enum MarkerType
        {
            Standard,    // 10K, 9K, 8K, 7K, 6K, 5K, 4K, 3K, 2K, 1K, 500, 250
            HighResolution  // 10K, 5K, 3K, 1K, 900, 800, 700, 600, 500, 400, 300, 200, 100
        }

        // 璅? Marker 憭批? (bp)
        private static readonly int[] StandardMarkerSizes = 
            { 10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 500, 250 };

        // 擃圾?漲 Marker 憭批? (bp)
        private static readonly int[] HighResMarkerSizes = 
            { 10000, 5000, 3000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100 };

        private MarkerType _currentMarkerType = MarkerType.Standard;
        private List<DnaFragment> _fragments = new List<DnaFragment>();

        // ?餅陶?
        private const double MinBandY = 30;  // ??嚗策 >10K嚗?        private const double MaxBandY = 0.95; // 摨雿蔭瘥?

        public ElectrophoresisGelControl()
        {
            InitializeComponent();
            this.Loaded += ElectrophoresisGelControl_Loaded;
            this.SizeChanged += ElectrophoresisGelControl_SizeChanged;
        }

        private void ElectrophoresisGelControl_Loaded(object sender, RoutedEventArgs e)
        {
            DrawMarkerLane();
        }

        private void ElectrophoresisGelControl_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            DrawMarkerLane();
            DrawSampleLane();
        }

        /// <summary>
        /// 閮剖? Marker 憿?
        /// </summary>
        public void SetMarkerType(MarkerType type)
        {
            _currentMarkerType = type;
            DrawMarkerLane();
            DrawSampleLane();
        }

        /// <summary>
        /// 閮剖?閬＊蝷箇? DNA ?挾
        /// </summary>
        public void SetFragments(List<DnaFragment> fragments)
        {
            _fragments = fragments ?? new List<DnaFragment>();
            DrawSampleLane();
        }

        /// <summary>
        /// 閮? DNA 憭批?撠???Y 雿蔭
        /// 雿輻撠?餃漲璅⊥?餅陶?瑞宏??        /// </summary>
        private double CalculateYPosition(int sizeInBp, double canvasHeight)
        {
            // ?餅陶銝?DNA ?瑞宏?? log(???? ??瘥?            // 頛之??畾萄銝嚗蝘餉??ｇ?嚗?撠??挾?其??對??瑞宏頛翰嚗?            
            int[] markerSizes = _currentMarkerType == MarkerType.Standard 
                ? StandardMarkerSizes 
                : HighResMarkerSizes;

            double maxSize = markerSizes.Max();
            double minSize = markerSizes.Min();

            // ??頞?蝭???畾?            if (sizeInBp > maxSize)
                sizeInBp = (int)maxSize;
            if (sizeInBp < minSize)
                sizeInBp = (int)minSize;

            // 撠頧?
            double logMax = Math.Log10(maxSize);
            double logMin = Math.Log10(minSize);
            double logSize = Math.Log10(sizeInBp);

            // 閮??詨?雿蔭 (0 = ?憭抒?畾? 1 = 摨撠?畾?
            double relativePosition = (logMax - logSize) / (logMax - logMin);

            // 頧???Canvas Y 摨扳?
            double usableHeight = canvasHeight * MaxBandY - MinBandY;
            return MinBandY + (relativePosition * usableHeight);
        }

        /// <summary>
        /// 蝜芾ˊ Marker Lane
        /// </summary>
        private void DrawMarkerLane()
        {
            MarkerCanvas.Children.Clear();

            double canvasHeight = MarkerCanvas.ActualHeight;
            double canvasWidth = MarkerCanvas.ActualWidth;

            if (canvasHeight <= 0 || canvasWidth <= 0)
                return;

            int[] markerSizes = _currentMarkerType == MarkerType.Standard 
                ? StandardMarkerSizes 
                : HighResMarkerSizes;

            foreach (int size in markerSizes)
            {
                double y = CalculateYPosition(size, canvasHeight);

                // 蝜芾ˊ Band
                var band = new Border
                {
                    Width = canvasWidth - 20,
                    Height = 3,
                    Background = new LinearGradientBrush(
                        Color.FromRgb(0, 255, 100),
                        Color.FromRgb(0, 200, 80),
                        0),
                    CornerRadius = new CornerRadius(1),
                    Effect = new System.Windows.Media.Effects.DropShadowEffect
                    {
                        Color = Color.FromRgb(0, 255, 100),
                        BlurRadius = 8,
                        ShadowDepth = 0,
                        Opacity = 0.6
                    }
                };

                Canvas.SetLeft(band, 10);
                Canvas.SetTop(band, y);
                MarkerCanvas.Children.Add(band);

                // 蝜芾ˊ憭批?璅惜
                string label = size >= 1000 ? $"{size / 1000}K" : size.ToString();
                var textBlock = new TextBlock
                {
                    Text = label,
                    Foreground = Brushes.White,
                    FontSize = 9,
                    FontFamily = new FontFamily("Consolas")
                };

                Canvas.SetRight(textBlock, 5);
                Canvas.SetTop(textBlock, y - 6);
                MarkerCanvas.Children.Add(textBlock);
            }
        }

        /// <summary>
        /// 蝜芾ˊ Sample Lane
        /// </summary>
        private void DrawSampleLane()
        {
            SampleCanvas.Children.Clear();

            double canvasHeight = SampleCanvas.ActualHeight;
            double canvasWidth = SampleCanvas.ActualWidth;

            if (canvasHeight <= 0 || canvasWidth <= 0 || _fragments.Count == 0)
                return;

            int[] markerSizes = _currentMarkerType == MarkerType.Standard 
                ? StandardMarkerSizes 
                : HighResMarkerSizes;

            double maxSize = markerSizes.Max();
            double minSize = markerSizes.Min();

            foreach (var fragment in _fragments)
            {
                double y;
                bool isOutOfRange = false;

                if (fragment.Size > maxSize)
                {
                    // 頞? 10K ??畾蛛??曉??垢
                    y = 10;
                    isOutOfRange = true;
                }
                else if (fragment.Size < minSize)
                {
                    // 憭芸???畾蛛??曉?摨垢
                    y = canvasHeight * MaxBandY;
                    isOutOfRange = true;
                }
                else
                {
                    y = CalculateYPosition(fragment.Size, canvasHeight);
                }

                // 閮? Band 撘瑕漲嚗?寞??挾憭批?隤踵嚗?                double intensity = Math.Min(1.0, Math.Max(0.3, Math.Log10(fragment.Size) / 4.0));

                // 蝜芾ˊ Band
                Color bandColor = isOutOfRange 
                    ? Color.FromRgb(255, 150, 0)  // 璈銵函內頞蝭?
                    : Color.FromRgb(0, 255, 100);

                var band = new Border
                {
                    Width = canvasWidth - 20,
                    Height = 4,
                    Background = new LinearGradientBrush(
                        bandColor,
                        Color.FromArgb((byte)(255 * intensity), bandColor.R, bandColor.G, bandColor.B),
                        0),
                    CornerRadius = new CornerRadius(1),
                    Effect = new System.Windows.Media.Effects.DropShadowEffect
                    {
                        Color = bandColor,
                        BlurRadius = 10,
                        ShadowDepth = 0,
                        Opacity = 0.7
                    },
                    ToolTip = $"{fragment.Size} bp"
                };

                Canvas.SetLeft(band, 10);
                Canvas.SetTop(band, y);
                SampleCanvas.Children.Add(band);

                // 蝜芾ˊ憭批?璅惜
                string label = fragment.Size >= 1000 
                    ? $"{fragment.Size / 1000.0:F1}K" 
                    : fragment.Size.ToString();
                
                var textBlock = new TextBlock
                {
                    Text = label,
                    Foreground = isOutOfRange ? Brushes.Orange : Brushes.LightGreen,
                    FontSize = 8,
                    FontFamily = new FontFamily("Consolas")
                };

                Canvas.SetLeft(textBlock, 5);
                Canvas.SetTop(textBlock, y - 10);
                SampleCanvas.Children.Add(textBlock);
            }
        }

        /// <summary>
        /// 皜???畾?        /// </summary>
        public void Clear()
        {
            _fragments.Clear();
            SampleCanvas.Children.Clear();
        }
    }
}


==================================================
FILE_NAME: RestrictionEnzyme.cs
PATH: D:\programming\BioSAK\BioSAK\Models\RestrictionEnzyme.cs
==================================================
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace BioSAK.Models
{
    /// <summary>
    /// ??嗆蝡舫???    /// </summary>
    public enum OverhangType
    {
        Blunt,      // 撟單??怎垢
        FivePrime,  // 5' 蝒
        ThreePrime  // 3' 蝒
    }

    /// <summary>
    /// ??嗉??芋??    /// </summary>
    public class RestrictionEnzyme
    {
        /// <summary>
        /// ?嗥??迂 (靘?: EcoRI)
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// 霅摨? (靘?: GAATTC)
        /// </summary>
        public string RecognitionSequence { get; set; }

        /// <summary>
        /// 5'??' ?∠??雿蔭 (?詨??潸??亙??絲暺?0-based)
        /// 靘?: G^AATTC ??CutPosition5 = 1
        /// </summary>
        public int CutPosition5 { get; set; }

        /// <summary>
        /// 3'??' ?∠??雿蔭 (?詨??潸??亙??絲暺?0-based)
        /// 靘?: GAATTC ??CutPosition3 = 5 (撠? CTTAA^G)
        /// </summary>
        public int CutPosition3 { get; set; }

        /// <summary>
        /// ?怎垢憿?
        /// </summary>
        public OverhangType OverhangType
        {
            get
            {
                if (CutPosition5 == CutPosition3)
                    return OverhangType.Blunt;
                else if (CutPosition5 < CutPosition3)
                    return OverhangType.FivePrime;
                else
                    return OverhangType.ThreePrime;
            }
        }

        /// <summary>
        /// ??蝒摨?
        /// </summary>
        public string GetOverhangSequence()
        {
            if (OverhangType == OverhangType.Blunt)
                return "";

            int start = Math.Min(CutPosition5, CutPosition3);
            int end = Math.Max(CutPosition5, CutPosition3);
            
            if (start >= 0 && end <= RecognitionSequence.Length)
                return RecognitionSequence.Substring(start, end - start);
            
            return "";
        }

        /// <summary>
        /// 撠??亙????甇??銵券?撘?(?? IUPAC 蝪∩蔥蝣?
        /// </summary>
        public string GetRegexPattern()
        {
            return ConvertToRegex(RecognitionSequence);
        }

        /// <summary>
        /// ????鈭?摨??迤?”??
        /// </summary>
        public string GetReverseComplementRegexPattern()
        {
            string revComp = GetReverseComplement(RecognitionSequence);
            return ConvertToRegex(revComp);
        }

        /// <summary>
        /// ?臬?箏?????(palindromic)
        /// </summary>
        public bool IsPalindromic
        {
            get
            {
                return RecognitionSequence.Equals(
                    GetReverseComplement(RecognitionSequence),
                    StringComparison.OrdinalIgnoreCase);
            }
        }

        /// <summary>
        /// IUPAC 蝪∩蔥蝣澆??”
        /// </summary>
        private static readonly Dictionary<char, string> IupacCodes = new Dictionary<char, string>
        {
            {'A', "A"}, {'T', "T"}, {'G', "G"}, {'C', "C"},
            {'R', "[AG]"},   // puRine
            {'Y', "[CT]"},   // pYrimidine
            {'M', "[AC]"},   // aMino
            {'K', "[GT]"},   // Keto
            {'S', "[GC]"},   // Strong
            {'W', "[AT]"},   // Weak
            {'H', "[ACT]"},  // not G
            {'B', "[CGT]"},  // not A
            {'V', "[ACG]"},  // not T
            {'D', "[AGT]"},  // not C
            {'N', "[ACGT]"}, // aNy
        };

        /// <summary>
        /// 鈭?暽澆撠?銵?        /// </summary>
        private static readonly Dictionary<char, char> ComplementMap = new Dictionary<char, char>
        {
            {'A', 'T'}, {'T', 'A'}, {'G', 'C'}, {'C', 'G'},
            {'R', 'Y'}, {'Y', 'R'}, {'M', 'K'}, {'K', 'M'},
            {'S', 'S'}, {'W', 'W'}, {'H', 'D'}, {'D', 'H'},
            {'B', 'V'}, {'V', 'B'}, {'N', 'N'}
        };

        private static string ConvertToRegex(string sequence)
        {
            var pattern = new System.Text.StringBuilder();
            foreach (char c in sequence.ToUpper())
            {
                if (IupacCodes.TryGetValue(c, out string replacement))
                    pattern.Append(replacement);
                else
                    pattern.Append(c);
            }
            return pattern.ToString();
        }

        private static string GetReverseComplement(string sequence)
        {
            var result = new char[sequence.Length];
            for (int i = 0; i < sequence.Length; i++)
            {
                char c = char.ToUpper(sequence[sequence.Length - 1 - i]);
                result[i] = ComplementMap.TryGetValue(c, out char comp) ? comp : c;
            }
            return new string(result);
        }

        public override string ToString()
        {
            return $"{Name}: {RecognitionSequence} ({OverhangType})";
        }
    }

    /// <summary>
    /// ?雿?鞈?
    /// </summary>
    public class CutSite
    {
        /// <summary>
        /// ?雿蔭 (?典?憪??葉??蝵殷?0-based)
        /// </summary>
        public int Position { get; set; }

        /// <summary>
        /// 雿輻???園
        /// </summary>
        public RestrictionEnzyme Enzyme { get; set; }

        /// <summary>
        /// 霅摨??典?憪??葉?絲憪?蝵?        /// </summary>
        public int RecognitionStart { get; set; }

        /// <summary>
        /// ?臬?典??銝??        /// </summary>
        public bool IsReverseStrand { get; set; }

        /// <summary>
        /// 5' ?∪??脩?撖阡?雿蔭
        /// </summary>
        public int Cut5Position => RecognitionStart + Enzyme.CutPosition5;

        /// <summary>
        /// 3' ?∪??脩?撖阡?雿蔭
        /// </summary>
        public int Cut3Position => RecognitionStart + Enzyme.CutPosition3;

        public override string ToString()
        {
            return $"{Enzyme.Name} @ {Position} ({Enzyme.OverhangType})";
        }
    }

    /// <summary>
    /// DNA ?挾
    /// </summary>
    public class DnaFragment
    {
        /// <summary>
        /// ?挾憭批? (bp)
        /// </summary>
        public int Size { get; set; }

        /// <summary>
        /// ?挾韏瑕?雿蔭 (?典?憪??葉)
        /// </summary>
        public int StartPosition { get; set; }

        /// <summary>
        /// ?挾蝯?雿蔭 (?典?憪??葉)
        /// </summary>
        public int EndPosition { get; set; }

        /// <summary>
        /// 5' 蝡舐???        /// </summary>
        public RestrictionEnzyme Enzyme5End { get; set; }

        /// <summary>
        /// 3' 蝡舐???        /// </summary>
        public RestrictionEnzyme Enzyme3End { get; set; }

        /// <summary>
        /// ?挾摨?
        /// </summary>
        public string Sequence { get; set; }

        public override string ToString()
        {
            return $"{Size} bp ({StartPosition}-{EndPosition})";
        }
    }
}


==================================================
FILE_NAME: TcgaModels.cs
PATH: D:\programming\BioSAK\BioSAK\Models\TcgaModels.cs
==================================================
using System;

namespace BioSAK.Services
{
    /// <summary>
    /// Box Plot 統計資料行
    /// </summary>
    public class BoxPlotStatsRow
    {
        public string CancerCode { get; set; }
        public string GeneId { get; set; }
        public string GeneName { get; set; }

        // Tumor statistics
        public int TumorN { get; set; }
        public double TumorMean { get; set; }
        public double TumorSd { get; set; }
        public double TumorMedian { get; set; }
        public double TumorQ1 { get; set; }
        public double TumorQ3 { get; set; }

        // Normal statistics
        public int NormalN { get; set; }
        public double NormalMean { get; set; }
        public double NormalSd { get; set; }
        public double NormalMedian { get; set; }
        public double NormalQ1 { get; set; }
        public double NormalQ3 { get; set; }

        // Statistical test results
        public double PValue { get; set; }
        public double FDR { get; set; }

        // Display formatters
        public string PValueDisplay => PValue < 0.001 ? $"{PValue:E2}" : $"{PValue:F4}";
        public string FdrDisplay => FDR < 0.001 ? $"{FDR:E2}" : $"{FDR:F4}";

        // Fold change
        public double Log2FoldChange => TumorMean - NormalMean;
        public string Regulation => Log2FoldChange > 0 ? "Up" : "Down";
    }

    /// <summary>
    /// Scatter Plot 資料點
    /// (已在 TcgaAnalysisPage.xaml.cs 中定義，此處為備份)
    /// </summary>
    public class ScatterPoint
    {
        public double X { get; set; }
        public double Y { get; set; }
        public string Condition { get; set; }
        public string SampleId { get; set; }
    }

    /// <summary>
    /// 基因搜尋結果
    /// </summary>
    public class GeneSearchResult
    {
        public string GeneId { get; set; }
        public string GeneName { get; set; }
        public string Description { get; set; }
        public bool Found { get; set; }
        public string OriginalQuery { get; set; }
    }

    /// <summary>
    /// 分析進度報告
    /// </summary>
    public class AnalysisProgress
    {
        public int Percentage { get; set; }
        public string Message { get; set; }
        public string Stage { get; set; }
        public bool IsComplete { get; set; }
        public bool HasError { get; set; }
        public string ErrorMessage { get; set; }
    }

    /// <summary>
    /// 匯出設定
    /// </summary>
    public class ExportSettings
    {
        public string FilePath { get; set; }
        public string FileFormat { get; set; }  // "PNG", "CSV", "TSV", "XLSX"
        public int ImageWidth { get; set; } = 800;
        public int ImageHeight { get; set; } = 600;
        public int DPI { get; set; } = 96;
        public bool IncludeHeader { get; set; } = true;
        public string Delimiter { get; set; } = ",";
    }
}


==================================================
FILE_NAME: AxisSettingsDialog.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\AxisSettingsDialog.xaml
==================================================
<Window x:Class="BioSAK.AxisSettingsDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Axis Settings" 
        Height="620" Width="420"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">
    
    <ScrollViewer VerticalScrollBarVisibility="Auto">
        <Grid Margin="20">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>

            <TextBlock Grid.Row="0" x:Name="TitleText" Text="Y Axis Settings" FontSize="18" FontWeight="Bold" 
                       Foreground="#333" Margin="0,0,0,15"/>

            <!-- Scale Settings -->
            <GroupBox Grid.Row="1" Header="Scale" Padding="10" Margin="0,0,0,10">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <CheckBox Grid.Row="0" Grid.ColumnSpan="2" x:Name="AutoScaleCheck" 
                              Content="Auto Scale (round to nice numbers)" IsChecked="True" Margin="0,0,0,8"/>

                    <CheckBox Grid.Row="1" Grid.ColumnSpan="2" x:Name="LogScaleCheck" 
                              Content="Logarithmic Scale (Log10)" Margin="0,0,0,8"/>

                    <TextBlock Grid.Row="2" Grid.Column="0" Text="Minimum:" VerticalAlignment="Center" Margin="0,0,10,5"/>
                    <TextBox Grid.Row="2" Grid.Column="1" x:Name="MinValueBox" Text="0" Width="100" 
                             HorizontalAlignment="Left" Margin="0,0,0,5" IsEnabled="False"/>

                    <TextBlock Grid.Row="3" Grid.Column="0" Text="Maximum:" VerticalAlignment="Center" Margin="0,0,10,0"/>
                    <TextBox Grid.Row="3" Grid.Column="1" x:Name="MaxValueBox" Text="100" Width="100" 
                             HorizontalAlignment="Left" IsEnabled="False"/>
                </Grid>
            </GroupBox>

            <!-- Tick Marks / Scale Lines -->
            <GroupBox Grid.Row="2" Header="Tick Marks" Padding="10" Margin="0,0,0,10">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <!-- Main Scale -->
                    <TextBlock Grid.Row="0" Grid.ColumnSpan="2" Text="Main Scale (Major Ticks)" 
                               FontWeight="SemiBold" Margin="0,0,0,5"/>
                    
                    <TextBlock Grid.Row="1" Grid.Column="0" Text="Interval:" VerticalAlignment="Center" Margin="15,0,10,5"/>
                    <StackPanel Grid.Row="1" Grid.Column="1" Orientation="Horizontal" Margin="0,0,0,5">
                        <TextBox x:Name="MainScaleIntervalBox" Text="0" Width="60"/>
                        <TextBlock Text="(0 = auto)" Foreground="#888" Margin="5,0,0,0" VerticalAlignment="Center"/>
                    </StackPanel>

                    <!-- Sub Scale -->
                    <TextBlock Grid.Row="2" Grid.ColumnSpan="2" Text="Sub Scale (Minor Ticks)" 
                               FontWeight="SemiBold" Margin="0,10,0,5"/>
                    
                    <CheckBox Grid.Row="3" Grid.ColumnSpan="2" x:Name="ShowSubScaleCheck" 
                              Content="Show minor ticks" Margin="15,0,0,5"/>
                    
                    <TextBlock Grid.Row="4" Grid.Column="0" Text="Divisions:" VerticalAlignment="Center" Margin="15,0,10,0"/>
                    <StackPanel Grid.Row="4" Grid.Column="1" Orientation="Horizontal">
                        <TextBox x:Name="SubScaleDivisionsBox" Text="5" Width="60" IsEnabled="False"/>
                        <TextBlock Text="per major tick" Foreground="#888" Margin="5,0,0,0" VerticalAlignment="Center"/>
                    </StackPanel>
                </Grid>
            </GroupBox>

            <!-- Grid Lines -->
            <GroupBox Grid.Row="3" Header="Grid Lines" Padding="10" Margin="0,0,0,10">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <CheckBox Grid.Row="0" Grid.ColumnSpan="2" x:Name="ShowGridLinesCheck" 
                              Content="Show Grid Lines (at major ticks)" Margin="0,0,0,8"/>

                    <TextBlock Grid.Row="1" Grid.Column="0" Text="Line Style:" VerticalAlignment="Center" Margin="0,0,10,5"/>
                    <ComboBox Grid.Row="1" Grid.Column="1" x:Name="GridLineStyleCombo" Width="120" 
                              HorizontalAlignment="Left" Margin="0,0,0,5" IsEnabled="False">
                        <ComboBoxItem Content="Solid" IsSelected="True"/>
                        <ComboBoxItem Content="Dashed"/>
                        <ComboBoxItem Content="Dotted"/>
                    </ComboBox>

                    <TextBlock Grid.Row="2" Grid.Column="0" Text="Line Color:" VerticalAlignment="Center" Margin="0,0,10,0"/>
                    <StackPanel Grid.Row="2" Grid.Column="1" Orientation="Horizontal">
                        <Border x:Name="GridLineColorPreview" Width="30" Height="20" Background="#E0E0E0" 
                                BorderBrush="#999" BorderThickness="1" Cursor="Hand"
                                MouseLeftButtonDown="GridLineColorPreview_Click"/>
                        <Button Content="Choose..." Padding="5,2" Margin="10,0,0,0" 
                                x:Name="GridLineColorBtn" Click="GridLineColor_Click" IsEnabled="False"/>
                    </StackPanel>
                </Grid>
            </GroupBox>

            <!-- Axis Break (Segment) -->
            <GroupBox Grid.Row="4" Header="Axis Break (Segment)" Padding="10" Margin="0,0,0,10">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <CheckBox Grid.Row="0" Grid.ColumnSpan="2" x:Name="EnableBreakCheck" 
                              Content="Enable Axis Break" Margin="0,0,0,8"/>

                    <TextBlock Grid.Row="1" Grid.Column="0" Text="Break Start:" VerticalAlignment="Center" Margin="0,0,10,5"/>
                    <TextBox Grid.Row="1" Grid.Column="1" x:Name="BreakStartBox" Text="0" Width="100" 
                             HorizontalAlignment="Left" Margin="0,0,0,5" IsEnabled="False"/>

                    <TextBlock Grid.Row="2" Grid.Column="0" Text="Break End:" VerticalAlignment="Center" Margin="0,0,10,0"/>
                    <TextBox Grid.Row="2" Grid.Column="1" x:Name="BreakEndBox" Text="0" Width="100" 
                             HorizontalAlignment="Left" IsEnabled="False"/>
                </Grid>
            </GroupBox>

            <!-- Axis Title -->
            <GroupBox Grid.Row="5" Header="Axis Title" Padding="10" Margin="0,0,0,10">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>

                    <TextBlock Grid.Column="0" Text="Title:" VerticalAlignment="Center" Margin="0,0,10,0"/>
                    <TextBox Grid.Column="1" x:Name="AxisTitleBox" Text="" />
                </Grid>
            </GroupBox>

            <StackPanel Grid.Row="6" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,10,0,0">
                <Button Content="Cancel" Width="80" Padding="5,8" Margin="0,0,10,0"
                        Background="#9E9E9E" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="Cancel_Click"/>
                <Button Content="OK" Width="80" Padding="5,8"
                        Background="#4CAF50" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="OK_Click"/>
            </StackPanel>
        </Grid>
    </ScrollViewer>
</Window>


==================================================
FILE_NAME: AxisSettingsDialog.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\AxisSettingsDialog.xaml.cs
==================================================
using System.Windows;
using System.Windows.Media;

namespace BioSAK
{
    public partial class AxisSettingsDialog : Window
    {
        public bool IsYAxis { get; private set; }
        
        // Scale settings
        public bool AutoScale { get; private set; } = true;
        public bool LogScale { get; private set; } = false;
        public double MinValue { get; private set; } = 0;
        public double MaxValue { get; private set; } = 100;
        
        // Tick mark settings
        public double MainScaleInterval { get; private set; } = 0; // 0 = auto
        public bool ShowSubScale { get; private set; } = false;
        public int SubScaleDivisions { get; private set; } = 5;
        
        // Axis break settings
        public bool EnableBreak { get; private set; } = false;
        public double BreakStart { get; private set; } = 0;
        public double BreakEnd { get; private set; } = 0;
        
        // Grid line settings
        public bool ShowGridLines { get; private set; } = false;
        public string GridLineStyle { get; private set; } = "Solid";
        public Color GridLineColor { get; private set; } = Color.FromRgb(224, 224, 224);
        
        // Title
        public string AxisTitle { get; private set; } = "";

        private Color currentGridColor = Color.FromRgb(224, 224, 224);

        public AxisSettingsDialog(bool isYAxis, string currentTitle, double currentMin, double currentMax,
            bool showGrid = false, string gridStyle = "Solid", Color? gridColor = null, double mainInterval = 0,
            bool showSubScale = false, int subDivisions = 5, bool logScale = false)
        {
            InitializeComponent();
            
            IsYAxis = isYAxis;
            TitleText.Text = isYAxis ? "Y Axis Settings" : "X Axis Settings";
            
            AxisTitleBox.Text = currentTitle;
            MinValueBox.Text = currentMin.ToString("G4");
            MaxValueBox.Text = currentMax.ToString("G4");
            
            // Log scale
            LogScaleCheck.IsChecked = logScale;
            
            // Tick marks
            MainScaleIntervalBox.Text = mainInterval.ToString("G4");
            ShowSubScaleCheck.IsChecked = showSubScale;
            SubScaleDivisionsBox.Text = subDivisions.ToString();
            SubScaleDivisionsBox.IsEnabled = showSubScale;
            
            // Grid lines
            ShowGridLines = showGrid;
            ShowGridLinesCheck.IsChecked = showGrid;
            GridLineStyle = gridStyle;
            if (gridColor.HasValue)
            {
                currentGridColor = gridColor.Value;
                GridLineColorPreview.Background = new SolidColorBrush(currentGridColor);
            }
            
            // Set grid line style combo
            foreach (System.Windows.Controls.ComboBoxItem item in GridLineStyleCombo.Items)
            {
                if (item.Content?.ToString() == gridStyle)
                {
                    GridLineStyleCombo.SelectedItem = item;
                    break;
                }
            }
            
            // Set initial enabled states
            MinValueBox.IsEnabled = false;
            MaxValueBox.IsEnabled = false;
            BreakStartBox.IsEnabled = false;
            BreakEndBox.IsEnabled = false;
            GridLineStyleCombo.IsEnabled = showGrid;
            GridLineColorBtn.IsEnabled = showGrid;
            
            // Add event handlers after initialization
            AutoScaleCheck.Checked += AutoScale_Changed;
            AutoScaleCheck.Unchecked += AutoScale_Changed;
            EnableBreakCheck.Checked += EnableBreak_Changed;
            EnableBreakCheck.Unchecked += EnableBreak_Changed;
            ShowGridLinesCheck.Checked += ShowGridLines_Changed;
            ShowGridLinesCheck.Unchecked += ShowGridLines_Changed;
            ShowSubScaleCheck.Checked += ShowSubScale_Changed;
            ShowSubScaleCheck.Unchecked += ShowSubScale_Changed;
        }

        private void AutoScale_Changed(object sender, RoutedEventArgs e)
        {
            bool enabled = AutoScaleCheck.IsChecked != true;
            MinValueBox.IsEnabled = enabled;
            MaxValueBox.IsEnabled = enabled;
        }

        private void EnableBreak_Changed(object sender, RoutedEventArgs e)
        {
            bool enabled = EnableBreakCheck.IsChecked == true;
            BreakStartBox.IsEnabled = enabled;
            BreakEndBox.IsEnabled = enabled;
        }

        private void ShowGridLines_Changed(object sender, RoutedEventArgs e)
        {
            bool enabled = ShowGridLinesCheck.IsChecked == true;
            GridLineStyleCombo.IsEnabled = enabled;
            GridLineColorBtn.IsEnabled = enabled;
        }

        private void ShowSubScale_Changed(object sender, RoutedEventArgs e)
        {
            SubScaleDivisionsBox.IsEnabled = ShowSubScaleCheck.IsChecked == true;
        }

        private void GridLineColor_Click(object sender, RoutedEventArgs e)
        {
            OpenColorPicker();
        }

        private void GridLineColorPreview_Click(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            if (ShowGridLinesCheck.IsChecked == true)
                OpenColorPicker();
        }

        private void OpenColorPicker()
        {
            var dialog = new ColorPickerDialog(currentGridColor);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                currentGridColor = dialog.SelectedColor;
                GridLineColorPreview.Background = new SolidColorBrush(currentGridColor);
            }
        }

        private void OK_Click(object sender, RoutedEventArgs e)
        {
            // Parse scale values
            AutoScale = AutoScaleCheck.IsChecked == true;
            LogScale = LogScaleCheck.IsChecked == true;
            
            if (!AutoScale)
            {
                if (!double.TryParse(MinValueBox.Text, out double min))
                {
                    MessageBox.Show("Invalid minimum value.", "Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }
                if (!double.TryParse(MaxValueBox.Text, out double max))
                {
                    MessageBox.Show("Invalid maximum value.", "Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }
                MinValue = min;
                MaxValue = max;
            }
            
            // Parse tick mark settings
            if (!double.TryParse(MainScaleIntervalBox.Text, out double mainInt))
                mainInt = 0;
            MainScaleInterval = mainInt;
            
            ShowSubScale = ShowSubScaleCheck.IsChecked == true;
            if (!int.TryParse(SubScaleDivisionsBox.Text, out int subDiv) || subDiv < 2)
                subDiv = 5;
            SubScaleDivisions = subDiv;
            
            // Parse break values
            EnableBreak = EnableBreakCheck.IsChecked == true;
            if (EnableBreak)
            {
                if (!double.TryParse(BreakStartBox.Text, out double breakStart) ||
                    !double.TryParse(BreakEndBox.Text, out double breakEnd))
                {
                    MessageBox.Show("Invalid break values.", "Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }
                BreakStart = breakStart;
                BreakEnd = breakEnd;
            }
            
            // Grid line settings
            ShowGridLines = ShowGridLinesCheck.IsChecked == true;
            GridLineStyle = (GridLineStyleCombo.SelectedItem as System.Windows.Controls.ComboBoxItem)?.Content?.ToString() ?? "Solid";
            GridLineColor = currentGridColor;
            
            // Title
            AxisTitle = AxisTitleBox.Text;

            DialogResult = true;
            Close();
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}


==================================================
FILE_NAME: BarChartSettingsWindow.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\BarChartSettingsWindow.xaml
==================================================
<Window x:Class="BioSAK.BarChartSettingsWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Chart Settings" 
        Height="480" Width="450"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Chart Settings" FontSize="16" FontWeight="Bold" Margin="0,0,0,15"/>

        <!-- Title Settings -->
        <GroupBox Grid.Row="1" Header="Titles" Padding="10" Margin="0,0,0,10">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="100"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <TextBlock Grid.Row="0" Grid.Column="0" Text="Chart Title:" VerticalAlignment="Center" Margin="0,5"/>
                <TextBox Grid.Row="0" Grid.Column="1" x:Name="ChartTitleBox" Margin="0,5" Padding="5,3"/>

                <TextBlock Grid.Row="1" Grid.Column="0" Text="X Axis Title:" VerticalAlignment="Center" Margin="0,5"/>
                <TextBox Grid.Row="1" Grid.Column="1" x:Name="XAxisTitleBox" Margin="0,5" Padding="5,3"/>

                <TextBlock Grid.Row="2" Grid.Column="0" Text="Y Axis Title:" VerticalAlignment="Center" Margin="0,5"/>
                <TextBox Grid.Row="2" Grid.Column="1" x:Name="YAxisTitleBox" Margin="0,5" Padding="5,3"/>
            </Grid>
        </GroupBox>

        <!-- Error Bar Settings -->
        <GroupBox Grid.Row="2" Header="Error Bars" Padding="10" Margin="0,0,0,10">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <TextBlock Grid.Row="0" Grid.Column="0" Text="Line Thickness:" 
                           VerticalAlignment="Center" Margin="0,0,15,0"/>
                <StackPanel Grid.Row="0" Grid.Column="1" Orientation="Horizontal">
                    <Slider x:Name="ErrorBarThicknessSlider" Width="180" Minimum="0.5" Maximum="5" Value="1.5" 
                            TickFrequency="0.5" IsSnapToTickEnabled="True" VerticalAlignment="Center"
                            ValueChanged="ThicknessSlider_ValueChanged"/>
                    <TextBlock x:Name="ErrorBarThicknessLabel" Text="1.5" Width="35" 
                               VerticalAlignment="Center" Margin="10,0,0,0"/>
                </StackPanel>
            </Grid>
        </GroupBox>

        <!-- Data Points Settings -->
        <GroupBox Grid.Row="3" Header="Data Points" Padding="10" Margin="0,0,0,10">
            <StackPanel>
                <CheckBox x:Name="ShowDataPointsCheck" Content="Show individual data points on bars" 
                          Margin="0,0,0,8"/>
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    
                    <TextBlock Grid.Column="0" Text="Point Size:" VerticalAlignment="Center" Margin="0,0,15,0"/>
                    <StackPanel Grid.Column="1" Orientation="Horizontal">
                        <Slider x:Name="DataPointSizeSlider" Width="180" Minimum="2" Maximum="12" Value="5" 
                                TickFrequency="1" IsSnapToTickEnabled="True" VerticalAlignment="Center"
                                ValueChanged="PointSizeSlider_ValueChanged"/>
                        <TextBlock x:Name="DataPointSizeLabel" Text="5" Width="35" 
                                   VerticalAlignment="Center" Margin="10,0,0,0"/>
                    </StackPanel>
                </Grid>
            </StackPanel>
        </GroupBox>

        <!-- Buttons -->
        <StackPanel Grid.Row="5" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,20,0,0">
            <Button Content="Cancel" Width="80" Padding="5,10" Margin="0,0,10,0"
                    Background="#9E9E9E" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="Cancel_Click"/>
            <Button Content="OK" Width="80" Padding="5,10"
                    Background="#4CAF50" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="OK_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: BarChartSettingsWindow.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\BarChartSettingsWindow.xaml.cs
==================================================
using System.Collections.Generic;
using System.Windows;

namespace BioSAK
{
    public partial class BarChartSettingsWindow : Window
    {
        public string ChartTitle { get; private set; } = "";
        public string XAxisTitle { get; private set; } = "";
        public string YAxisTitle { get; private set; } = "";
        
        // Error bar settings
        public double ErrorBarThickness { get; private set; } = 1.5;
        
        // Data point settings
        public bool ShowDataPoints { get; private set; } = false;
        public double DataPointSize { get; private set; } = 5;

        public BarChartSettingsWindow(List<ChartDataSeries> data, string chartTitle, string xTitle, string yTitle,
            double errorBarThickness = 1.5, bool showDataPoints = false, double dataPointSize = 5)
        {
            InitializeComponent();

            ChartTitleBox.Text = chartTitle;
            XAxisTitleBox.Text = xTitle;
            YAxisTitleBox.Text = yTitle;
            
            ErrorBarThicknessSlider.Value = errorBarThickness;
            ErrorBarThicknessLabel.Text = errorBarThickness.ToString("F1");
            
            ShowDataPointsCheck.IsChecked = showDataPoints;
            DataPointSizeSlider.Value = dataPointSize;
            DataPointSizeLabel.Text = dataPointSize.ToString("F0");
        }

        private void ThicknessSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (ErrorBarThicknessLabel != null && ErrorBarThicknessSlider != null)
                ErrorBarThicknessLabel.Text = ErrorBarThicknessSlider.Value.ToString("F1");
        }

        private void PointSizeSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (DataPointSizeLabel != null && DataPointSizeSlider != null)
                DataPointSizeLabel.Text = DataPointSizeSlider.Value.ToString("F0");
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }

        private void OK_Click(object sender, RoutedEventArgs e)
        {
            ChartTitle = ChartTitleBox.Text;
            XAxisTitle = XAxisTitleBox.Text;
            YAxisTitle = YAxisTitleBox.Text;
            
            ErrorBarThickness = ErrorBarThicknessSlider.Value;
            ShowDataPoints = ShowDataPointsCheck.IsChecked == true;
            DataPointSize = DataPointSizeSlider.Value;

            DialogResult = true;
            Close();
        }
    }
}


==================================================
FILE_NAME: BarChartWindow.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\BarChartWindow.xaml
==================================================
<Window x:Class="BioSAK.BarChartWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Bar Chart" 
        Height="750" Width="1000"
        MinHeight="500" MinWidth="700"
        WindowStartupLocation="CenterOwner"
        Background="#F5F5F5"
        KeyDown="Window_KeyDown"
        Focusable="True">

    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Main Toolbar -->
        <Border Grid.Row="0" Background="White" CornerRadius="5" Padding="10" Margin="0,0,0,5">
            <StackPanel Orientation="Horizontal">
                <Button Content="? Save PNG" Padding="8,5" Margin="0,0,5,0"
                        Background="#4CAF50" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="SaveAsPng_Click"/>
                <Button Content="? Save SVG" Padding="8,5" Margin="0,0,10,0"
                        Background="#2196F3" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="SaveAsSvg_Click"/>
                <Separator Margin="5,0"/>
                <Button Content="?? Copy" Padding="8,5" Margin="5,0"
                        Background="#9C27B0" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="CopyToClipboard_Click" ToolTip="Ctrl+C"/>
                <Separator Margin="5,0"/>
                <Button Content="?? Statistics" Padding="8,5" Margin="5,0"
                        Background="#FF5722" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="OpenStatistics_Click"/>
                <Separator Margin="5,0"/>
                <Button Content="? Edit Bars" Padding="8,5" Margin="5,0"
                        Background="#795548" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="EditBars_Click" ToolTip="Edit bar colors and patterns"/>
                <Separator Margin="5,0"/>
                <TextBlock Text="Size:" VerticalAlignment="Center" Margin="5,0,5,0" FontWeight="SemiBold"/>
                <ComboBox x:Name="SizePresetCombo" Width="100" Margin="0,0,5,0" 
                          SelectionChanged="SizePreset_Changed" ToolTip="Preset sizes">
                    <ComboBoxItem Content="Auto Fit" Tag="0,0"/>
                    <ComboBoxItem Content="800?500" Tag="800,500" IsSelected="True"/>
                    <ComboBoxItem Content="1024?768" Tag="1024,768"/>
                    <ComboBoxItem Content="1280?720" Tag="1280,720"/>
                    <ComboBoxItem Content="1920?1080" Tag="1920,1080"/>
                    <ComboBoxItem Content="Custom..." Tag="custom"/>
                </ComboBox>
                <TextBox x:Name="ChartWidthBox" Width="50" Text="800" VerticalAlignment="Center" 
                         TextAlignment="Center" ToolTip="Chart width (px)" Visibility="Collapsed"/>
                <TextBlock x:Name="SizeXLabel" Text="?" VerticalAlignment="Center" Margin="3,0" Visibility="Collapsed"/>
                <TextBox x:Name="ChartHeightBox" Width="50" Text="500" VerticalAlignment="Center" 
                         TextAlignment="Center" ToolTip="Chart height (px)" Visibility="Collapsed"/>
                <Button x:Name="ApplySizeBtn" Content="Apply" Padding="5,3" Margin="5,0" Click="ApplyChartSize_Click"
                        Background="#607D8B" Foreground="White" BorderThickness="0" Cursor="Hand" Visibility="Collapsed"/>
            </StackPanel>
        </Border>

        <!-- Annotation Toolbar -->
        <Border Grid.Row="1" Background="White" CornerRadius="5" Padding="10" Margin="0,0,0,5">
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="Add:" VerticalAlignment="Center" Margin="0,0,10,0" FontWeight="SemiBold"/>
                
                <Button Content="?? Text" Padding="8,5" Margin="0,0,5,0"
                        Background="#FF9800" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddTextBox_Click"/>
                
                <Button Content="峏 Symbol" Padding="8,5" Margin="0,0,5,0"
                        Background="#9C27B0" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="OpenSymbolPicker_Click"/>
                
                <Separator Margin="10,0"/>
                <TextBlock Text="Lines:" VerticalAlignment="Center" Margin="0,0,10,0" FontWeight="SemiBold"/>
                
                <Button Content="?" Padding="10,5" Margin="0,0,3,0"
                        Background="#607D8B" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddLine_Click" Tag="Line"/>
                <Button Content="??" Padding="10,5" Margin="0,0,3,0"
                        Background="#607D8B" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddLine_Click" Tag="UShape"/>
                <Button Content="?? Padding="10,5" Margin="0,0,3,0"
                        Background="#607D8B" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddLine_Click" Tag="Arrow"/>
                <Button Content="?" Padding="10,5" Margin="0,0,3,0"
                        Background="#607D8B" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddLine_Click" Tag="HShape"/>
                
                <Separator Margin="10,0"/>
                <Button Content="?? Delete" Padding="8,5"
                        Background="#EF5350" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="DeleteSelected_Click"/>
            </StackPanel>
        </Border>

        <!-- Chart Area with ScrollViewer for resizable chart -->
        <Border Grid.Row="2" Background="#E0E0E0" CornerRadius="5" ClipToBounds="True">
            <ScrollViewer x:Name="ChartScrollViewer" 
                          HorizontalScrollBarVisibility="Auto" 
                          VerticalScrollBarVisibility="Auto"
                          Background="#E0E0E0">
                <Grid x:Name="ChartContainer">
                    <Canvas x:Name="ChartCanvas" Background="White" 
                            MouseLeftButtonDown="ChartCanvas_MouseLeftButtonDown"
                            MouseMove="ChartCanvas_MouseMove"
                            MouseLeftButtonUp="ChartCanvas_MouseLeftButtonUp"
                            SizeChanged="ChartCanvas_SizeChanged"/>
                    <Rectangle x:Name="SelectionRect" Stroke="#2196F3" StrokeThickness="1" 
                               StrokeDashArray="4 2" Fill="#202196F3" Visibility="Collapsed"/>
                </Grid>
            </ScrollViewer>
        </Border>

        <!-- Legend (hidden, now drawn on canvas) -->
        <Border Grid.Row="3" Background="Transparent" Padding="5" Margin="0,5,0,0" Visibility="Collapsed">
            <WrapPanel x:Name="LegendPanel" HorizontalAlignment="Center"/>
        </Border>
    </Grid>
</Window>


==================================================
FILE_NAME: BarChartWindow.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\BarChartWindow.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using Microsoft.Win32;

namespace BioSAK
{
    public partial class BarChartWindow : Window
    {
        private List<ChartDataSeries> dataSeries;
        private string chartType; // "Column" or "MultiGroup"
        private string errorType;
        private string xAxisTitle;
        private string yAxisTitle = "Y";
        private string chartTitle = "";

        private double marginLeft = 70;
        private double marginRight = 30;
        private double marginTop = 50;
        private double marginBottom = 60;

        // Chart size control
        private bool useFixedSize = false;
        private double fixedChartWidth = 800;
        private double fixedChartHeight = 500;

        // Bar appearance settings: [seriesIndex, xIndex] -> BarStyle
        private Dictionary<(int, int), BarStyle> barStyles = new Dictionary<(int, int), BarStyle>();
        
        // Bar rectangles for click detection
        private List<BarInfo> barInfos = new List<BarInfo>();

        // Error bar and display settings
        private double errorBarThickness = 1.5;
        private bool showDataPoints = false;
        private double dataPointSize = 5;
        private ErrorBarDirection defaultErrorDirection = ErrorBarDirection.Both;
        
        // Grid line settings
        private bool showGridLines = false;
        private string gridLineStyle = "Solid";
        private Color gridLineColor = Color.FromRgb(224, 224, 224);
        
        // Scale settings
        private bool autoScale = true;
        private bool logScale = false;
        private double yMin = 0;
        private double yMax = 100;
        private double mainScaleInterval = 0; // 0 = auto
        private bool showSubScale = false;
        private int subScaleDivisions = 5;
        
        // Axis break settings
        private bool enableAxisBreak = false;
        private double axisBreakStart = 0;
        private double axisBreakEnd = 0;

        // Floating legend
        private Border? legendBorder = null;
        private bool isLegendDragging = false;
        private Point legendDragStart;
        private Point legendStartPosition;

        // Annotation system
        private List<FrameworkElement> annotations = new List<FrameworkElement>();
        private List<FrameworkElement> selectedAnnotations = new List<FrameworkElement>();
        private FrameworkElement? selectedAnnotation = null;
        private bool isDragging = false;
        private bool isSelecting = false;
        private Point dragStart;
        private Point elementStart;
        private Point selectionStart;

        private DateTime lastClickTime = DateTime.MinValue;
        private FrameworkElement? lastClickedElement = null;
        private bool isTextAddMode = false;
        private bool isResizing = false;              // ?臬甇?隤踵憭批?
        private string currentResizeHandle = "";      // ?嗅????handle ?迂
        private Canvas? currentLineCanvas = null;     // ?嗅?甇?隤踵??璇?Canvas
        private readonly Color[] defaultColors = new Color[]
        {
            Color.FromRgb(66, 133, 244), Color.FromRgb(234, 67, 53),
            Color.FromRgb(52, 168, 83), Color.FromRgb(251, 188, 5),
            Color.FromRgb(154, 71, 182), Color.FromRgb(255, 112, 67),
            Color.FromRgb(0, 172, 193), Color.FromRgb(124, 77, 255),
        };

        public BarChartWindow(List<ChartDataSeries> data, string type, string error, string xTitle, 
            string errorDirection = "Both")
        {
            InitializeComponent();
            dataSeries = data;
            chartType = type;
            errorType = error;
            xAxisTitle = xTitle;
            chartTitle = type == "Column" ? "Column Chart" : "Multi Factors Chart";
            
            // Set default error direction
            defaultErrorDirection = errorDirection switch
            {
                "Up" => ErrorBarDirection.Up,
                "Down" => ErrorBarDirection.Down,
                _ => ErrorBarDirection.Both
            };

            InitializeBarStyles();
            this.Loaded += (s, e) => 
            { 
                // Set initial chart size from text boxes or fit to window
                if (double.TryParse(ChartWidthBox.Text, out double w) && 
                    double.TryParse(ChartHeightBox.Text, out double h))
                {
                    ChartCanvas.Width = w;
                    ChartCanvas.Height = h;
                }
                DrawChart(); 
                this.Focus(); 
            };
        }

        private void InitializeBarStyles()
        {
            for (int s = 0; s < dataSeries.Count; s++)
            {
                for (int x = 0; x < dataSeries[s].XValues.Count; x++)
                {
                    // For Column chart: color by series (s)
                    // For MultiGroup chart: color by X index (x)
                    int colorIndex = (chartType == "Column") ? s : x;
                    
                    barStyles[(s, x)] = new BarStyle
                    {
                        FillColor = defaultColors[colorIndex % defaultColors.Length],
                        BorderColor = Colors.Black,
                        BorderThickness = 1,
                        Pattern = FillPattern.Solid,
                        ErrorDirection = defaultErrorDirection
                    };
                }
            }
        }

        #region Keyboard and Mouse Events

        private void Window_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Delete)
            {
                DeleteSelectedAnnotations();
                e.Handled = true;
            }
            else if (Keyboard.Modifiers == ModifierKeys.Control)
            {
                switch (e.Key)
                {
                    case Key.C: CopyChartToClipboard(); e.Handled = true; break;
                    case Key.A: SelectAllAnnotations(); e.Handled = true; break;
                }
            }
        }

        private void ChartCanvas_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            DrawChart();
            
            // Update size textboxes if not in fixed size mode
            if (!useFixedSize && ChartWidthBox != null && ChartHeightBox != null && 
                ChartCanvas.ActualWidth > 0 && ChartCanvas.ActualHeight > 0)
            {
                ChartWidthBox.Text = ((int)ChartCanvas.ActualWidth).ToString();
                ChartHeightBox.Text = ((int)ChartCanvas.ActualHeight).ToString();
            }
        }

        private void ChartCanvas_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            var pos = e.GetPosition(ChartCanvas);
            var now = DateTime.Now;

            // === ?啣?: ????瘛餃?璅∪? ===
            if (isTextAddMode)
            {
                isTextAddMode = false;
                ChartCanvas.Cursor = Cursors.Arrow;

                // ?Ｗ儔??憿
               
                CreateEditableTextAtPosition(pos);
                return;
            }
            // Check if clicked on annotation

            var hitElement = FindAnnotationAt(pos);
            if (hitElement != null)
            {
                bool isDoubleClick = (now - lastClickTime).TotalMilliseconds < 300 && lastClickedElement == hitElement;
                if (isDoubleClick)
                {
                    EditAnnotation(hitElement);
                }
                else
                {
                    ClearSelection();
                    SelectAnnotation(hitElement);
                    isDragging = true;
                    dragStart = pos;
                    elementStart = new Point(Canvas.GetLeft(hitElement), Canvas.GetTop(hitElement));
                    ChartCanvas.CaptureMouse();
                }
                lastClickTime = now;
                lastClickedElement = hitElement;
                return;
            }

            // Check if clicked on bar
            var clickedBar = barInfos.FirstOrDefault(b => b.Bounds.Contains(pos));
            if (clickedBar != null)
            {
                bool isDoubleClick = (now - lastClickTime).TotalMilliseconds < 300;
                if (isDoubleClick)
                {
                    EditSingleBar(clickedBar.SeriesIndex, clickedBar.XIndex);
                }
                lastClickTime = now;
                lastClickedElement = null;
                return;
            }

            // Start selection rectangle or open settings
            ClearSelection();
            bool isDoubleClickEmpty = (now - lastClickTime).TotalMilliseconds < 300 && lastClickedElement == null;
            if (isDoubleClickEmpty)
            {
                OpenSettingsDialog();
            }
            else
            {
                isSelecting = true;
                selectionStart = pos;
                SelectionRect.Visibility = Visibility.Visible;
                Canvas.SetLeft(SelectionRect, pos.X);
                Canvas.SetTop(SelectionRect, pos.Y);
                SelectionRect.Width = 0;
                SelectionRect.Height = 0;
                ChartCanvas.CaptureMouse();
            }
            lastClickTime = now;
            lastClickedElement = null;
        }
        private void CreateEditableTextAtPosition(Point position)
        {
            // ?萄遣?舐楊頛舐? TextBox
            var textBox = new TextBox
            {
                Text = "",
                FontSize = 12,
                MinWidth = 60,
                MinHeight = 24,
                Background = new SolidColorBrush(Color.FromArgb(250, 255, 255, 255)),
                BorderBrush = new SolidColorBrush(Color.FromRgb(33, 150, 243)),
                BorderThickness = new Thickness(2),
                Padding = new Thickness(4, 2, 4, 2),
                AcceptsReturn = true,
                TextWrapping = TextWrapping.NoWrap
            };

            Canvas.SetLeft(textBox, position.X);
            Canvas.SetTop(textBox, position.Y);
            ChartCanvas.Children.Add(textBox);

            // 閮剔蔭?阡?霈?嗅隞亦??唾撓??
            textBox.Loaded += (s, args) =>
            {
                textBox.Focus();
                Keyboard.Focus(textBox);
            };

            // ??摰?蝺刻摩
            textBox.LostFocus += (s, args) => FinalizeTextInput(textBox);

            textBox.PreviewKeyDown += (s, args) =>
            {
                if (args.Key == Key.Enter && Keyboard.Modifiers != ModifierKeys.Shift)
                {
                    // Enter 摰?蝺刻摩嚗hift+Enter ??嚗?
                    FinalizeTextInput(textBox);
                    args.Handled = true;
                }
                else if (args.Key == Key.Escape)
                {
                    // Escape ??
                    ChartCanvas.Children.Remove(textBox);
                    args.Handled = true;
                }
            };
        }
        private void FinalizeTextInput(TextBox textBox)
        {
            // ?脫迫???瑁?
            if (!ChartCanvas.Children.Contains(textBox))
                return;

            string text = textBox.Text.Trim();
            double left = Canvas.GetLeft(textBox);
            double top = Canvas.GetTop(textBox);

            // 蝘駁 TextBox
            ChartCanvas.Children.Remove(textBox);

            // 憒????箇征嚗??萄遣 annotation
            if (string.IsNullOrEmpty(text))
                return;

            // ?萄遣 TextBlock annotation
            var tb = new TextBlock
            {
                Text = text,
                FontSize = 12,
                Padding = new Thickness(5),
                Foreground = Brushes.Black
            };

            var border = new Border
            {
                Child = tb,
                Background = Brushes.Transparent,
                Cursor = Cursors.SizeAll
            };

            Canvas.SetLeft(border, left);
            Canvas.SetTop(border, top);
            ChartCanvas.Children.Add(border);
            annotations.Add(border);
        }
        private void ConvertTextBoxToAnnotation(TextBox textBox)
        {
            // 瑼Ｘ TextBox ?臬??怠?銝?
            if (!ChartCanvas.Children.Contains(textBox))
                return;

            string text = textBox.Text.Trim();
            double left = Canvas.GetLeft(textBox);
            double top = Canvas.GetTop(textBox);

            // 蝘駁 TextBox
            ChartCanvas.Children.Remove(textBox);

            // 憒????箇征嚗??萄遣 annotation
            if (string.IsNullOrEmpty(text))
                return;

            // ?萄遣 TextBlock annotation
            var tb = new TextBlock
            {
                Text = text,
                FontSize = 12,
                Padding = new Thickness(5)
            };

            var border = new Border
            {
                Child = tb,
                Background = Brushes.Transparent,
                Cursor = Cursors.SizeAll
            };

            Canvas.SetLeft(border, left);
            Canvas.SetTop(border, top);
            ChartCanvas.Children.Add(border);
            annotations.Add(border);
        }
        private void ChartCanvas_MouseMove(object sender, MouseEventArgs e)
        {
            var pos = e.GetPosition(ChartCanvas);

            if (isSelecting)
            {
                double x = Math.Min(pos.X, selectionStart.X);
                double y = Math.Min(pos.Y, selectionStart.Y);
                Canvas.SetLeft(SelectionRect, x);
                Canvas.SetTop(SelectionRect, y);
                SelectionRect.Width = Math.Abs(pos.X - selectionStart.X);
                SelectionRect.Height = Math.Abs(pos.Y - selectionStart.Y);
                return;
            }

            if (isDragging && selectedAnnotation != null)
            {
                double dx = pos.X - dragStart.X;
                double dy = pos.Y - dragStart.Y;
                Canvas.SetLeft(selectedAnnotation, elementStart.X + dx);
                Canvas.SetTop(selectedAnnotation, elementStart.Y + dy);
            }
        }

        private void ChartCanvas_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (isSelecting)
            {
                double x1 = Canvas.GetLeft(SelectionRect);
                double y1 = Canvas.GetTop(SelectionRect);
                double x2 = x1 + SelectionRect.Width;
                double y2 = y1 + SelectionRect.Height;

                foreach (var ann in annotations)
                {
                    double ax = Canvas.GetLeft(ann);
                    double ay = Canvas.GetTop(ann);
                    if (ax >= x1 && ax <= x2 && ay >= y1 && ay <= y2)
                    {
                        selectedAnnotations.Add(ann);
                        HighlightAnnotation(ann, true);
                    }
                }
                SelectionRect.Visibility = Visibility.Collapsed;
                isSelecting = false;
            }

            isDragging = false;
            ChartCanvas.ReleaseMouseCapture();
        }

        #endregion

        #region Bar Editing

        private void EditBars_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new BarStyleEditorDialog(dataSeries, barStyles, chartType);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                barStyles = dialog.UpdatedStyles;
                DrawChart();
            }
        }

        private void EditSingleBar(int seriesIndex, int xIndex)
        {
            var key = (seriesIndex, xIndex);
            var currentStyle = barStyles.ContainsKey(key) ? barStyles[key] : new BarStyle();

            // Get X label
            string xLabel = (dataSeries[seriesIndex].XLabels.Count > xIndex && 
                            !string.IsNullOrEmpty(dataSeries[seriesIndex].XLabels[xIndex]))
                ? dataSeries[seriesIndex].XLabels[xIndex]
                : $"X={dataSeries[seriesIndex].XValues[xIndex]:G4}";

            var dialog = new SingleBarStyleDialog(currentStyle, dataSeries[seriesIndex].Name, xLabel);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                var newStyle = dialog.UpdatedStyle;
                
                // Link colors based on chart type:
                // Column: Same series index (s) -> update all X positions with same color
                // MultiGroup: Same X index -> update all series with same color
                
                if (chartType == "Column")
                {
                    // Update all bars with same series index (same Y column)
                    int numGroups = dataSeries.Max(s => s.XValues.Count);
                    for (int x = 0; x < numGroups; x++)
                    {
                        var updateKey = (seriesIndex, x);
                        if (!barStyles.ContainsKey(updateKey))
                            barStyles[updateKey] = new BarStyle();
                        barStyles[updateKey].FillColor = newStyle.FillColor;
                        barStyles[updateKey].BorderColor = newStyle.BorderColor;
                        barStyles[updateKey].BorderThickness = newStyle.BorderThickness;
                        barStyles[updateKey].Pattern = newStyle.Pattern;
                    }
                }
                else
                {
                    // MultiGroup: Update all bars with same X index (same position within groups)
                    for (int s = 0; s < dataSeries.Count; s++)
                    {
                        var updateKey = (s, xIndex);
                        if (!barStyles.ContainsKey(updateKey))
                            barStyles[updateKey] = new BarStyle();
                        barStyles[updateKey].FillColor = newStyle.FillColor;
                        barStyles[updateKey].BorderColor = newStyle.BorderColor;
                        barStyles[updateKey].BorderThickness = newStyle.BorderThickness;
                        barStyles[updateKey].Pattern = newStyle.Pattern;
                    }
                }
                
                DrawChart();
            }
        }

        #endregion

        #region Chart Drawing

        private void DrawChart()
        {
            var savedAnnotations = annotations.ToList();
            var positions = savedAnnotations.Select(a => new Point(Canvas.GetLeft(a), Canvas.GetTop(a))).ToList();

            // Save legend position if exists
            Point? savedLegendPos = null;
            if (legendBorder != null && ChartCanvas.Children.Contains(legendBorder))
            {
                savedLegendPos = new Point(Canvas.GetLeft(legendBorder), Canvas.GetTop(legendBorder));
            }

            ChartCanvas.Children.Clear();
            barInfos.Clear();

            if (dataSeries == null || dataSeries.Count == 0) return;

            double width = ChartCanvas.ActualWidth;
            double height = ChartCanvas.ActualHeight;
            if (width < 100 || height < 100) return;

            double plotWidth = width - marginLeft - marginRight;
            double plotHeight = height - marginTop - marginBottom;

            // Calculate Y range
            double calculatedYMax = 0;
            double calculatedYMin = double.MaxValue;
            foreach (var s in dataSeries)
            {
                for (int i = 0; i < s.YValues.Count; i++)
                {
                    double val = s.YValues[i];
                    double err = GetErrorValue(s, i);
                    calculatedYMax = Math.Max(calculatedYMax, val + err);
                    calculatedYMin = Math.Min(calculatedYMin, val - err);
                }
            }
            
            if (calculatedYMin == double.MaxValue) calculatedYMin = 0;
            if (calculatedYMin < 0) calculatedYMin = 0; // Bar charts typically start at 0
            
            // Apply nice rounding to max value
            calculatedYMax = CalculateNiceYMax(calculatedYMax * 1.1);
            if (calculatedYMax == 0) calculatedYMax = 1;

            // Use manual scale if autoScale is disabled
            double useYMax = autoScale ? calculatedYMax : yMax;
            double useYMin = autoScale ? 0 : yMin;
            if (useYMax <= useYMin) useYMax = calculatedYMax;

            // Draw background and grid
            ChartCanvas.Children.Add(new Rectangle
            {
                Width = plotWidth,
                Height = plotHeight,
                Fill = Brushes.White,
                Stroke = new SolidColorBrush(Color.FromRgb(200, 200, 200)),
                StrokeThickness = 1
            });
            Canvas.SetLeft(ChartCanvas.Children[0], marginLeft);
            Canvas.SetTop(ChartCanvas.Children[0], marginTop);

            DrawGridLines(plotWidth, plotHeight, useYMax);
            DrawTickMarks(plotWidth, plotHeight, useYMax);

            if (chartType == "Column")
                DrawColumnBars(plotWidth, plotHeight, useYMax);
            else
                DrawMultiGroupBars(plotWidth, plotHeight, useYMax);

            DrawAxes(plotWidth, plotHeight, useYMax);
            DrawTitle();
            BuildLegend();

            // Restore legend position if it was saved
            if (savedLegendPos.HasValue && legendBorder != null)
            {
                Canvas.SetLeft(legendBorder, savedLegendPos.Value.X);
                Canvas.SetTop(legendBorder, savedLegendPos.Value.Y);
            }

            // Restore annotations
            for (int i = 0; i < savedAnnotations.Count; i++)
            {
                ChartCanvas.Children.Add(savedAnnotations[i]);
                Canvas.SetLeft(savedAnnotations[i], positions[i].X);
                Canvas.SetTop(savedAnnotations[i], positions[i].Y);
            }
            annotations = savedAnnotations;
        }

        /// <summary>
        /// Calculate a nice rounded Y axis maximum value (multiples of 5, 10, etc.)
        /// </summary>
        private double CalculateNiceYMax(double value)
        {
            if (value <= 0) return 1;
            
            // Find the order of magnitude
            double magnitude = Math.Pow(10, Math.Floor(Math.Log10(value)));
            double normalized = value / magnitude;
            
            // Round to nice numbers: 1, 2, 2.5, 5, 10
            double nice;
            if (normalized <= 1) nice = 1;
            else if (normalized <= 2) nice = 2;
            else if (normalized <= 2.5) nice = 2.5;
            else if (normalized <= 5) nice = 5;
            else nice = 10;
            
            return nice * magnitude;
        }

        /// <summary>
        /// Calculate nice tick interval based on range
        /// </summary>
        private double CalculateNiceInterval(double range, int targetTicks = 5)
        {
            if (range <= 0) return 1;
            
            double roughInterval = range / targetTicks;
            double magnitude = Math.Pow(10, Math.Floor(Math.Log10(roughInterval)));
            double normalized = roughInterval / magnitude;
            
            double nice;
            if (normalized <= 1) nice = 1;
            else if (normalized <= 2) nice = 2;
            else if (normalized <= 5) nice = 5;
            else nice = 10;
            
            return nice * magnitude;
        }

        /// <summary>
        /// Draw tick marks (main and sub scale)
        /// </summary>
        private void DrawTickMarks(double plotWidth, double plotHeight, double yMax)
        {
            double interval = mainScaleInterval > 0 ? mainScaleInterval : CalculateNiceInterval(yMax);
            double majorTickLength = 6;
            double minorTickLength = 3;
            
            // Draw major ticks
            for (double yVal = 0; yVal <= yMax; yVal += interval)
            {
                double y = marginTop + plotHeight - (yVal / yMax) * plotHeight;
                
                // Left tick
                ChartCanvas.Children.Add(new Line
                {
                    X1 = marginLeft - majorTickLength,
                    Y1 = y,
                    X2 = marginLeft,
                    Y2 = y,
                    Stroke = Brushes.Black,
                    StrokeThickness = 1
                });
            }
            
            // Draw minor ticks if enabled
            if (showSubScale && subScaleDivisions > 1)
            {
                double minorInterval = interval / subScaleDivisions;
                for (double yVal = minorInterval; yVal < yMax; yVal += minorInterval)
                {
                    // Skip if this is a major tick position
                    if (Math.Abs(yVal % interval) < 0.0001) continue;
                    
                    double y = marginTop + plotHeight - (yVal / yMax) * plotHeight;
                    
                    ChartCanvas.Children.Add(new Line
                    {
                        X1 = marginLeft - minorTickLength,
                        Y1 = y,
                        X2 = marginLeft,
                        Y2 = y,
                        Stroke = Brushes.Black,
                        StrokeThickness = 0.5
                    });
                }
            }
        }

        private double GetErrorValue(ChartDataSeries s, int index)
        {
            if (errorType == "None") return 0;
            if (errorType == "SD" && index < s.YErrors.Count) return s.YErrors[index];
            if (errorType == "SEM" && index < s.SEMValues.Count) return s.SEMValues[index];
            if (errorType == "95CI" && index < s.SEMValues.Count && index < s.NValues.Count)
            {
                double sem = s.SEMValues[index];
                int n = s.NValues[index];
                double tCrit = GetTCritical(n - 1);
                return tCrit * sem;
            }
            return 0;
        }

        private double GetTCritical(int df)
        {
            if (df <= 0) return 1.96;
            if (df == 1) return 12.706; if (df == 2) return 4.303;
            if (df <= 5) return 2.571; if (df <= 10) return 2.228;
            if (df <= 20) return 2.086; if (df <= 30) return 2.042;
            return 1.96;
        }

        private void DrawColumnBars(double plotWidth, double plotHeight, double yMax)
        {
            // Column bars: each X value has one group, each series is a bar
            int numGroups = dataSeries.Max(s => s.XValues.Count);
            int numSeries = dataSeries.Count;

            double groupWidth = plotWidth / numGroups;
            double totalBarWidth = groupWidth * 0.8; // Use 80% of group width for bars
            double barWidth = totalBarWidth / numSeries;
            double gap = barWidth * 0.1;
            double groupPadding = groupWidth * 0.1; // 10% padding on each side

            for (int g = 0; g < numGroups; g++)
            {
                double groupStartX = marginLeft + g * groupWidth + groupPadding;
                double groupCenterX = marginLeft + g * groupWidth + groupWidth / 2;

                for (int s = 0; s < numSeries; s++)
                {
                    if (g >= dataSeries[s].YValues.Count) continue;

                    var key = (s, g);
                    var style = barStyles.ContainsKey(key) ? barStyles[key] : new BarStyle { FillColor = defaultColors[s % defaultColors.Length] };

                    double val = dataSeries[s].YValues[g];
                    double barHeight = (val / yMax) * plotHeight;
                    double barX = groupStartX + s * barWidth + gap / 2;
                    double barY = marginTop + plotHeight - barHeight;
                    double actualBarWidth = barWidth - gap;

                    var rect = CreateStyledBar(barX, barY, actualBarWidth, barHeight, style);
                    ChartCanvas.Children.Add(rect);

                    barInfos.Add(new BarInfo
                    {
                        SeriesIndex = s,
                        XIndex = g,
                        Bounds = new Rect(barX, barY, actualBarWidth, barHeight)
                    });

                    double barCenterX = barX + actualBarWidth / 2;

                    // Draw data points first (behind error bar)
                    DrawDataPoints(barCenterX, barY, plotHeight, yMax, dataSeries[s], g, actualBarWidth, style.FillColor);

                    // Error bar (use style direction if set, otherwise default)
                    double err = GetErrorValue(dataSeries[s], g);
                    if (err > 0)
                    {
                        double errPx = (err / yMax) * plotHeight;
                        DrawErrorBar(barCenterX, barY, errPx, Brushes.Black, actualBarWidth, style.ErrorDirection);
                    }
                }

                // X label - centered under the group of bars
                string labelText = "";
                if (dataSeries[0].XLabels.Count > g && !string.IsNullOrEmpty(dataSeries[0].XLabels[g]))
                    labelText = dataSeries[0].XLabels[g];
                else if (dataSeries[0].XValues.Count > g)
                    labelText = dataSeries[0].XValues[g].ToString("G4");

                if (!string.IsNullOrEmpty(labelText))
                {
                    var label = new TextBlock
                    {
                        Text = labelText,
                        FontSize = 10
                    };
                    label.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                    Canvas.SetLeft(label, groupCenterX - label.DesiredSize.Width / 2);
                    Canvas.SetTop(label, marginTop + plotHeight + 5);
                    ChartCanvas.Children.Add(label);
                }
            }
        }

        private void DrawMultiGroupBars(double plotWidth, double plotHeight, double yMax)
        {
            // MultiGroup: each series is a group, X values are bars within group
            int numSeries = dataSeries.Count;
            double groupWidth = plotWidth / numSeries;

            for (int s = 0; s < numSeries; s++)
            {
                int numBars = dataSeries[s].XValues.Count;
                double totalBarWidth = groupWidth * 0.8;
                double barWidth = totalBarWidth / numBars;
                double gap = barWidth * 0.1;
                double groupPadding = groupWidth * 0.1;

                double groupStartX = marginLeft + s * groupWidth + groupPadding;
                double groupCenterX = marginLeft + s * groupWidth + groupWidth / 2;

                for (int x = 0; x < numBars; x++)
                {
                    var key = (s, x);
                    var style = barStyles.ContainsKey(key) ? barStyles[key] : 
                        new BarStyle { FillColor = defaultColors[x % defaultColors.Length] };

                    double val = dataSeries[s].YValues[x];
                    double barHeight = (val / yMax) * plotHeight;
                    double barX = groupStartX + x * barWidth + gap / 2;
                    double barY = marginTop + plotHeight - barHeight;
                    double actualBarWidth = barWidth - gap;

                    var rect = CreateStyledBar(barX, barY, actualBarWidth, barHeight, style);
                    ChartCanvas.Children.Add(rect);

                    barInfos.Add(new BarInfo
                    {
                        SeriesIndex = s,
                        XIndex = x,
                        Bounds = new Rect(barX, barY, actualBarWidth, barHeight)
                    });

                    double barCenterX = barX + actualBarWidth / 2;

                    // Draw data points first (behind error bar)
                    DrawDataPoints(barCenterX, barY, plotHeight, yMax, dataSeries[s], x, actualBarWidth, style.FillColor);

                    // Error bar (use style direction if set, otherwise default)
                    double err = GetErrorValue(dataSeries[s], x);
                    if (err > 0)
                    {
                        double errPx = (err / yMax) * plotHeight;
                        DrawErrorBar(barCenterX, barY, errPx, Brushes.Black, actualBarWidth, style.ErrorDirection);
                    }
                }

                // Series label - centered under the group
                var label = new TextBlock
                {
                    Text = dataSeries[s].Name,
                    FontSize = 10,
                    FontWeight = FontWeights.SemiBold
                };
                label.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(label, groupCenterX - label.DesiredSize.Width / 2);
                Canvas.SetTop(label, marginTop + plotHeight + 5);
                ChartCanvas.Children.Add(label);
            }
        }

        private FrameworkElement CreateStyledBar(double x, double y, double width, double height, BarStyle style)
        {
            var rect = new Rectangle
            {
                Width = width,
                Height = height,
                Stroke = new SolidColorBrush(style.BorderColor),
                StrokeThickness = style.BorderThickness
            };

            rect.Fill = CreatePatternBrush(style);

            Canvas.SetLeft(rect, x);
            Canvas.SetTop(rect, y);
            return rect;
        }

        private Brush CreatePatternBrush(BarStyle style)
        {
            var baseColor = style.FillColor;

            switch (style.Pattern)
            {
                case FillPattern.Solid:
                    return new SolidColorBrush(baseColor);

                case FillPattern.HorizontalLines:
                    return CreateLineBrush(baseColor, 0);

                case FillPattern.VerticalLines:
                    return CreateLineBrush(baseColor, 90);

                case FillPattern.DiagonalUp:
                    return CreateLineBrush(baseColor, 45);

                case FillPattern.DiagonalDown:
                    return CreateLineBrush(baseColor, -45);

                case FillPattern.CrossHatch:
                    return CreateCrossHatchBrush(baseColor);

                case FillPattern.Dots:
                    return CreateDotsBrush(baseColor);

                default:
                    return new SolidColorBrush(baseColor);
            }
        }

        private Brush CreateLineBrush(Color color, double angle)
        {
            var brush = new DrawingBrush
            {
                TileMode = TileMode.Tile,
                Viewport = new Rect(0, 0, 8, 8),
                ViewportUnits = BrushMappingMode.Absolute
            };

            var group = new DrawingGroup();
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(Color.FromArgb(50, color.R, color.G, color.B)),
                null, new RectangleGeometry(new Rect(0, 0, 8, 8))));
            group.Children.Add(new GeometryDrawing(
                null, new Pen(new SolidColorBrush(color), 2),
                new LineGeometry(new Point(0, 4), new Point(8, 4))));

            brush.Drawing = group;
            brush.Transform = new RotateTransform(angle, 4, 4);
            return brush;
        }

        private Brush CreateCrossHatchBrush(Color color)
        {
            var brush = new DrawingBrush
            {
                TileMode = TileMode.Tile,
                Viewport = new Rect(0, 0, 8, 8),
                ViewportUnits = BrushMappingMode.Absolute
            };

            var group = new DrawingGroup();
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(Color.FromArgb(50, color.R, color.G, color.B)),
                null, new RectangleGeometry(new Rect(0, 0, 8, 8))));
            group.Children.Add(new GeometryDrawing(
                null, new Pen(new SolidColorBrush(color), 1),
                new LineGeometry(new Point(0, 0), new Point(8, 8))));
            group.Children.Add(new GeometryDrawing(
                null, new Pen(new SolidColorBrush(color), 1),
                new LineGeometry(new Point(8, 0), new Point(0, 8))));

            brush.Drawing = group;
            return brush;
        }

        private Brush CreateDotsBrush(Color color)
        {
            var brush = new DrawingBrush
            {
                TileMode = TileMode.Tile,
                Viewport = new Rect(0, 0, 8, 8),
                ViewportUnits = BrushMappingMode.Absolute
            };

            var group = new DrawingGroup();
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(Color.FromArgb(50, color.R, color.G, color.B)),
                null, new RectangleGeometry(new Rect(0, 0, 8, 8))));
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(color), null,
                new EllipseGeometry(new Point(4, 4), 2, 2)));

            brush.Drawing = group;
            return brush;
        }

        /// <summary>
        /// Convert Y data value to canvas Y coordinate, handling axis break if enabled
        /// </summary>
        private double ValueToCanvasY(double value, double plotHeight, double yMax)
        {
            if (!enableAxisBreak || axisBreakStart >= axisBreakEnd || axisBreakEnd >= yMax)
            {
                // No break - standard linear transformation
                return marginTop + plotHeight - (value / yMax) * plotHeight;
            }
            
            // With axis break
            double breakGapPixels = 15;
            double breakSize = axisBreakEnd - axisBreakStart;
            double effectiveMax = yMax - breakSize;
            double belowBreakHeight = (axisBreakStart / effectiveMax) * (plotHeight - breakGapPixels);
            double aboveBreakHeight = ((yMax - axisBreakEnd) / effectiveMax) * (plotHeight - breakGapPixels);
            double breakY = marginTop + plotHeight - belowBreakHeight;
            
            if (value <= axisBreakStart)
            {
                // Value is below the break
                return marginTop + plotHeight - (value / axisBreakStart) * belowBreakHeight;
            }
            else if (value >= axisBreakEnd)
            {
                // Value is above the break
                double aboveValue = value - axisBreakEnd;
                double aboveRange = yMax - axisBreakEnd;
                return breakY - breakGapPixels - (aboveValue / aboveRange) * aboveBreakHeight;
            }
            else
            {
                // Value is within the break - clamp to break start
                return breakY;
            }
        }

        private void DrawErrorBar(double cx, double top, double errPx, Brush brush, double barWidth, 
            ErrorBarDirection direction = ErrorBarDirection.Both)
        {
            double capWidth = barWidth / 3.0; // Cap width is 1/3 of bar width
            
            // Determine what to draw based on direction
            bool drawUp = direction == ErrorBarDirection.Both || direction == ErrorBarDirection.Up;
            bool drawDown = direction == ErrorBarDirection.Both || direction == ErrorBarDirection.Down;
            
            // Calculate Y positions
            double topY = drawUp ? top - errPx : top;
            double bottomY = drawDown ? top + errPx : top;
            
            // Vertical line
            ChartCanvas.Children.Add(new Line 
            { 
                X1 = cx, Y1 = topY, X2 = cx, Y2 = bottomY, 
                Stroke = brush, StrokeThickness = errorBarThickness 
            });
            
            // Top cap (if drawing up)
            if (drawUp)
            {
                ChartCanvas.Children.Add(new Line 
                { 
                    X1 = cx - capWidth / 2, Y1 = topY, X2 = cx + capWidth / 2, Y2 = topY, 
                    Stroke = brush, StrokeThickness = errorBarThickness 
                });
            }
            
            // Bottom cap (if drawing down)
            if (drawDown)
            {
                ChartCanvas.Children.Add(new Line 
                { 
                    X1 = cx - capWidth / 2, Y1 = bottomY, X2 = cx + capWidth / 2, Y2 = bottomY, 
                    Stroke = brush, StrokeThickness = errorBarThickness 
                });
            }
        }

        private void DrawDataPoints(double cx, double barY, double plotHeight, double yMax, 
            ChartDataSeries series, int xIndex, double barWidth, Color barColor)
        {
            if (!showDataPoints || xIndex >= series.RawReplicates.Count) return;
            
            var replicates = series.RawReplicates[xIndex];
            if (replicates == null || replicates.Count == 0) return;
            
            double pointSize = dataPointSize;
            var brush = new SolidColorBrush(Color.FromArgb(200, 0, 0, 0)); // Semi-transparent black
            
            foreach (var val in replicates)
            {
                double y = marginTop + plotHeight - (val / yMax) * plotHeight;
                var ellipse = new Ellipse
                {
                    Width = pointSize,
                    Height = pointSize,
                    Fill = brush,
                    Stroke = Brushes.White,
                    StrokeThickness = 0.5
                };
                Canvas.SetLeft(ellipse, cx - pointSize / 2);
                Canvas.SetTop(ellipse, y - pointSize / 2);
                ChartCanvas.Children.Add(ellipse);
            }
        }

        private void DrawGridLines(double plotWidth, double plotHeight, double yMax)
        {
            if (!showGridLines) return;
            
            var brush = new SolidColorBrush(gridLineColor);
            DoubleCollection dashArray = null;
            
            switch (gridLineStyle)
            {
                case "Dashed":
                    dashArray = new DoubleCollection { 6, 3 };
                    break;
                case "Dotted":
                    dashArray = new DoubleCollection { 2, 2 };
                    break;
            }
            
            // Use main scale interval or calculate nice interval
            double interval = mainScaleInterval > 0 ? mainScaleInterval : CalculateNiceInterval(yMax);
            
            for (double yVal = 0; yVal <= yMax; yVal += interval)
            {
                double y = marginTop + plotHeight - (yVal / yMax * plotHeight);
                var line = new Line 
                { 
                    X1 = marginLeft, 
                    Y1 = y, 
                    X2 = marginLeft + plotWidth, 
                    Y2 = y, 
                    Stroke = brush, 
                    StrokeThickness = 1 
                };
                if (dashArray != null)
                    line.StrokeDashArray = dashArray;
                ChartCanvas.Children.Add(line);
            }
        }

        private void DrawAxes(double plotWidth, double plotHeight, double yMax)
        {
            // Y axis labels - with axis break support
            if (enableAxisBreak && axisBreakStart < axisBreakEnd && axisBreakEnd < yMax)
            {
                DrawAxesWithBreak(plotWidth, plotHeight, yMax);
            }
            else
            {
                // Calculate interval
                double interval = mainScaleInterval > 0 ? mainScaleInterval : CalculateNiceInterval(yMax);
                
                // Draw Y axis labels at nice intervals
                for (double yVal = 0; yVal <= yMax; yVal += interval)
                {
                    double y = marginTop + plotHeight - (yVal / yMax) * plotHeight;
                    
                    // Format label based on value magnitude
                    string labelText;
                    if (logScale)
                        labelText = Math.Pow(10, yVal).ToString("G3");
                    else if (yVal == Math.Floor(yVal) && Math.Abs(yVal) < 10000)
                        labelText = yVal.ToString("F0");
                    else
                        labelText = yVal.ToString("G4");
                    
                    var lbl = new TextBlock { Text = labelText, FontSize = 10 };
                    lbl.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                    Canvas.SetLeft(lbl, marginLeft - lbl.DesiredSize.Width - 8);
                    Canvas.SetTop(lbl, y - lbl.DesiredSize.Height / 2);
                    ChartCanvas.Children.Add(lbl);
                }
            }

            // Clickable Y axis area (invisible rectangle for click detection)
            var yAxisClickArea = new Rectangle
            {
                Width = marginLeft,
                Height = plotHeight,
                Fill = Brushes.Transparent,
                Cursor = Cursors.Hand
            };
            yAxisClickArea.MouseLeftButtonDown += (s, e) =>
            {
                if (e.ClickCount == 2)
                    OpenAxisSettings(true);
            };
            yAxisClickArea.ToolTip = "Double-click to edit Y axis settings";
            Canvas.SetLeft(yAxisClickArea, 0);
            Canvas.SetTop(yAxisClickArea, marginTop);
            ChartCanvas.Children.Add(yAxisClickArea);

            // X axis title (clickable)
            var xt = new TextBlock 
            { 
                Text = xAxisTitle, 
                FontSize = 12, 
                FontWeight = FontWeights.SemiBold,
                Cursor = Cursors.Hand,
                ToolTip = "Double-click to edit X axis settings"
            };
            xt.MouseLeftButtonDown += (s, e) => 
            {
                if (e.ClickCount == 2)
                    OpenAxisSettings(false);
            };
            xt.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            Canvas.SetLeft(xt, marginLeft + (plotWidth - xt.DesiredSize.Width) / 2);
            Canvas.SetTop(xt, marginTop + plotHeight + 30);
            ChartCanvas.Children.Add(xt);

            // Y axis title (clickable)
            var yt = new TextBlock 
            { 
                Text = yAxisTitle, 
                FontSize = 12, 
                FontWeight = FontWeights.SemiBold, 
                RenderTransform = new RotateTransform(-90),
                Cursor = Cursors.Hand,
                ToolTip = "Double-click to edit Y axis settings"
            };
            yt.MouseLeftButtonDown += (s, e) => 
            {
                if (e.ClickCount == 2)
                    OpenAxisSettings(true);
            };
            yt.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            Canvas.SetLeft(yt, 10);
            Canvas.SetTop(yt, marginTop + (plotHeight + yt.DesiredSize.Width) / 2);
            ChartCanvas.Children.Add(yt);
        }

        private void DrawAxesWithBreak(double plotWidth, double plotHeight, double yMax)
        {
            // Calculate the effective range (excluding the break)
            double breakSize = axisBreakEnd - axisBreakStart;
            double effectiveMax = yMax - breakSize;
            double breakGapPixels = 15; // Gap for the break symbol
            double belowBreakHeight = (axisBreakStart / effectiveMax) * (plotHeight - breakGapPixels);
            double aboveBreakHeight = ((yMax - axisBreakEnd) / effectiveMax) * (plotHeight - breakGapPixels);
            
            double breakY = marginTop + plotHeight - belowBreakHeight - breakGapPixels;
            
            // Draw labels below break
            int numLabelsBelow = 3;
            for (int i = 0; i <= numLabelsBelow; i++)
            {
                double yVal = axisBreakStart * i / numLabelsBelow;
                double y = marginTop + plotHeight - (belowBreakHeight * i / numLabelsBelow);
                var lbl = new TextBlock { Text = yVal.ToString("F1"), FontSize = 10 };
                lbl.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(lbl, marginLeft - lbl.DesiredSize.Width - 5);
                Canvas.SetTop(lbl, y - lbl.DesiredSize.Height / 2);
                ChartCanvas.Children.Add(lbl);
            }
            
            // Draw break symbol (zigzag)
            double zigzagWidth = 8;
            double zigzagY1 = breakY + breakGapPixels;
            double zigzagY2 = breakY;
            
            var breakPath = new System.Windows.Shapes.Path
            {
                Stroke = Brushes.Black,
                StrokeThickness = 1.5,
                Data = Geometry.Parse($"M {marginLeft - 5},{zigzagY1} " +
                    $"L {marginLeft - 5 + zigzagWidth / 2},{zigzagY1 - breakGapPixels / 3} " +
                    $"L {marginLeft - 5},{zigzagY1 - breakGapPixels * 2 / 3} " +
                    $"L {marginLeft - 5 + zigzagWidth / 2},{zigzagY2}")
            };
            ChartCanvas.Children.Add(breakPath);
            
            // Draw labels above break
            int numLabelsAbove = 2;
            for (int i = 0; i <= numLabelsAbove; i++)
            {
                double yVal = axisBreakEnd + (yMax - axisBreakEnd) * i / numLabelsAbove;
                double y = breakY - (aboveBreakHeight * i / numLabelsAbove);
                var lbl = new TextBlock { Text = yVal.ToString("F1"), FontSize = 10 };
                lbl.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(lbl, marginLeft - lbl.DesiredSize.Width - 5);
                Canvas.SetTop(lbl, y - lbl.DesiredSize.Height / 2);
                ChartCanvas.Children.Add(lbl);
            }
        }

        private void OpenAxisSettings(bool isYAxis)
        {
            double width = ChartCanvas.ActualWidth;
            double height = ChartCanvas.ActualHeight;
            double plotHeight = height - marginTop - marginBottom;

            // Calculate current max
            double currentMax = 0;
            foreach (var s in dataSeries)
            {
                for (int i = 0; i < s.YValues.Count; i++)
                {
                    double err = GetErrorValue(s, i);
                    currentMax = Math.Max(currentMax, s.YValues[i] + err);
                }
            }
            currentMax = CalculateNiceYMax(currentMax * 1.1);

            var dialog = new AxisSettingsDialog(
                isYAxis, 
                isYAxis ? yAxisTitle : xAxisTitle,
                yMin, autoScale ? currentMax : yMax,
                showGridLines, gridLineStyle, gridLineColor, 
                mainScaleInterval, showSubScale, subScaleDivisions, logScale);
            dialog.Owner = this;
            
            if (dialog.ShowDialog() == true)
            {
                if (isYAxis)
                {
                    yAxisTitle = dialog.AxisTitle;
                    autoScale = dialog.AutoScale;
                    logScale = dialog.LogScale;
                    
                    if (!dialog.AutoScale)
                    {
                        yMin = dialog.MinValue;
                        yMax = dialog.MaxValue;
                    }
                    
                    // Tick mark settings
                    mainScaleInterval = dialog.MainScaleInterval;
                    showSubScale = dialog.ShowSubScale;
                    subScaleDivisions = dialog.SubScaleDivisions;
                    
                    // Store axis break settings
                    enableAxisBreak = dialog.EnableBreak;
                    axisBreakStart = dialog.BreakStart;
                    axisBreakEnd = dialog.BreakEnd;
                }
                else
                {
                    xAxisTitle = dialog.AxisTitle;
                }
                
                showGridLines = dialog.ShowGridLines;
                gridLineStyle = dialog.GridLineStyle;
                gridLineColor = dialog.GridLineColor;
                
                DrawChart();
            }
        }

        private void DrawTitle()
        {
            double width = ChartCanvas.ActualWidth;
            string[] parts = chartTitle.Split('|');
            string main = parts[0].Trim();

            var t = new TextBlock { Text = main, FontSize = 16, FontWeight = FontWeights.Bold };
            t.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            Canvas.SetLeft(t, (width - t.DesiredSize.Width) / 2);
            Canvas.SetTop(t, 8);
            ChartCanvas.Children.Add(t);
        }

        private void BuildLegend()
        {
            // Remove old legend if exists
            if (legendBorder != null && ChartCanvas.Children.Contains(legendBorder))
            {
                ChartCanvas.Children.Remove(legendBorder);
            }

            // Create legend container
            legendBorder = new Border
            {
                Background = new SolidColorBrush(Color.FromArgb(240, 255, 255, 255)),
                BorderBrush = new SolidColorBrush(Color.FromRgb(200, 200, 200)),
                BorderThickness = new Thickness(1),
                CornerRadius = new CornerRadius(3),
                Padding = new Thickness(8),
                Cursor = Cursors.SizeAll
            };

            var legendStack = new StackPanel();

            if (chartType == "Column")
            {
                foreach (var s in dataSeries)
                {
                    int idx = dataSeries.IndexOf(s);
                    var style = barStyles.ContainsKey((idx, 0)) ? barStyles[(idx, 0)] : new BarStyle { FillColor = defaultColors[idx % defaultColors.Length] };
                    legendStack.Children.Add(CreateLegendItem(s.Name, style));
                }
            }
            else
            {
                if (dataSeries.Count > 0)
                {
                    for (int x = 0; x < dataSeries[0].XValues.Count; x++)
                    {
                        var style = barStyles.ContainsKey((0, x)) ? barStyles[(0, x)] : new BarStyle { FillColor = defaultColors[x % defaultColors.Length] };
                        string labelText = (dataSeries[0].XLabels.Count > x && !string.IsNullOrEmpty(dataSeries[0].XLabels[x]))
                            ? dataSeries[0].XLabels[x]
                            : $"X={dataSeries[0].XValues[x]:G4}";
                        legendStack.Children.Add(CreateLegendItem(labelText, style));
                    }
                }
            }

            legendBorder.Child = legendStack;

            // Add drag events
            legendBorder.MouseLeftButtonDown += Legend_MouseLeftButtonDown;
            legendBorder.MouseMove += Legend_MouseMove;
            legendBorder.MouseLeftButtonUp += Legend_MouseLeftButtonUp;

            ChartCanvas.Children.Add(legendBorder);

            // Position legend (default: top-left, move to top-right if overlapping data)
            PositionLegend();
        }

        private StackPanel CreateLegendItem(string text, BarStyle style)
        {
            var sp = new StackPanel { Orientation = Orientation.Horizontal, Margin = new Thickness(2, 3, 2, 3) };
            var rect = new Rectangle 
            { 
                Width = 14, Height = 14, 
                Fill = CreatePatternBrush(style), 
                Stroke = new SolidColorBrush(style.BorderColor), 
                StrokeThickness = 1, 
                Margin = new Thickness(0, 0, 6, 0) 
            };
            sp.Children.Add(rect);
            sp.Children.Add(new TextBlock { Text = text, VerticalAlignment = VerticalAlignment.Center, FontSize = 11 });
            return sp;
        }

        private void PositionLegend()
        {
            if (legendBorder == null) return;

            legendBorder.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            double legendWidth = legendBorder.DesiredSize.Width;
            double legendHeight = legendBorder.DesiredSize.Height;

            double width = ChartCanvas.ActualWidth;
            double height = ChartCanvas.ActualHeight;
            double plotWidth = width - marginLeft - marginRight;
            double plotHeight = height - marginTop - marginBottom;

            // Default position: top-left inside plot area
            double leftX = marginLeft + 10;
            double topY = marginTop + 10;

            // Check if legend overlaps with bars in top-left
            bool overlapsTopLeft = CheckLegendOverlap(leftX, topY, legendWidth, legendHeight);

            if (overlapsTopLeft)
            {
                // Try top-right
                double rightX = marginLeft + plotWidth - legendWidth - 10;
                bool overlapsTopRight = CheckLegendOverlap(rightX, topY, legendWidth, legendHeight);
                
                if (!overlapsTopRight)
                {
                    leftX = rightX;
                }
                // If both overlap, keep top-left (user can drag)
            }

            Canvas.SetLeft(legendBorder, leftX);
            Canvas.SetTop(legendBorder, topY);
        }

        private bool CheckLegendOverlap(double legendX, double legendY, double legendW, double legendH)
        {
            var legendRect = new Rect(legendX, legendY, legendW, legendH);

            foreach (var barInfo in barInfos)
            {
                if (legendRect.IntersectsWith(barInfo.Bounds))
                    return true;
            }
            return false;
        }

        private void Legend_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (legendBorder == null) return;
            
            isLegendDragging = true;
            legendDragStart = e.GetPosition(ChartCanvas);
            legendStartPosition = new Point(Canvas.GetLeft(legendBorder), Canvas.GetTop(legendBorder));
            legendBorder.CaptureMouse();
            e.Handled = true;
        }

        private void Legend_MouseMove(object sender, MouseEventArgs e)
        {
            if (!isLegendDragging || legendBorder == null) return;

            Point currentPos = e.GetPosition(ChartCanvas);
            double deltaX = currentPos.X - legendDragStart.X;
            double deltaY = currentPos.Y - legendDragStart.Y;

            double newLeft = legendStartPosition.X + deltaX;
            double newTop = legendStartPosition.Y + deltaY;

            // Constrain to canvas bounds
            legendBorder.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            double legendW = legendBorder.DesiredSize.Width;
            double legendH = legendBorder.DesiredSize.Height;

            newLeft = Math.Max(0, Math.Min(newLeft, ChartCanvas.ActualWidth - legendW));
            newTop = Math.Max(0, Math.Min(newTop, ChartCanvas.ActualHeight - legendH));

            Canvas.SetLeft(legendBorder, newLeft);
            Canvas.SetTop(legendBorder, newTop);
        }

        private void Legend_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (legendBorder == null) return;
            
            isLegendDragging = false;
            legendBorder.ReleaseMouseCapture();
        }

        #endregion

        #region Settings Dialog

        private void OpenSettingsDialog()
        {
            var dialog = new BarChartSettingsWindow(dataSeries, chartTitle, xAxisTitle, yAxisTitle,
                errorBarThickness, showDataPoints, dataPointSize);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                chartTitle = dialog.ChartTitle;
                xAxisTitle = dialog.XAxisTitle;
                yAxisTitle = dialog.YAxisTitle;
                errorBarThickness = dialog.ErrorBarThickness;
                showDataPoints = dialog.ShowDataPoints;
                dataPointSize = dialog.DataPointSize;
                DrawChart();
            }
        }

        #endregion

        #region Annotation System (simplified - shared logic with ChartWindow)

        private void SelectAllAnnotations()
        {
            ClearSelection();
            foreach (var ann in annotations)
            {
                selectedAnnotations.Add(ann);
                HighlightAnnotation(ann, true);
            }
        }
        private void AddResizeHandles(Canvas container, string lineType)
        {
            var handleColor = new SolidColorBrush(Color.FromRgb(33, 150, 243)); // ?

            switch (lineType)
            {
                case "Line":
                case "Arrow":
                    // 蝺??拍垢?賢隞交???
                    AddHandle(container, "Start", handleColor, Cursors.Cross);
                    AddHandle(container, "End", handleColor, Cursors.Cross);
                    break;

                case "UShape":
                    // ??敶Ｙ?嚗椰銝銝?隤踵?擃漲嚗銝?隤踵撖砍漲嚗?
                    AddHandle(container, "LeftBottom", handleColor, Cursors.SizeNS);
                    AddHandle(container, "RightBottom", handleColor, Cursors.SizeNS);
                    AddHandle(container, "TopRight", handleColor, Cursors.SizeWE);
                    break;

                case "HShape":
                    // H 敶Ｙ?嚗椰銝椰銝銝銝?隤踵?擃漲嚗銝哨?隤踵撖砍漲嚗?
                    AddHandle(container, "LeftTop", handleColor, Cursors.SizeNS);
                    AddHandle(container, "LeftBottom", handleColor, Cursors.SizeNS);
                    AddHandle(container, "RightTop", handleColor, Cursors.SizeNS);
                    AddHandle(container, "RightBottom", handleColor, Cursors.SizeNS);
                    AddHandle(container, "RightMid", handleColor, Cursors.SizeWE);
                    break;
            }

            UpdateHandlePositions(container);
        }

        private void UpdateHandlePositions(Canvas container)
        {
            if (container.Tag is not LineShapeInfo info) return;

            foreach (var child in container.Children.OfType<Ellipse>())
            {
                if (child.Tag?.ToString() != "Handle") continue;

                string name = child.GetValue(FrameworkElement.NameProperty) as string ?? "";

                switch (name)
                {
                    // Line/Arrow ?垢暺?
                    case "Start":
                        Canvas.SetLeft(child, info.StartX - 5);
                        Canvas.SetTop(child, info.StartY - 5);
                        break;
                    case "End":
                        Canvas.SetLeft(child, info.EndX - 5);
                        Canvas.SetTop(child, info.EndY - 5);
                        break;

                    // UShape ?矽?湧?
                    case "LeftBottom":
                        Canvas.SetLeft(child, -5);
                        if (info.Type == "UShape")
                            Canvas.SetTop(child, info.LeftHeight - 5);
                        else // HShape
                            Canvas.SetTop(child, info.Height / 2 + info.LeftHeight / 2 - 5);
                        break;
                    case "RightBottom":
                        Canvas.SetLeft(child, info.Width - 5);
                        if (info.Type == "UShape")
                            Canvas.SetTop(child, info.RightHeight - 5);
                        else // HShape
                            Canvas.SetTop(child, info.Height / 2 + info.RightHeight / 2 - 5);
                        break;
                    case "TopRight":
                        Canvas.SetLeft(child, info.Width - 5);
                        Canvas.SetTop(child, -5);
                        break;

                    // HShape 憿??矽?湧?
                    case "LeftTop":
                        Canvas.SetLeft(child, -5);
                        Canvas.SetTop(child, info.Height / 2 - info.LeftHeight / 2 - 5);
                        break;
                    case "RightTop":
                        Canvas.SetLeft(child, info.Width - 5);
                        Canvas.SetTop(child, info.Height / 2 - info.RightHeight / 2 - 5);
                        break;
                    case "RightMid":
                        Canvas.SetLeft(child, info.Width - 5);
                        Canvas.SetTop(child, info.Height / 2 - 5);
                        break;
                }
            }
        }
        private void AddHandle(Canvas container, string name, Brush color, Cursor cursor)
        {
            var handle = new Ellipse
            {
                Width = 10,
                Height = 10,
                Fill = color,
                Stroke = Brushes.White,
                StrokeThickness = 1,
                Cursor = cursor,
                Tag = "Handle"
            };

            handle.SetValue(FrameworkElement.NameProperty, name);
            handle.MouseLeftButtonDown += Handle_MouseDown;
            handle.MouseMove += Handle_MouseMove;
            handle.MouseLeftButtonUp += Handle_MouseUp;

            container.Children.Add(handle);
        }
        private void Handle_MouseDown(object sender, MouseButtonEventArgs e)
        {
            if (sender is Ellipse handle && handle.Parent is Canvas container)
            {
                isResizing = true;
                currentResizeHandle = handle.GetValue(FrameworkElement.NameProperty) as string ?? "";
                currentLineCanvas = container;
                dragStart = e.GetPosition(ChartCanvas);
                handle.CaptureMouse();
                e.Handled = true;
            }
        }

        private void Handle_MouseMove(object sender, MouseEventArgs e)
        {
            if (!isResizing || currentLineCanvas == null) return;
            if (currentLineCanvas.Tag is not LineShapeInfo info) return;

            var pos = e.GetPosition(ChartCanvas);
            var border = currentLineCanvas.Parent as Border;
            if (border == null) return;

            double containerLeft = Canvas.GetLeft(border);
            double containerTop = Canvas.GetTop(border);
            double localX = pos.X - containerLeft;
            double localY = pos.Y - containerTop;

            // Shift ?萄隞仿??嗉?摨佗??冽?渡?嚗?
            bool shiftPressed = Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift);

            // ?? Line/Arrow ?垢暺???
            if (currentResizeHandle == "Start" || currentResizeHandle == "End")
            {
                double anchorX = currentResizeHandle == "Start" ? info.EndX : info.StartX;
                double anchorY = currentResizeHandle == "Start" ? info.EndY : info.StartY;

                double targetX = localX, targetY = localY;

                // Shift ???45 摨西?
                if (shiftPressed)
                {
                    double dx = localX - anchorX, dy = localY - anchorY;
                    double length = Math.Sqrt(dx * dx + dy * dy);
                    if (length > 0)
                    {
                        double angle = Math.Atan2(dy, dx);
                        double snapped = Math.Round(angle / (Math.PI / 4)) * (Math.PI / 4);
                        targetX = anchorX + length * Math.Cos(snapped);
                        targetY = anchorY + length * Math.Sin(snapped);
                    }
                }

                if (currentResizeHandle == "Start")
                {
                    info.StartX = targetX;
                    info.StartY = targetY;
                }
                else
                {
                    info.EndX = targetX;
                    info.EndY = targetY;
                }

                // 蝣箔?摨扳?銝?霈?鞎
                double minX = Math.Min(info.StartX, info.EndX) - 15;
                double minY = Math.Min(info.StartY, info.EndY) - 15;

                if (minX < 0)
                {
                    info.StartX -= minX;
                    info.EndX -= minX;
                    Canvas.SetLeft(border, containerLeft + minX);
                }
                if (minY < 0)
                {
                    info.StartY -= minY;
                    info.EndY -= minY;
                    Canvas.SetTop(border, containerTop + minY);
                }

                currentLineCanvas.Width = Math.Max(info.StartX, info.EndX) + 15;
                currentLineCanvas.Height = Math.Max(info.StartY, info.EndY) + 15;
            }
            else
            {
                // ???嗡?敶Ｙ??矽??
                double dx = pos.X - dragStart.X;
                double dy = pos.Y - dragStart.Y;

                switch (currentResizeHandle)
                {
                    case "TopRight":
                    case "RightMid":
                        // 隤踵撖砍漲
                        info.Width = Math.Max(20, info.Width + dx);
                        currentLineCanvas.Width = info.Width + 10;
                        break;

                    case "LeftBottom":
                        if (info.Type == "UShape")
                        {
                            // ??敶Ｙ?嚗矽?游椰???湧?摨?
                            info.LeftHeight = Math.Max(10, info.LeftHeight + dy);
                            info.Height = Math.Max(info.LeftHeight, info.RightHeight) + 5;
                        }
                        else
                        {
                            // H 敶Ｙ?嚗?蝔梯矽??
                            info.LeftHeight = Math.Max(10, info.LeftHeight + dy * 2);
                        }
                        break;

                    case "LeftTop":
                        // H 敶Ｙ?嚗??隤踵
                        info.LeftHeight = Math.Max(10, info.LeftHeight - dy * 2);
                        break;

                    case "RightBottom":
                        if (info.Type == "UShape")
                        {
                            // ??敶Ｙ?嚗矽?游???湧?摨?
                            info.RightHeight = Math.Max(10, info.RightHeight + dy);
                            info.Height = Math.Max(info.LeftHeight, info.RightHeight) + 5;
                        }
                        else
                        {
                            // H 敶Ｙ?嚗?蝔梯矽??
                            info.RightHeight = Math.Max(10, info.RightHeight + dy * 2);
                        }
                        break;

                    case "RightTop":
                        // H 敶Ｙ?嚗??隤踵
                        info.RightHeight = Math.Max(10, info.RightHeight - dy * 2);
                        break;
                }

                // ?湔摰孵憭批?
                if (info.Type == "HShape")
                {
                    info.Height = Math.Max(info.LeftHeight, info.RightHeight) + 10;
                    currentLineCanvas.Height = info.Height;
                }
                if (info.Type == "UShape")
                {
                    currentLineCanvas.Height = info.Height;
                }

                dragStart = pos;
            }

            RedrawLineShape(currentLineCanvas, info);
            UpdateHandlePositions(currentLineCanvas);
            e.Handled = true;
        }


        private void Handle_MouseUp(object sender, MouseButtonEventArgs e)
        {
            isResizing = false;
            currentResizeHandle = "";
            currentLineCanvas = null;

            if (sender is Ellipse handle)
            {
                handle.ReleaseMouseCapture();
            }
            e.Handled = true;
        }
        private void ClearSelection()
        {
            foreach (var ann in selectedAnnotations) HighlightAnnotation(ann, false);
            selectedAnnotations.Clear();
            if (selectedAnnotation != null) { HighlightAnnotation(selectedAnnotation, false); selectedAnnotation = null; }
        }

        private void SelectAnnotation(FrameworkElement? element)
        {
            selectedAnnotation = element;
            if (element != null) { selectedAnnotations.Add(element); HighlightAnnotation(element, true); }
        }

        private void HighlightAnnotation(FrameworkElement element, bool highlight)
        {
            if (element is Border border)
            {
                border.BorderBrush = highlight ? Brushes.DodgerBlue : (border.Tag as Brush ?? Brushes.Transparent);
                border.BorderThickness = highlight ? new Thickness(2) : new Thickness(border.Tag != null ? 1 : 0);
            }
        }

        private FrameworkElement? FindAnnotationAt(Point pos)
        {
            foreach (var ann in annotations)
            {
                double left = Canvas.GetLeft(ann);
                double top = Canvas.GetTop(ann);
                if (pos.X >= left - 5 && pos.X <= left + ann.ActualWidth + 5 && pos.Y >= top - 5 && pos.Y <= top + ann.ActualHeight + 5)
                    return ann;
            }
            return null;
        }

        private void DeleteSelectedAnnotations()
        {
            var toDelete = selectedAnnotations.Count > 0 ? selectedAnnotations.ToList() : (selectedAnnotation != null ? new List<FrameworkElement> { selectedAnnotation } : new List<FrameworkElement>());
            foreach (var ann in toDelete) { ChartCanvas.Children.Remove(ann); annotations.Remove(ann); }
            selectedAnnotations.Clear();
            selectedAnnotation = null;
        }

        private void EditAnnotation(FrameworkElement element)
        {
            if (element is Border border)
            {
                // ??蝺刻摩
                if (border.Child is TextBlock tb)
                {
                    var format = new TextFormatInfo
                    {
                        FontFamily = tb.FontFamily,
                        FontSize = tb.FontSize,
                        TextColor = (tb.Foreground as SolidColorBrush)?.Color ?? Colors.Black,
                        IsBold = tb.FontWeight == FontWeights.Bold,
                        IsItalic = tb.FontStyle == FontStyles.Italic,
                        ShowBorder = false
                    };
                    var dialog = new TextAnnotationDialog(tb.Text, format);
                    dialog.Owner = this;
                    if (dialog.ShowDialog() == true)
                    {
                        tb.Text = dialog.AnnotationText;
                        tb.FontSize = dialog.SelectedFontSize;
                        tb.FontFamily = dialog.SelectedFontFamily;
                        tb.FontWeight = dialog.IsBold ? FontWeights.Bold : FontWeights.Normal;
                        tb.FontStyle = dialog.IsItalic ? FontStyles.Italic : FontStyles.Normal;
                        tb.Foreground = new SolidColorBrush(dialog.TextColor);
                    }
                }
                // 蝺?蝺刻摩
                else if (border.Child is Canvas lineCanvas && lineCanvas.Tag is LineShapeInfo info)
                {
                    var dialog = new LineSettingsDialog(info);
                    dialog.Owner = this;
                    if (dialog.ShowDialog() == true)
                    {
                        info.Thickness = dialog.LineThickness;
                        info.Stroke = new SolidColorBrush(dialog.LineColor);
                        info.ArrowDirection = dialog.ArrowDirection;

                        RedrawLineShape(lineCanvas, info);
                        UpdateHandlePositions(lineCanvas);
                    }
                }
            }
        }

        private void AddTextBox_Click(object sender, RoutedEventArgs e)
        {
            // ?脣??瘛餃?璅∪?
            isTextAddMode = true;
            ChartCanvas.Cursor = Cursors.Cross;
                           
        }

        private void OpenSymbolPicker_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new SymbolPickerDialog();
            dialog.Owner = this;
            if (dialog.ShowDialog() == true && !string.IsNullOrEmpty(dialog.SelectedSymbol))
            {
                var tb = new TextBlock { Text = dialog.SelectedSymbol, FontSize = 14, Padding = new Thickness(5) };
                var border = new Border { Child = tb, Background = Brushes.Transparent, Cursor = Cursors.SizeAll };
                Canvas.SetLeft(border, 100);
                Canvas.SetTop(border, 100);
                ChartCanvas.Children.Add(border);
                annotations.Add(border);
            }
        }

        private void AddLine_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button btn && btn.Tag is string lineType)
            {
                CreateLineAnnotation(lineType);
            }
        }

        private void CreateLineAnnotation(string lineType)
        {
            var container = new Canvas { Background = Brushes.Transparent, Cursor = Cursors.SizeAll };

            var info = new LineShapeInfo
            {
                Type = lineType,
                Stroke = Brushes.Black,
                Thickness = 2,
                Width = 100,
                Height = 40,
                LeftHeight = 40,
                RightHeight = 40,
                ArrowDirection = "Right",
                StartX = 5,
                StartY = 10,
                EndX = 105,
                EndY = 10
            };

            switch (lineType)
            {
                case "Line":
                case "Arrow":
                    container.Width = 110;
                    container.Height = 20;
                    info.Height = 20;
                    break;
                case "UShape":
                    container.Width = 100;
                    container.Height = 45;
                    info.Height = 45;
                    info.LeftHeight = 40;
                    info.RightHeight = 40;
                    break;
                case "HShape":
                    container.Width = 100;
                    container.Height = 50;
                    info.Height = 50;
                    info.LeftHeight = 40;
                    info.RightHeight = 40;
                    break;
            }

            container.Tag = info;
            RedrawLineShape(container, info);
            AddResizeHandles(container, lineType);

            var border = new Border
            {
                Child = container,
                BorderThickness = new Thickness(0),
                Background = Brushes.Transparent,
                Cursor = Cursors.SizeAll
            };

            Canvas.SetLeft(border, 150);
            Canvas.SetTop(border, 150);
            ChartCanvas.Children.Add(border);
            annotations.Add(border);
        }
        private void RedrawLineShape(Canvas container, LineShapeInfo info)
        {
            // 皜??敶Ｙ?蝺?嚗???Handle嚗?
            ClearShapeLines(container);

            switch (info.Type)
            {
                case "Line":
                    var line = new Line
                    {
                        X1 = info.StartX,
                        Y1 = info.StartY,
                        X2 = info.EndX,
                        Y2 = info.EndY,
                        Stroke = info.Stroke,
                        StrokeThickness = info.Thickness,
                        Tag = "ShapeLine"
                    };
                    container.Children.Add(line);
                    break;

                case "Arrow":
                    DrawArrowShape(container, info);
                    break;

                case "UShape":
                    DrawUShape(container, info);
                    break;

                case "HShape":
                    DrawHShape(container, info);
                    break;
            }
        }
        private void ClearShapeLines(Canvas container)
        {
            var toRemove = container.Children.OfType<FrameworkElement>()
                .Where(c => c.Tag?.ToString() != "Handle").ToList();
            foreach (var item in toRemove)
            {
                container.Children.Remove(item);
            }
        }
        private void DrawArrowShape(Canvas container, LineShapeInfo info)
        {
            double dx = info.EndX - info.StartX;
            double dy = info.EndY - info.StartY;
            double length = Math.Sqrt(dx * dx + dy * dy);
            if (length == 0) length = 1;

            double ux = dx / length, uy = dy / length;
            double px = -uy, py = ux;
            double arrowSize = 10;
            string dir = info.ArrowDirection ?? "Right";

            double lsx = info.StartX, lsy = info.StartY, lex = info.EndX, ley = info.EndY;

            if (dir == "Left" || dir == "Both") { lsx += ux * arrowSize; lsy += uy * arrowSize; }
            if (dir == "Right" || dir == "Both") { lex -= ux * arrowSize; ley -= uy * arrowSize; }

            // 銝餌?璇?
            container.Children.Add(new Line
            {
                X1 = lsx,
                Y1 = lsy,
                X2 = lex,
                Y2 = ley,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });

            // ?喟悌??
            if (dir == "Right" || dir == "Both")
            {
                container.Children.Add(new Polygon
                {
                    Points = new PointCollection {
                new Point(info.EndX - ux * arrowSize + px * arrowSize * 0.5, info.EndY - uy * arrowSize + py * arrowSize * 0.5),
                new Point(info.EndX, info.EndY),
                new Point(info.EndX - ux * arrowSize - px * arrowSize * 0.5, info.EndY - uy * arrowSize - py * arrowSize * 0.5)
            },
                    Fill = info.Stroke,
                    Tag = "ShapeLine"
                });
            }

            // 撌衣悌??
            if (dir == "Left" || dir == "Both")
            {
                container.Children.Add(new Polygon
                {
                    Points = new PointCollection {
                new Point(info.StartX + ux * arrowSize + px * arrowSize * 0.5, info.StartY + uy * arrowSize + py * arrowSize * 0.5),
                new Point(info.StartX, info.StartY),
                new Point(info.StartX + ux * arrowSize - px * arrowSize * 0.5, info.StartY + uy * arrowSize - py * arrowSize * 0.5)
            },
                    Fill = info.Stroke,
                    Tag = "ShapeLine"
                });
            }
        }

        private void DrawUShape(Canvas container, LineShapeInfo info)
        {
            // ??敶Ｙ?嚗椰?蝺?+ ?瘞游像蝺?+ ?喳??渡?
            // 撌阡??蝺?敺??典?銝?
            container.Children.Add(new Line
            {
                X1 = 0,
                Y1 = 0,
                X2 = 0,
                Y2 = info.LeftHeight,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });

            // ?瘞游像蝺?
            container.Children.Add(new Line
            {
                X1 = 0,
                Y1 = 0,
                X2 = info.Width,
                Y2 = 0,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });

            // ?喲??蝺?敺??典?銝?
            container.Children.Add(new Line
            {
                X1 = info.Width,
                Y1 = 0,
                X2 = info.Width,
                Y2 = info.RightHeight,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });
        }
        
        private void DrawHShape(Canvas container, LineShapeInfo info)
        {
            // H 敶Ｙ?嚗極摮?嚗?
            double midY = info.Height / 2;

            // 撌阡??蝺?
            container.Children.Add(new Line
            {
                X1 = 0,
                Y1 = midY - info.LeftHeight / 2,
                X2 = 0,
                Y2 = midY + info.LeftHeight / 2,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });

            // 銝剝?瘞游像蝺?
            container.Children.Add(new Line
            {
                X1 = 0,
                Y1 = midY,
                X2 = info.Width,
                Y2 = midY,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });

            // ?喲??蝺?
            container.Children.Add(new Line
            {
                X1 = info.Width,
                Y1 = midY - info.RightHeight / 2,
                X2 = info.Width,
                Y2 = midY + info.RightHeight / 2,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });
        }

        private void DeleteSelected_Click(object sender, RoutedEventArgs e) => DeleteSelectedAnnotations();

        #endregion

        #region Statistics

        private void OpenStatistics_Click(object sender, RoutedEventArgs e)
        {
            var statsWindow = new StatisticsWindow(dataSeries, chartType);
            statsWindow.Owner = this;
            statsWindow.Show();
        }

        #endregion

        #region Chart Size Control

        private void SizePreset_Changed(object sender, SelectionChangedEventArgs e)
        {
            // Guard against event firing during initialization
            if (ChartWidthBox == null || ChartHeightBox == null || ChartCanvas == null) return;
            
            if (SizePresetCombo.SelectedItem is ComboBoxItem item && item.Tag is string tag)
            {
                if (tag == "custom")
                {
                    // Show custom size controls
                    ChartWidthBox.Visibility = Visibility.Visible;
                    SizeXLabel.Visibility = Visibility.Visible;
                    ChartHeightBox.Visibility = Visibility.Visible;
                    ApplySizeBtn.Visibility = Visibility.Visible;
                    return;
                }
                else
                {
                    // Hide custom size controls
                    ChartWidthBox.Visibility = Visibility.Collapsed;
                    SizeXLabel.Visibility = Visibility.Collapsed;
                    ChartHeightBox.Visibility = Visibility.Collapsed;
                    ApplySizeBtn.Visibility = Visibility.Collapsed;
                }

                var parts = tag.Split(',');
                if (parts.Length == 2 && int.TryParse(parts[0], out int w) && int.TryParse(parts[1], out int h))
                {
                    if (w == 0 && h == 0)
                    {
                        // Auto fit
                        useFixedSize = false;
                        ChartCanvas.Width = double.NaN;
                        ChartCanvas.Height = double.NaN;
                        ChartCanvas.UpdateLayout();
                        DrawChart();
                    }
                    else
                    {
                        // Apply preset size
                        useFixedSize = true;
                        fixedChartWidth = w;
                        fixedChartHeight = h;
                        ChartCanvas.Width = w;
                        ChartCanvas.Height = h;
                        ChartWidthBox.Text = w.ToString();
                        ChartHeightBox.Text = h.ToString();
                        DrawChart();
                    }
                }
            }
        }

        private void ApplyChartSize_Click(object sender, RoutedEventArgs e)
        {
            if (!double.TryParse(ChartWidthBox.Text, out double width) || width < 200)
            {
                MessageBox.Show("Invalid width. Minimum is 200.", "Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            if (!double.TryParse(ChartHeightBox.Text, out double height) || height < 150)
            {
                MessageBox.Show("Invalid height. Minimum is 150.", "Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            useFixedSize = true;
            fixedChartWidth = width;
            fixedChartHeight = height;

            ChartCanvas.Width = width;
            ChartCanvas.Height = height;
            DrawChart();
        }

        private void FitToWindow_Click(object sender, RoutedEventArgs e)
        {
            useFixedSize = false;
            ChartCanvas.Width = double.NaN;
            ChartCanvas.Height = double.NaN;
            
            // Force layout update
            ChartCanvas.UpdateLayout();
            DrawChart();
            
            // Update textboxes to show current size
            Dispatcher.BeginInvoke(new Action(() =>
            {
                ChartWidthBox.Text = ((int)ChartCanvas.ActualWidth).ToString();
                ChartHeightBox.Text = ((int)ChartCanvas.ActualHeight).ToString();
            }), System.Windows.Threading.DispatcherPriority.Loaded);
        }

        /// <summary>
        /// Calculate the bounding box of all visible elements on the canvas
        /// </summary>
        private Rect GetChartBoundingBox()
        {
            double minX = double.MaxValue, minY = double.MaxValue;
            double maxX = double.MinValue, maxY = double.MinValue;

            foreach (UIElement child in ChartCanvas.Children)
            {
                double left = Canvas.GetLeft(child);
                double top = Canvas.GetTop(child);
                
                if (double.IsNaN(left)) left = 0;
                if (double.IsNaN(top)) top = 0;

                double width = 0, height = 0;

                if (child is FrameworkElement fe)
                {
                    fe.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                    width = fe.ActualWidth > 0 ? fe.ActualWidth : fe.DesiredSize.Width;
                    height = fe.ActualHeight > 0 ? fe.ActualHeight : fe.DesiredSize.Height;
                }

                if (child is Line line)
                {
                    minX = Math.Min(minX, Math.Min(line.X1, line.X2));
                    minY = Math.Min(minY, Math.Min(line.Y1, line.Y2));
                    maxX = Math.Max(maxX, Math.Max(line.X1, line.X2));
                    maxY = Math.Max(maxY, Math.Max(line.Y1, line.Y2));
                }
                else
                {
                    minX = Math.Min(minX, left);
                    minY = Math.Min(minY, top);
                    maxX = Math.Max(maxX, left + width);
                    maxY = Math.Max(maxY, top + height);
                }
            }

            // Fallback to canvas size if no elements
            if (minX == double.MaxValue)
            {
                return new Rect(0, 0, ChartCanvas.ActualWidth, ChartCanvas.ActualHeight);
            }

            // Add small padding
            double padding = 5;
            return new Rect(
                Math.Max(0, minX - padding),
                Math.Max(0, minY - padding),
                Math.Min(ChartCanvas.ActualWidth, maxX + padding) - Math.Max(0, minX - padding),
                Math.Min(ChartCanvas.ActualHeight, maxY + padding) - Math.Max(0, minY - padding)
            );
        }

        #endregion

        #region Save/Copy

        private void SaveAsPng_Click(object sender, RoutedEventArgs e)
        {
            var dlg = new SaveFileDialog { Filter = "PNG Image|*.png", FileName = "barchart.png" };
            if (dlg.ShowDialog() == true)
            {
                // Render full canvas
                int width = (int)ChartCanvas.ActualWidth;
                int height = (int)ChartCanvas.ActualHeight;
                
                var bmp = new RenderTargetBitmap(width, height, 96, 96, PixelFormats.Pbgra32);
                bmp.Render(ChartCanvas);
                
                var enc = new PngBitmapEncoder();
                enc.Frames.Add(BitmapFrame.Create(bmp));
                using (var s = File.Create(dlg.FileName)) enc.Save(s);
                MessageBox.Show($"Saved! ({width}?{height})", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        private void SaveAsSvg_Click(object sender, RoutedEventArgs e)
        {
            var dlg = new SaveFileDialog { Filter = "SVG File|*.svg", FileName = "barchart.svg" };
            if (dlg.ShowDialog() == true)
            {
                int width = (int)ChartCanvas.ActualWidth;
                int height = (int)ChartCanvas.ActualHeight;
                
                using (var w = new StreamWriter(dlg.FileName))
                {
                    w.WriteLine($"<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"{width}\" height=\"{height}\">");
                    w.WriteLine("<rect width=\"100%\" height=\"100%\" fill=\"white\"/>");
                    
                    foreach (var c in ChartCanvas.Children)
                    {
                        if (c is Rectangle r && r.Tag?.ToString() != "Handle")
                        {
                            var fill = (r.Fill as SolidColorBrush)?.Color ?? Colors.Gray;
                            double rx = Canvas.GetLeft(r);
                            double ry = Canvas.GetTop(r);
                            if (double.IsNaN(rx)) rx = 0;
                            if (double.IsNaN(ry)) ry = 0;
                            w.WriteLine($"<rect x=\"{rx:F1}\" y=\"{ry:F1}\" width=\"{r.Width:F1}\" height=\"{r.Height:F1}\" fill=\"#{fill.R:X2}{fill.G:X2}{fill.B:X2}\"/>");
                        }
                        else if (c is Line l)
                        {
                            var col = (l.Stroke as SolidColorBrush)?.Color ?? Colors.Black;
                            w.WriteLine($"<line x1=\"{l.X1:F1}\" y1=\"{l.Y1:F1}\" x2=\"{l.X2:F1}\" y2=\"{l.Y2:F1}\" stroke=\"#{col.R:X2}{col.G:X2}{col.B:X2}\" stroke-width=\"{l.StrokeThickness}\"/>");
                        }
                        else if (c is TextBlock tb)
                        {
                            double tx = Canvas.GetLeft(tb);
                            double ty = Canvas.GetTop(tb);
                            if (double.IsNaN(tx)) tx = 0;
                            if (double.IsNaN(ty)) ty = 0;
                            var col = (tb.Foreground as SolidColorBrush)?.Color ?? Colors.Black;
                            w.WriteLine($"<text x=\"{tx:F1}\" y=\"{ty + tb.FontSize:F1}\" font-size=\"{tb.FontSize}\" fill=\"#{col.R:X2}{col.G:X2}{col.B:X2}\">{System.Security.SecurityElement.Escape(tb.Text)}</text>");
                        }
                        else if (c is Ellipse el)
                        {
                            double ex = Canvas.GetLeft(el) + el.Width / 2;
                            double ey = Canvas.GetTop(el) + el.Height / 2;
                            var fill = (el.Fill as SolidColorBrush)?.Color ?? Colors.Gray;
                            w.WriteLine($"<ellipse cx=\"{ex:F1}\" cy=\"{ey:F1}\" rx=\"{el.Width / 2:F1}\" ry=\"{el.Height / 2:F1}\" fill=\"#{fill.R:X2}{fill.G:X2}{fill.B:X2}\"/>");
                        }
                    }
                    w.WriteLine("</svg>");
                }
                MessageBox.Show($"Saved! ({width}?{height})", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        private void CopyToClipboard_Click(object sender, RoutedEventArgs e) => CopyChartToClipboard();

        private void CopyChartToClipboard()
        {
            int width = (int)ChartCanvas.ActualWidth;
            int height = (int)ChartCanvas.ActualHeight;
            
            var bmp = new RenderTargetBitmap(width, height, 96, 96, PixelFormats.Pbgra32);
            bmp.Render(ChartCanvas);
            Clipboard.SetImage(bmp);
            MessageBox.Show($"Chart copied! ({width}?{height})", "Copied", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        #endregion
    }
   

    #region Helper Classes

    public class BarStyle
    {
        public Color FillColor { get; set; } = Colors.DodgerBlue;
        public Color BorderColor { get; set; } = Colors.Black;
        public double BorderThickness { get; set; } = 1;
        public FillPattern Pattern { get; set; } = FillPattern.Solid;
        public ErrorBarDirection ErrorDirection { get; set; } = ErrorBarDirection.Both;
    }

    public enum FillPattern
    {
        Solid,
        HorizontalLines,
        VerticalLines,
        DiagonalUp,
        DiagonalDown,
        CrossHatch,
        Dots
    }

    public enum ErrorBarDirection
    {
        Both,
        Up,
        Down
    }

    public class BarInfo
    {
        public int SeriesIndex { get; set; }
        public int XIndex { get; set; }
        public Rect Bounds { get; set; }
    }

    #endregion
}


==================================================
FILE_NAME: BarStyleEditorDialog.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\BarStyleEditorDialog.xaml
==================================================
<Window x:Class="BioSAK.BarStyleEditorDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Edit Bar Styles" 
        Height="550" Width="650"
        WindowStartupLocation="CenterOwner"
        Background="#F5F5F5">

    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="? Edit Bar Styles" FontSize="18" FontWeight="Bold" Margin="0,0,0,15"/>

        <!-- Edit Mode Selection -->
        <Border Grid.Row="1" Background="White" CornerRadius="5" Padding="15" Margin="0,0,0,10">
            <StackPanel>
                <TextBlock Text="Edit Mode:" FontWeight="SemiBold" Margin="0,0,0,10"/>
                <WrapPanel>
                    <RadioButton x:Name="ModeAll" Content="All Bars" GroupName="EditMode" IsChecked="True" Margin="0,0,20,5"/>
                    <RadioButton x:Name="ModeSeries" Content="Same Series" GroupName="EditMode" Margin="0,0,20,5"/>
                    <RadioButton x:Name="ModeRow" Content="Same X (Row)" GroupName="EditMode" Margin="0,0,20,5"/>
                    <RadioButton x:Name="ModeIndividual" Content="Individual" GroupName="EditMode" Margin="0,0,20,5"/>
                </WrapPanel>
                
                <Grid Margin="0,10,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="150"/>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="150"/>
                    </Grid.ColumnDefinitions>
                    
                    <TextBlock Grid.Column="0" Text="Series:" VerticalAlignment="Center" Margin="0,0,10,0"/>
                    <ComboBox Grid.Column="1" x:Name="SeriesCombo" Width="140"/>
                    
                    <TextBlock Grid.Column="2" Text="X Index:" VerticalAlignment="Center" Margin="20,0,10,0"/>
                    <ComboBox Grid.Column="3" x:Name="XIndexCombo" Width="140"/>
                </Grid>
            </StackPanel>
        </Border>

        <!-- Style Settings -->
        <Border Grid.Row="2" Background="White" CornerRadius="5" Padding="15">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="120"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- Fill Color -->
                <TextBlock Grid.Row="0" Grid.Column="0" Text="Fill Color:" VerticalAlignment="Center" Margin="0,5"/>
                <StackPanel Grid.Row="0" Grid.Column="1" Orientation="Horizontal" Margin="0,5">
                    <Border x:Name="FillColorPreview" Width="30" Height="25" BorderBrush="Gray" BorderThickness="1" Background="DodgerBlue" Margin="0,0,10,0"/>
                    <Button Content="Choose..." Padding="10,3" Click="ChooseFillColor_Click"/>
                    <WrapPanel Margin="15,0,0,0">
                        <Button Content=" " Width="22" Height="22" Margin="2" Background="#4285F4" Click="QuickColor_Click" Tag="#4285F4"/>
                        <Button Content=" " Width="22" Height="22" Margin="2" Background="#EA4335" Click="QuickColor_Click" Tag="#EA4335"/>
                        <Button Content=" " Width="22" Height="22" Margin="2" Background="#34A853" Click="QuickColor_Click" Tag="#34A853"/>
                        <Button Content=" " Width="22" Height="22" Margin="2" Background="#FBBC05" Click="QuickColor_Click" Tag="#FBBC05"/>
                        <Button Content=" " Width="22" Height="22" Margin="2" Background="#9A47B6" Click="QuickColor_Click" Tag="#9A47B6"/>
                        <Button Content=" " Width="22" Height="22" Margin="2" Background="#FF7043" Click="QuickColor_Click" Tag="#FF7043"/>
                        <Button Content=" " Width="22" Height="22" Margin="2" Background="#00ACC1" Click="QuickColor_Click" Tag="#00ACC1"/>
                        <Button Content=" " Width="22" Height="22" Margin="2" Background="#7C4DFF" Click="QuickColor_Click" Tag="#7C4DFF"/>
                    </WrapPanel>
                </StackPanel>

                <!-- Border Color -->
                <TextBlock Grid.Row="1" Grid.Column="0" Text="Border Color:" VerticalAlignment="Center" Margin="0,5"/>
                <StackPanel Grid.Row="1" Grid.Column="1" Orientation="Horizontal" Margin="0,5">
                    <Border x:Name="BorderColorPreview" Width="30" Height="25" BorderBrush="Gray" BorderThickness="1" Background="Black" Margin="0,0,10,0"/>
                    <Button Content="Choose..." Padding="10,3" Click="ChooseBorderColor_Click"/>
                </StackPanel>

                <!-- Border Thickness -->
                <TextBlock Grid.Row="2" Grid.Column="0" Text="Border Width:" VerticalAlignment="Center" Margin="0,5"/>
                <StackPanel Grid.Row="2" Grid.Column="1" Orientation="Horizontal" Margin="0,5">
                    <Slider x:Name="BorderThicknessSlider" Width="150" Minimum="0" Maximum="5" Value="1" TickFrequency="0.5" IsSnapToTickEnabled="True"/>
                    <TextBlock x:Name="BorderThicknessLabel" Text="1" Margin="10,0,0,0" VerticalAlignment="Center"/>
                </StackPanel>

                <!-- Fill Pattern -->
                <TextBlock Grid.Row="3" Grid.Column="0" Text="Fill Pattern:" VerticalAlignment="Center" Margin="0,5"/>
                <ComboBox Grid.Row="3" Grid.Column="1" x:Name="PatternCombo" Width="200" HorizontalAlignment="Left" Margin="0,5">
                    <ComboBoxItem Content="Solid" Tag="Solid" IsSelected="True"/>
                    <ComboBoxItem Content="Horizontal Lines" Tag="HorizontalLines"/>
                    <ComboBoxItem Content="Vertical Lines" Tag="VerticalLines"/>
                    <ComboBoxItem Content="Diagonal Up (/)" Tag="DiagonalUp"/>
                    <ComboBoxItem Content="Diagonal Down (\)" Tag="DiagonalDown"/>
                    <ComboBoxItem Content="Cross Hatch" Tag="CrossHatch"/>
                    <ComboBoxItem Content="Dots" Tag="Dots"/>
                </ComboBox>

                <!-- Preview -->
                <TextBlock Grid.Row="4" Grid.Column="0" Text="Preview:" VerticalAlignment="Top" Margin="0,15,0,0"/>
                <Border Grid.Row="4" Grid.Column="1" x:Name="PreviewBorder" Width="100" Height="60" 
                        HorizontalAlignment="Left" Margin="0,15,0,0"
                        BorderBrush="Black" BorderThickness="1"/>
            </Grid>
        </Border>

        <!-- Buttons -->
        <StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
            <Button Content="Apply" Padding="20,8" Margin="0,0,10,0"
                    Background="#FF9800" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="Apply_Click"/>
            <Button Content="Cancel" Padding="20,8" Margin="0,0,10,0"
                    Background="#9E9E9E" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="Cancel_Click"/>
            <Button Content="OK" Padding="20,8"
                    Background="#4CAF50" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="OK_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: BarStyleEditorDialog.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\BarStyleEditorDialog.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace BioSAK
{
    public partial class BarStyleEditorDialog : Window
    {
        private List<ChartDataSeries> dataSeries;
        private string chartType;
        public Dictionary<(int, int), BarStyle> UpdatedStyles { get; private set; }

        private Color currentFillColor = Colors.DodgerBlue;
        private Color currentBorderColor = Colors.Black;

        public BarStyleEditorDialog(List<ChartDataSeries> data, Dictionary<(int, int), BarStyle> styles, string type)
        {
            InitializeComponent();
            dataSeries = data;
            chartType = type;
            UpdatedStyles = new Dictionary<(int, int), BarStyle>(styles);

            InitializeControls();
            BorderThicknessSlider.ValueChanged += (s, e) => { BorderThicknessLabel.Text = BorderThicknessSlider.Value.ToString("F1"); UpdatePreview(); };
            PatternCombo.SelectionChanged += (s, e) => UpdatePreview();

            UpdatePreview();
        }

        private void InitializeControls()
        {
            // Populate series combo
            for (int i = 0; i < dataSeries.Count; i++)
                SeriesCombo.Items.Add($"{i}: {dataSeries[i].Name}");
            if (SeriesCombo.Items.Count > 0) SeriesCombo.SelectedIndex = 0;

            // Populate X index combo - use XLabels if available
            int maxX = dataSeries.Max(s => s.XValues.Count);
            for (int i = 0; i < maxX; i++)
            {
                string label;
                if (dataSeries.Count > 0 && i < dataSeries[0].XLabels.Count &&
                    !string.IsNullOrEmpty(dataSeries[0].XLabels[i]))
                {
                    label = $"{i}: {dataSeries[0].XLabels[i]}";
                }
                else if (dataSeries.Count > 0 && i < dataSeries[0].XValues.Count)
                {
                    label = $"{i}: X={dataSeries[0].XValues[i]:G4}";
                }
                else
                {
                    label = $"{i}";
                }
                XIndexCombo.Items.Add(label);
            }
            if (XIndexCombo.Items.Count > 0) XIndexCombo.SelectedIndex = 0;
        }

        private void ChooseFillColor_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new ColorPickerDialog(currentFillColor);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                currentFillColor = dialog.SelectedColor;
                FillColorPreview.Background = new SolidColorBrush(currentFillColor);
                UpdatePreview();
            }
        }

        private void ChooseBorderColor_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new ColorPickerDialog(currentBorderColor);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                currentBorderColor = dialog.SelectedColor;
                BorderColorPreview.Background = new SolidColorBrush(currentBorderColor);
                UpdatePreview();
            }
        }

        private void QuickColor_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button btn && btn.Tag is string colorStr)
            {
                try
                {
                    currentFillColor = (Color)ColorConverter.ConvertFromString(colorStr);
                    FillColorPreview.Background = new SolidColorBrush(currentFillColor);
                    UpdatePreview();
                }
                catch { }
            }
        }

        private FillPattern GetSelectedPattern()
        {
            if (PatternCombo.SelectedItem is ComboBoxItem item && item.Tag is string tag)
            {
                return Enum.TryParse<FillPattern>(tag, out var pattern) ? pattern : FillPattern.Solid;
            }
            return FillPattern.Solid;
        }

        private void UpdatePreview()
        {
            var style = new BarStyle
            {
                FillColor = currentFillColor,
                BorderColor = currentBorderColor,
                BorderThickness = BorderThicknessSlider.Value,
                Pattern = GetSelectedPattern()
            };

            PreviewBorder.Background = CreatePatternBrush(style);
            PreviewBorder.BorderBrush = new SolidColorBrush(style.BorderColor);
            PreviewBorder.BorderThickness = new Thickness(style.BorderThickness);
        }

        private Brush CreatePatternBrush(BarStyle style)
        {
            var color = style.FillColor;

            switch (style.Pattern)
            {
                case FillPattern.Solid:
                    return new SolidColorBrush(color);

                case FillPattern.HorizontalLines:
                    return CreateLineBrush(color, 0);

                case FillPattern.VerticalLines:
                    return CreateLineBrush(color, 90);

                case FillPattern.DiagonalUp:
                    return CreateLineBrush(color, 45);

                case FillPattern.DiagonalDown:
                    return CreateLineBrush(color, -45);

                case FillPattern.CrossHatch:
                    return CreateCrossHatchBrush(color);

                case FillPattern.Dots:
                    return CreateDotsBrush(color);

                default:
                    return new SolidColorBrush(color);
            }
        }

        private Brush CreateLineBrush(Color color, double angle)
        {
            var brush = new DrawingBrush
            {
                TileMode = TileMode.Tile,
                Viewport = new Rect(0, 0, 8, 8),
                ViewportUnits = BrushMappingMode.Absolute
            };

            var group = new DrawingGroup();
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(Color.FromArgb(50, color.R, color.G, color.B)),
                null, new RectangleGeometry(new Rect(0, 0, 8, 8))));
            group.Children.Add(new GeometryDrawing(
                null, new Pen(new SolidColorBrush(color), 2),
                new LineGeometry(new Point(0, 4), new Point(8, 4))));

            brush.Drawing = group;
            brush.Transform = new RotateTransform(angle, 4, 4);
            return brush;
        }

        private Brush CreateCrossHatchBrush(Color color)
        {
            var brush = new DrawingBrush
            {
                TileMode = TileMode.Tile,
                Viewport = new Rect(0, 0, 8, 8),
                ViewportUnits = BrushMappingMode.Absolute
            };

            var group = new DrawingGroup();
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(Color.FromArgb(50, color.R, color.G, color.B)),
                null, new RectangleGeometry(new Rect(0, 0, 8, 8))));
            group.Children.Add(new GeometryDrawing(
                null, new Pen(new SolidColorBrush(color), 1),
                new LineGeometry(new Point(0, 0), new Point(8, 8))));
            group.Children.Add(new GeometryDrawing(
                null, new Pen(new SolidColorBrush(color), 1),
                new LineGeometry(new Point(8, 0), new Point(0, 8))));

            brush.Drawing = group;
            return brush;
        }

        private Brush CreateDotsBrush(Color color)
        {
            var brush = new DrawingBrush
            {
                TileMode = TileMode.Tile,
                Viewport = new Rect(0, 0, 8, 8),
                ViewportUnits = BrushMappingMode.Absolute
            };

            var group = new DrawingGroup();
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(Color.FromArgb(50, color.R, color.G, color.B)),
                null, new RectangleGeometry(new Rect(0, 0, 8, 8))));
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(color), null,
                new EllipseGeometry(new Point(4, 4), 2, 2)));

            brush.Drawing = group;
            return brush;
        }

        private BarStyle CreateCurrentStyle()
        {
            return new BarStyle
            {
                FillColor = currentFillColor,
                BorderColor = currentBorderColor,
                BorderThickness = BorderThicknessSlider.Value,
                Pattern = GetSelectedPattern()
            };
        }

        private void Apply_Click(object sender, RoutedEventArgs e)
        {
            ApplyStyle();
        }

        private void ApplyStyle()
        {
            var style = CreateCurrentStyle();

            if (ModeAll.IsChecked == true)
            {
                // Apply to all bars
                for (int s = 0; s < dataSeries.Count; s++)
                {
                    for (int x = 0; x < dataSeries[s].XValues.Count; x++)
                    {
                        UpdatedStyles[(s, x)] = CloneStyle(style);
                    }
                }
            }
            else if (ModeSeries.IsChecked == true)
            {
                // Apply to same series
                int selectedSeries = SeriesCombo.SelectedIndex;
                if (selectedSeries >= 0 && selectedSeries < dataSeries.Count)
                {
                    for (int x = 0; x < dataSeries[selectedSeries].XValues.Count; x++)
                    {
                        UpdatedStyles[(selectedSeries, x)] = CloneStyle(style);
                    }
                }
            }
            else if (ModeRow.IsChecked == true)
            {
                // Apply to same X (row)
                int selectedX = XIndexCombo.SelectedIndex;
                for (int s = 0; s < dataSeries.Count; s++)
                {
                    if (selectedX < dataSeries[s].XValues.Count)
                    {
                        UpdatedStyles[(s, selectedX)] = CloneStyle(style);
                    }
                }
            }
            else if (ModeIndividual.IsChecked == true)
            {
                // Apply to individual bar
                int selectedSeries = SeriesCombo.SelectedIndex;
                int selectedX = XIndexCombo.SelectedIndex;
                if (selectedSeries >= 0 && selectedX >= 0)
                {
                    UpdatedStyles[(selectedSeries, selectedX)] = CloneStyle(style);
                }
            }
        }

        private BarStyle CloneStyle(BarStyle style)
        {
            return new BarStyle
            {
                FillColor = style.FillColor,
                BorderColor = style.BorderColor,
                BorderThickness = style.BorderThickness,
                Pattern = style.Pattern
            };
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }

        private void OK_Click(object sender, RoutedEventArgs e)
        {
            ApplyStyle();
            DialogResult = true;
            Close();
        }
    }
}

==================================================
FILE_NAME: ChartSettingsWindow.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\ChartSettingsWindow.xaml
==================================================
<Window x:Class="BioSAK.ChartSettingsWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Chart Settings" 
        Height="550" Width="480"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Title Settings -->
        <GroupBox Grid.Row="0" Header="Titles" Margin="0,0,0,15" Padding="10">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="100"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <TextBlock Grid.Row="0" Grid.Column="0" Text="Main Title:" VerticalAlignment="Center"/>
                <TextBox Grid.Row="0" Grid.Column="1" x:Name="ChartTitleBox" Margin="0,5"/>

                <TextBlock Grid.Row="1" Grid.Column="0" Text="Subtitle:" VerticalAlignment="Center"/>
                <TextBox Grid.Row="1" Grid.Column="1" x:Name="ChartSubtitleBox" Margin="0,5"/>

                <TextBlock Grid.Row="1" Grid.Column="1" Text="(Use | in Main Title for two lines)" 
                           FontSize="10" Foreground="#888" VerticalAlignment="Bottom" 
                           HorizontalAlignment="Right" Margin="0,0,0,-2"/>

                <TextBlock Grid.Row="2" Grid.Column="0" Text="X Axis Title:" VerticalAlignment="Center"/>
                <TextBox Grid.Row="2" Grid.Column="1" x:Name="XAxisTitleBox" Margin="0,5"/>

                <TextBlock Grid.Row="3" Grid.Column="0" Text="Y Axis Title:" VerticalAlignment="Center"/>
                <TextBox Grid.Row="3" Grid.Column="1" x:Name="YAxisTitleBox" Margin="0,5"/>
            </Grid>
        </GroupBox>

        <!-- Chart Type -->
        <GroupBox Grid.Row="1" Header="Chart Type" Margin="0,0,0,15" Padding="10">
            <StackPanel Orientation="Horizontal">
                <RadioButton x:Name="LineTypeRadio" Content="Line" Margin="0,0,20,0"/>
                <RadioButton x:Name="ScatterTypeRadio" Content="Scatter" Margin="0,0,20,0"/>
                <RadioButton x:Name="VolcanoTypeRadio" Content="Volcano"/>
            </StackPanel>
        </GroupBox>

        <!-- Series Settings -->
        <GroupBox Grid.Row="2" Header="Series Settings" Padding="10">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <ComboBox Grid.Row="0" x:Name="SeriesSelector" Margin="0,0,0,10"
                          SelectionChanged="SeriesSelector_SelectionChanged"/>

                <Grid Grid.Row="1">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="100"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>

                    <!-- Color -->
                    <TextBlock Grid.Row="0" Grid.Column="0" Text="Color:" VerticalAlignment="Center"/>
                    <StackPanel Grid.Row="0" Grid.Column="1" Orientation="Horizontal" Margin="0,5">
                        <Border x:Name="ColorPreview" Width="30" Height="25" BorderBrush="#CCC" 
                                BorderThickness="1" CornerRadius="3" Margin="0,0,10,0"/>
                        <Button Content="Choose..." Padding="10,3" Click="ChooseColor_Click"/>
                    </StackPanel>

                    <!-- Line Thickness -->
                    <TextBlock Grid.Row="1" Grid.Column="0" Text="Line Width:" VerticalAlignment="Center"/>
                    <StackPanel Grid.Row="1" Grid.Column="1" Orientation="Horizontal" Margin="0,5">
                        <Slider x:Name="LineThicknessSlider" Width="150" Minimum="1" Maximum="10" 
                                Value="2" TickFrequency="1" IsSnapToTickEnabled="True"
                                ValueChanged="LineThickness_Changed"/>
                        <TextBlock x:Name="LineThicknessLabel" Text="2" Margin="10,0,0,0" VerticalAlignment="Center"/>
                    </StackPanel>

                    <!-- Marker Size -->
                    <TextBlock Grid.Row="2" Grid.Column="0" Text="Marker Size:" VerticalAlignment="Center"/>
                    <StackPanel Grid.Row="2" Grid.Column="1" Orientation="Horizontal" Margin="0,5">
                        <Slider x:Name="MarkerSizeSlider" Width="150" Minimum="4" Maximum="20" 
                                Value="8" TickFrequency="2" IsSnapToTickEnabled="True"
                                ValueChanged="MarkerSize_Changed"/>
                        <TextBlock x:Name="MarkerSizeLabel" Text="8" Margin="10,0,0,0" VerticalAlignment="Center"/>
                    </StackPanel>

                    <!-- Marker Shape -->
                    <TextBlock Grid.Row="3" Grid.Column="0" Text="Marker Shape:" VerticalAlignment="Center"/>
                    <ComboBox Grid.Row="3" Grid.Column="1" x:Name="MarkerShapeCombo" Margin="0,5"
                              SelectionChanged="MarkerShape_Changed">
                        <ComboBoxItem Content="Circle" IsSelected="True"/>
                        <ComboBoxItem Content="Square"/>
                        <ComboBoxItem Content="Triangle"/>
                        <ComboBoxItem Content="Diamond"/>
                    </ComboBox>
                </Grid>
            </Grid>
        </GroupBox>

        <!-- Buttons -->
        <StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
            <Button Content="Cancel" Width="80" Padding="5,8" Margin="0,0,10,0"
                    Background="#EEE" BorderThickness="0" Cursor="Hand"
                    Click="Cancel_Click"/>
            <Button Content="Apply" Width="80" Padding="5,8"
                    Background="#4FC3F7" Foreground="White" BorderThickness="0" Cursor="Hand"
                    Click="Apply_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: ChartSettingsWindow.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\ChartSettingsWindow.xaml.cs
==================================================
using System.Collections.Generic;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace BioSAK
{
    public partial class ChartSettingsWindow : Window
    {
        private List<ChartDataSeries>? dataSeries;
        private int selectedIndex = 0;
        private bool isInitialized = false;

        public string ChartTitle { get; private set; } = "";
        public string XAxisTitle { get; private set; } = "";
        public string YAxisTitle { get; private set; } = "";
        public string SelectedChartType { get; private set; } = "Line";

        public ChartSettingsWindow(List<ChartDataSeries> series, string chartTitle, string xTitle, string yTitle, string chartType)
        {
            InitializeComponent();

            dataSeries = series;
            ChartTitle = chartTitle;
            XAxisTitle = xTitle;
            YAxisTitle = yTitle;
            SelectedChartType = chartType;

            // Initialize UI after loading
            this.Loaded += (s, e) =>
            {
                // Parse two-line title
                string[] titleParts = chartTitle.Split('|');
                ChartTitleBox.Text = titleParts[0].Trim();
                ChartSubtitleBox.Text = titleParts.Length > 1 ? titleParts[1].Trim() : "";

                XAxisTitleBox.Text = xTitle;
                YAxisTitleBox.Text = yTitle;

                // Set chart type
                switch (chartType)
                {
                    case "Line":
                        LineTypeRadio.IsChecked = true;
                        break;
                    case "Scatter":
                        ScatterTypeRadio.IsChecked = true;
                        break;
                    case "Volcano":
                        VolcanoTypeRadio.IsChecked = true;
                        break;
                }

                // Populate series selector
                SeriesSelector.Items.Clear();
                for (int i = 0; i < dataSeries.Count; i++)
                {
                    SeriesSelector.Items.Add(dataSeries[i].Name);
                }

                if (SeriesSelector.Items.Count > 0)
                {
                    SeriesSelector.SelectedIndex = 0;
                }

                isInitialized = true;
            };
        }

        private void SeriesSelector_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (dataSeries == null || SeriesSelector.SelectedIndex < 0 || SeriesSelector.SelectedIndex >= dataSeries.Count)
                return;

            selectedIndex = SeriesSelector.SelectedIndex;
            var series = dataSeries[selectedIndex];

            // Temporarily disable to prevent event loops
            isInitialized = false;

            // Update UI to reflect selected series
            ColorPreview.Background = new SolidColorBrush(series.LineColor);
            LineThicknessSlider.Value = series.LineThickness;
            LineThicknessLabel.Text = ((int)series.LineThickness).ToString();
            MarkerSizeSlider.Value = series.MarkerSize;
            MarkerSizeLabel.Text = series.MarkerSize.ToString();

            // Set marker shape
            switch (series.MarkerShape)
            {
                case "Circle":
                    MarkerShapeCombo.SelectedIndex = 0;
                    break;
                case "Square":
                    MarkerShapeCombo.SelectedIndex = 1;
                    break;
                case "Triangle":
                    MarkerShapeCombo.SelectedIndex = 2;
                    break;
                case "Diamond":
                    MarkerShapeCombo.SelectedIndex = 3;
                    break;
                default:
                    MarkerShapeCombo.SelectedIndex = 0;
                    break;
            }

            isInitialized = true;
        }

        private void ChooseColor_Click(object sender, RoutedEventArgs e)
        {
            if (dataSeries == null || selectedIndex >= dataSeries.Count) return;

            var colorDialog = new ColorPickerDialog(dataSeries[selectedIndex].LineColor);
            colorDialog.Owner = this;

            if (colorDialog.ShowDialog() == true)
            {
                dataSeries[selectedIndex].LineColor = colorDialog.SelectedColor;
                ColorPreview.Background = new SolidColorBrush(colorDialog.SelectedColor);
            }
        }

        private void LineThickness_Changed(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (!isInitialized || dataSeries == null || LineThicknessLabel == null) return;

            LineThicknessLabel.Text = ((int)LineThicknessSlider.Value).ToString();
            if (selectedIndex < dataSeries.Count)
            {
                dataSeries[selectedIndex].LineThickness = LineThicknessSlider.Value;
            }
        }

        private void MarkerSize_Changed(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (!isInitialized || dataSeries == null || MarkerSizeLabel == null) return;

            MarkerSizeLabel.Text = ((int)MarkerSizeSlider.Value).ToString();
            if (selectedIndex < dataSeries.Count)
            {
                dataSeries[selectedIndex].MarkerSize = (int)MarkerSizeSlider.Value;
            }
        }

        private void MarkerShape_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (!isInitialized || dataSeries == null || MarkerShapeCombo.SelectedItem == null) return;

            if (MarkerShapeCombo.SelectedItem is ComboBoxItem item && selectedIndex < dataSeries.Count)
            {
                dataSeries[selectedIndex].MarkerShape = item.Content?.ToString() ?? "Circle";
            }
        }

        private void Apply_Click(object sender, RoutedEventArgs e)
        {
            // Combine title and subtitle with | separator
            string mainTitle = ChartTitleBox.Text.Trim();
            string subtitle = ChartSubtitleBox.Text.Trim();

            if (!string.IsNullOrEmpty(subtitle))
            {
                ChartTitle = $"{mainTitle}|{subtitle}";
            }
            else
            {
                ChartTitle = mainTitle;
            }

            XAxisTitle = XAxisTitleBox.Text;
            YAxisTitle = YAxisTitleBox.Text;

            if (LineTypeRadio.IsChecked == true)
                SelectedChartType = "Line";
            else if (ScatterTypeRadio.IsChecked == true)
                SelectedChartType = "Scatter";
            else if (VolcanoTypeRadio.IsChecked == true)
                SelectedChartType = "Volcano";

            DialogResult = true;
            Close();
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}


==================================================
FILE_NAME: ChartWindow.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\ChartWindow.xaml
==================================================
<Window x:Class="BioSAK.ChartWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Chart" 
        Height="700" Width="900"
        MinHeight="500" MinWidth="600"
        WindowStartupLocation="CenterOwner"
        Background="#F5F5F5"
        KeyDown="Window_KeyDown"
        Focusable="True">

    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Main Toolbar -->
        <Border Grid.Row="0" Background="White" CornerRadius="5" Padding="10" Margin="0,0,0,5">
            <StackPanel Orientation="Horizontal">
                <Button Content="💾 Save PNG" Padding="8,5" Margin="0,0,5,0"
                        Background="#4CAF50" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="SaveAsPng_Click"/>
                <Button Content="💾 Save SVG" Padding="8,5" Margin="0,0,10,0"
                        Background="#2196F3" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="SaveAsSvg_Click"/>
                <Separator Margin="5,0"/>
                <Button Content="📋 Copy to Clipboard" Padding="8,5" Margin="5,0"
                        Background="#9C27B0" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="CopyToClipboard_Click" ToolTip="Ctrl+C"/>
                <Separator Margin="5,0"/>
                <Button Content="📊 Statistics" Padding="8,5" Margin="5,0"
                        Background="#FF5722" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="OpenStatistics_Click"/>
                <Separator Margin="5,0"/>
                <TextBlock Text="Double-click chart to edit | Ctrl+A: Select All | Del: Delete" 
                           VerticalAlignment="Center" Foreground="#888" FontStyle="Italic" Margin="10,0"/>
            </StackPanel>
        </Border>

        <!-- Annotation Toolbar -->
        <Border Grid.Row="1" Background="White" CornerRadius="5" Padding="10" Margin="0,0,0,5">
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="Add:" VerticalAlignment="Center" Margin="0,0,10,0" FontWeight="SemiBold"/>

                <Button x:Name="TextBoxTool" Content="📝 Text" Padding="8,5" Margin="0,0,5,0"
                        Background="#FF9800" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddTextBox_Click" ToolTip="Add Text Box"/>

                <Button Content="Ω Symbol" Padding="8,5" Margin="0,0,5,0"
                        Background="#9C27B0" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="OpenSymbolPicker_Click" ToolTip="Insert Special Symbol"/>

                <Separator Margin="10,0"/>
                <TextBlock Text="Lines:" VerticalAlignment="Center" Margin="0,0,10,0" FontWeight="SemiBold"/>

                <Button Content="─" Padding="10,5" Margin="0,0,3,0"
                        Background="#607D8B" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddLine_Click" ToolTip="Straight Line" Tag="Line"/>
                <Button Content="┌┐" Padding="10,5" Margin="0,0,3,0"
                        Background="#607D8B" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddLine_Click" ToolTip="U-Shape (ㄇ)" Tag="UShape"/>
                <Button Content="→" Padding="10,5" Margin="0,0,3,0"
                        Background="#607D8B" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddLine_Click" ToolTip="Arrow" Tag="Arrow"/>
                <Button Content="╠╣" Padding="10,5" Margin="0,0,3,0"
                        Background="#607D8B" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="AddLine_Click" ToolTip="H-Shape" Tag="HShape"/>

                <Separator Margin="10,0"/>
                <Button Content="🗑 Delete (Del)" Padding="8,5"
                        Background="#EF5350" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="DeleteSelected_Click"/>
            </StackPanel>
        </Border>

        <!-- Chart Area -->
        <Border Grid.Row="2" Background="White" CornerRadius="5" ClipToBounds="True">
            <Grid x:Name="ChartContainer">
                <Canvas x:Name="ChartCanvas" Background="White" 
                        MouseLeftButtonDown="ChartCanvas_MouseLeftButtonDown"
                        MouseMove="ChartCanvas_MouseMove"
                        MouseLeftButtonUp="ChartCanvas_MouseLeftButtonUp"
                        SizeChanged="ChartCanvas_SizeChanged"/>
                <!-- Selection Rectangle -->
                <Rectangle x:Name="SelectionRect" Stroke="#2196F3" StrokeThickness="1" 
                           StrokeDashArray="4 2" Fill="#202196F3" Visibility="Collapsed"/>
            </Grid>
        </Border>

        <!-- Legend -->
        <Border Grid.Row="3" Background="White" CornerRadius="5" Padding="10" Margin="0,5,0,0">
            <WrapPanel x:Name="LegendPanel" HorizontalAlignment="Center"/>
        </Border>
    </Grid>
</Window>


==================================================
FILE_NAME: ChartWindow.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\ChartWindow.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using Microsoft.Win32;

namespace BioSAK
{
    public partial class ChartWindow : Window
    {
        private List<ChartDataSeries> dataSeries;
        private string chartType;
        private string errorType;
        private string xAxisTitle;
        private string yAxisTitle = "Y";
        private string chartTitle = "";

        private double marginLeft = 70;
        private double marginRight = 20;
        private double marginTop = 50;
        private double marginBottom = 50;

        private DateTime lastClickTime = DateTime.MinValue;
        private FrameworkElement? lastClickedElement = null;

        // Annotation tracking
        private List<FrameworkElement> annotations = new List<FrameworkElement>();
        private List<FrameworkElement> selectedAnnotations = new List<FrameworkElement>();
        private FrameworkElement? selectedAnnotation = null;
        private bool isDragging = false;
        private bool isResizing = false;
        private bool isSelecting = false;
        private Point dragStart;
        private Point elementStart;
        private Point selectionStart;
        private string currentResizeHandle = "";
        private Canvas? currentLineCanvas = null;

        // Clipboard for annotations
        private List<AnnotationClipboardItem> clipboardItems = new List<AnnotationClipboardItem>();

        // Chart data points for alignment
        private List<Point> chartDataPoints = new List<Point>();

        private readonly Color[] defaultColors = new Color[]
        {
            Color.FromRgb(66, 133, 244), Color.FromRgb(234, 67, 53),
            Color.FromRgb(52, 168, 83), Color.FromRgb(251, 188, 5),
            Color.FromRgb(154, 71, 182), Color.FromRgb(255, 112, 67),
            Color.FromRgb(0, 172, 193), Color.FromRgb(124, 77, 255),
        };

        public ChartWindow(List<ChartDataSeries> data, string type, string error, string xTitle)
        {
            InitializeComponent();

            dataSeries = data;
            chartType = type;
            errorType = error;
            xAxisTitle = xTitle;
            chartTitle = $"{type} Chart";

            for (int i = 0; i < dataSeries.Count; i++)
            {
                dataSeries[i].LineColor = defaultColors[i % defaultColors.Length];
            }

            this.Loaded += (s, e) => { DrawChart(); this.Focus(); };
        }

        #region Keyboard Shortcuts

        private void Window_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Delete)
            {
                DeleteSelectedAnnotations();
                e.Handled = true;
            }
            else if (Keyboard.Modifiers == ModifierKeys.Control)
            {
                switch (e.Key)
                {
                    case Key.C:
                        if (selectedAnnotations.Count > 0 || selectedAnnotation != null)
                            CopySelectedAnnotations();
                        else
                            CopyChartToClipboard();
                        e.Handled = true;
                        break;
                    case Key.V:
                        PasteAnnotations();
                        e.Handled = true;
                        break;
                    case Key.A:
                        SelectAllAnnotations();
                        e.Handled = true;
                        break;
                }
            }
        }

        private void SelectAllAnnotations()
        {
            ClearSelection();
            foreach (var ann in annotations)
            {
                selectedAnnotations.Add(ann);
                HighlightAnnotation(ann, true);
            }
        }

        private void CopySelectedAnnotations()
        {
            clipboardItems.Clear();
            var toCopy = selectedAnnotations.Count > 0 ? selectedAnnotations :
                         (selectedAnnotation != null ? new List<FrameworkElement> { selectedAnnotation } : new List<FrameworkElement>());

            foreach (var ann in toCopy)
            {
                var item = new AnnotationClipboardItem
                {
                    Left = Canvas.GetLeft(ann),
                    Top = Canvas.GetTop(ann)
                };

                if (ann is Border border)
                {
                    if (border.Child is TextBlock tb)
                    {
                        item.Type = "Text";
                        item.Text = tb.Text;
                        item.FormatInfo = border.DataContext as TextFormatInfo;
                    }
                    else if (border.Child is Canvas lineCanvas && lineCanvas.Tag is LineShapeInfo lineInfo)
                    {
                        item.Type = "Line";
                        item.LineInfo = CloneLineInfo(lineInfo);
                    }
                }
                clipboardItems.Add(item);
            }
        }

        private void PasteAnnotations()
        {
            if (clipboardItems.Count == 0) return;

            ClearSelection();
            double offset = 20;

            foreach (var item in clipboardItems)
            {
                if (item.Type == "Text" && item.FormatInfo != null)
                {
                    CreateTextAnnotation(item.Text ?? "", item.FormatInfo.FontSize,
                        item.FormatInfo.FontFamily, item.FormatInfo.IsBold,
                        item.FormatInfo.IsItalic, item.FormatInfo.ShowBorder,
                        item.FormatInfo.TextColor, item.Left + offset, item.Top + offset);
                }
                else if (item.Type == "Line" && item.LineInfo != null)
                {
                    CreateLineFromInfo(item.LineInfo, item.Left + offset, item.Top + offset);
                }
            }
        }

        private void DeleteSelectedAnnotations()
        {
            var toDelete = selectedAnnotations.Count > 0 ? selectedAnnotations.ToList() :
                          (selectedAnnotation != null ? new List<FrameworkElement> { selectedAnnotation } : new List<FrameworkElement>());

            foreach (var ann in toDelete)
            {
                ChartCanvas.Children.Remove(ann);
                annotations.Remove(ann);
            }
            selectedAnnotations.Clear();
            selectedAnnotation = null;
        }

        #endregion

        #region Mouse Events

        private void ChartCanvas_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            DrawChart();
        }

        private void ChartCanvas_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            var pos = e.GetPosition(ChartCanvas);
            var now = DateTime.Now;

            var hitElement = FindAnnotationAt(pos);

            if (hitElement != null)
            {
                bool ctrlPressed = Keyboard.Modifiers == ModifierKeys.Control;

                if (ctrlPressed)
                {
                    // Toggle selection
                    if (selectedAnnotations.Contains(hitElement))
                    {
                        selectedAnnotations.Remove(hitElement);
                        HighlightAnnotation(hitElement, false);
                    }
                    else
                    {
                        selectedAnnotations.Add(hitElement);
                        HighlightAnnotation(hitElement, true);
                    }
                }
                else
                {
                    bool isDoubleClick = (now - lastClickTime).TotalMilliseconds < 300 && lastClickedElement == hitElement;

                    if (isDoubleClick)
                    {
                        if (hitElement is Border border)
                        {
                            if (border.Child is TextBlock)
                                EditTextAnnotation(border);
                            else if (border.Child is Canvas lineCanvas && lineCanvas.Tag is LineShapeInfo)
                                EditLineAnnotation(border);
                        }
                    }
                    else
                    {
                        if (!selectedAnnotations.Contains(hitElement))
                        {
                            ClearSelection();
                            SelectAnnotation(hitElement);
                        }

                        isDragging = true;
                        dragStart = pos;
                        elementStart = new Point(Canvas.GetLeft(hitElement), Canvas.GetTop(hitElement));
                        ChartCanvas.CaptureMouse();
                    }
                }

                lastClickTime = now;
                lastClickedElement = hitElement;
                return;
            }

            // Start selection rectangle
            ClearSelection();
            isSelecting = true;
            selectionStart = pos;
            SelectionRect.Visibility = Visibility.Visible;
            Canvas.SetLeft(SelectionRect, pos.X);
            Canvas.SetTop(SelectionRect, pos.Y);
            SelectionRect.Width = 0;
            SelectionRect.Height = 0;
            ChartCanvas.CaptureMouse();

            // Double-click on empty area opens settings
            if ((now - lastClickTime).TotalMilliseconds < 300 && lastClickedElement == null)
            {
                OpenSettingsDialog();
            }
            lastClickTime = now;
            lastClickedElement = null;
        }

        private void ChartCanvas_MouseMove(object sender, MouseEventArgs e)
        {
            var pos = e.GetPosition(ChartCanvas);

            if (isSelecting)
            {
                double x = Math.Min(pos.X, selectionStart.X);
                double y = Math.Min(pos.Y, selectionStart.Y);
                double w = Math.Abs(pos.X - selectionStart.X);
                double h = Math.Abs(pos.Y - selectionStart.Y);

                Canvas.SetLeft(SelectionRect, x);
                Canvas.SetTop(SelectionRect, y);
                SelectionRect.Width = w;
                SelectionRect.Height = h;
                return;
            }

            if (!isDragging) return;

            bool shiftPressed = Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift);

            double dx = pos.X - dragStart.X;
            double dy = pos.Y - dragStart.Y;

            double newX = elementStart.X + dx;
            double newY = elementStart.Y + dy;

            // Shift: Align to nearest X-axis data point
            if (shiftPressed && chartDataPoints.Count > 0)
            {
                double minDist = double.MaxValue;
                double nearestX = newX;

                foreach (var pt in chartDataPoints)
                {
                    double dist = Math.Abs(newX - pt.X);
                    if (dist < minDist)
                    {
                        minDist = dist;
                        nearestX = pt.X;
                    }
                }

                if (minDist < 20) newX = nearestX;
            }

            if (selectedAnnotation != null)
            {
                Canvas.SetLeft(selectedAnnotation, newX);
                Canvas.SetTop(selectedAnnotation, newY);
            }

            // Move all selected annotations together
            if (selectedAnnotations.Count > 1)
            {
                foreach (var ann in selectedAnnotations)
                {
                    if (ann != selectedAnnotation)
                    {
                        double annX = Canvas.GetLeft(ann) + dx;
                        double annY = Canvas.GetTop(ann) + dy;
                        Canvas.SetLeft(ann, annX);
                        Canvas.SetTop(ann, annY);
                    }
                }
                dragStart = pos;
            }
        }

        private void ChartCanvas_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (isSelecting)
            {
                // Select annotations within rectangle
                double x1 = Canvas.GetLeft(SelectionRect);
                double y1 = Canvas.GetTop(SelectionRect);
                double x2 = x1 + SelectionRect.Width;
                double y2 = y1 + SelectionRect.Height;

                foreach (var ann in annotations)
                {
                    double annX = Canvas.GetLeft(ann);
                    double annY = Canvas.GetTop(ann);

                    if (annX >= x1 && annX <= x2 && annY >= y1 && annY <= y2)
                    {
                        selectedAnnotations.Add(ann);
                        HighlightAnnotation(ann, true);
                    }
                }

                SelectionRect.Visibility = Visibility.Collapsed;
                isSelecting = false;
            }

            isDragging = false;
            isResizing = false;
            currentResizeHandle = "";
            currentLineCanvas = null;
            ChartCanvas.ReleaseMouseCapture();
        }

        #endregion

        #region Selection Helpers

        private void ClearSelection()
        {
            foreach (var ann in selectedAnnotations)
            {
                HighlightAnnotation(ann, false);
            }
            selectedAnnotations.Clear();

            if (selectedAnnotation != null)
            {
                HighlightAnnotation(selectedAnnotation, false);
                selectedAnnotation = null;
            }
        }

        private void HighlightAnnotation(FrameworkElement element, bool highlight)
        {
            if (element is Border border)
            {
                if (highlight)
                {
                    border.Tag = border.BorderBrush;
                    border.BorderBrush = new SolidColorBrush(Color.FromRgb(33, 150, 243));
                    border.BorderThickness = new Thickness(2);
                }
                else
                {
                    border.BorderBrush = border.Tag as Brush ?? Brushes.Transparent;
                    if (border.Child is TextBlock)
                    {
                        var fmt = border.DataContext as TextFormatInfo;
                        border.BorderThickness = fmt?.ShowBorder == true ? new Thickness(1) : new Thickness(0);
                    }
                    else
                    {
                        border.BorderThickness = new Thickness(0);
                    }
                }
            }
        }

        private FrameworkElement? FindAnnotationAt(Point pos)
        {
            foreach (var ann in annotations)
            {
                double left = Canvas.GetLeft(ann);
                double top = Canvas.GetTop(ann);
                double right = left + ann.ActualWidth;
                double bottom = top + ann.ActualHeight;

                if (ann is Border border && border.Child is Canvas canvas && canvas.Tag is LineShapeInfo info)
                {
                    if (info.Type == "Line" || info.Type == "Arrow")
                    {
                        Point p1 = new Point(left + info.StartX, top + info.StartY);
                        Point p2 = new Point(left + info.EndX, top + info.EndY);
                        double dist = DistanceToLineSegment(pos, p1, p2);
                        if (dist < 10) return ann;
                        continue;
                    }
                }

                if (pos.X >= left - 5 && pos.X <= right + 5 && pos.Y >= top - 5 && pos.Y <= bottom + 5)
                {
                    return ann;
                }
            }
            return null;
        }

        private double DistanceToLineSegment(Point p, Point p1, Point p2)
        {
            double dx = p2.X - p1.X;
            double dy = p2.Y - p1.Y;
            double lengthSquared = dx * dx + dy * dy;

            if (lengthSquared == 0) return Math.Sqrt((p.X - p1.X) * (p.X - p1.X) + (p.Y - p1.Y) * (p.Y - p1.Y));

            double t = Math.Max(0, Math.Min(1, ((p.X - p1.X) * dx + (p.Y - p1.Y) * dy) / lengthSquared));
            double projX = p1.X + t * dx;
            double projY = p1.Y + t * dy;

            return Math.Sqrt((p.X - projX) * (p.X - projX) + (p.Y - projY) * (p.Y - projY));
        }

        private void SelectAnnotation(FrameworkElement? element)
        {
            selectedAnnotation = element;
            if (element != null)
            {
                selectedAnnotations.Add(element);
                HighlightAnnotation(element, true);
            }
        }

        #endregion

        #region Clipboard Operations

        private void CopyToClipboard_Click(object sender, RoutedEventArgs e)
        {
            CopyChartToClipboard();
        }

        private void CopyChartToClipboard()
        {
            var renderBitmap = new RenderTargetBitmap(
                (int)ChartCanvas.ActualWidth, (int)ChartCanvas.ActualHeight,
                96, 96, PixelFormats.Pbgra32);

            renderBitmap.Render(ChartCanvas);

            Clipboard.SetImage(renderBitmap);
            MessageBox.Show("Chart copied to clipboard!", "Copied", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        #endregion

        #region Statistics

        private void OpenStatistics_Click(object sender, RoutedEventArgs e)
        {
            var statsWindow = new StatisticsWindow(dataSeries);
            statsWindow.Owner = this;
            statsWindow.Show();
        }

        #endregion

        #region Text Annotation

        private void AddTextBox_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new TextAnnotationDialog();
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                CreateTextAnnotation(dialog.AnnotationText, dialog.SelectedFontSize,
                    dialog.SelectedFontFamily, dialog.IsBold, dialog.IsItalic,
                    dialog.ShowBorder, dialog.TextColor);
            }
        }

        private void CreateTextAnnotation(string text, double fontSize, FontFamily fontFamily,
            bool isBold, bool isItalic, bool showBorder, Color textColor, double x = 100, double y = 100)
        {
            var textBlock = new TextBlock
            {
                Text = text,
                FontSize = fontSize,
                FontFamily = fontFamily,
                FontWeight = isBold ? FontWeights.Bold : FontWeights.Normal,
                FontStyle = isItalic ? FontStyles.Italic : FontStyles.Normal,
                Foreground = new SolidColorBrush(textColor),
                Padding = new Thickness(5),
                TextWrapping = TextWrapping.Wrap
            };

            var border = new Border
            {
                Child = textBlock,
                BorderThickness = showBorder ? new Thickness(1) : new Thickness(0),
                BorderBrush = showBorder ? Brushes.Black : Brushes.Transparent,
                Background = Brushes.Transparent,
                Cursor = Cursors.SizeAll,
                Tag = showBorder ? Brushes.Black : Brushes.Transparent
            };

            border.DataContext = new TextFormatInfo
            {
                FontSize = fontSize,
                FontFamily = fontFamily,
                IsBold = isBold,
                IsItalic = isItalic,
                ShowBorder = showBorder,
                TextColor = textColor
            };

            Canvas.SetLeft(border, x);
            Canvas.SetTop(border, y);
            ChartCanvas.Children.Add(border);
            annotations.Add(border);
        }

        private void EditTextAnnotation(Border border)
        {
            if (border.Child is not TextBlock textBlock) return;

            var format = border.DataContext as TextFormatInfo ?? new TextFormatInfo();

            var dialog = new TextAnnotationDialog(textBlock.Text, format);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                textBlock.Text = dialog.AnnotationText;
                textBlock.FontSize = dialog.SelectedFontSize;
                textBlock.FontFamily = dialog.SelectedFontFamily;
                textBlock.FontWeight = dialog.IsBold ? FontWeights.Bold : FontWeights.Normal;
                textBlock.FontStyle = dialog.IsItalic ? FontStyles.Italic : FontStyles.Normal;
                textBlock.Foreground = new SolidColorBrush(dialog.TextColor);

                border.BorderThickness = dialog.ShowBorder ? new Thickness(1) : new Thickness(0);
                border.BorderBrush = dialog.ShowBorder ? Brushes.Black : Brushes.Transparent;
                border.Tag = dialog.ShowBorder ? Brushes.Black : Brushes.Transparent;

                border.DataContext = new TextFormatInfo
                {
                    FontSize = dialog.SelectedFontSize,
                    FontFamily = dialog.SelectedFontFamily,
                    IsBold = dialog.IsBold,
                    IsItalic = dialog.IsItalic,
                    ShowBorder = dialog.ShowBorder,
                    TextColor = dialog.TextColor
                };
            }
        }

        private void OpenSymbolPicker_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new SymbolPickerDialog();
            dialog.Owner = this;
            if (dialog.ShowDialog() == true && !string.IsNullOrEmpty(dialog.SelectedSymbol))
            {
                CreateTextAnnotation(dialog.SelectedSymbol, 14, new FontFamily("Segoe UI"),
                    false, false, false, Colors.Black);
            }
        }

        #endregion

        #region Line Annotation

        private void AddLine_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button btn && btn.Tag is string lineType)
            {
                CreateLineAnnotation(lineType);
            }
        }

        private void EditLineAnnotation(Border border)
        {
            if (border.Child is not Canvas lineCanvas || lineCanvas.Tag is not LineShapeInfo info) return;

            var dialog = new LineSettingsDialog(info);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                info.Thickness = dialog.LineThickness;
                info.Stroke = new SolidColorBrush(dialog.LineColor);
                info.ArrowDirection = dialog.ArrowDirection;

                RedrawLineShape(lineCanvas, info);
                UpdateHandlePositions(lineCanvas);
            }
        }

        private void CreateLineAnnotation(string lineType)
        {
            var container = new Canvas { Background = Brushes.Transparent, Cursor = Cursors.SizeAll };

            var info = new LineShapeInfo
            {
                Type = lineType,
                Stroke = Brushes.Black,
                Thickness = 2,
                Width = 100,
                Height = 40,
                LeftHeight = 40,
                RightHeight = 40,
                ArrowDirection = "Right",
                StartX = 5,
                StartY = 10,
                EndX = 105,
                EndY = 10
            };

            switch (lineType)
            {
                case "Line":
                case "Arrow":
                    container.Width = 110;
                    container.Height = 20;
                    info.Height = 20;
                    break;
                case "UShape":
                case "HShape":
                    container.Width = 100;
                    container.Height = 40;
                    break;
            }

            container.Tag = info;
            RedrawLineShape(container, info);
            AddResizeHandles(container, lineType);

            var border = new Border
            {
                Child = container,
                BorderThickness = new Thickness(0),
                Background = Brushes.Transparent,
                Cursor = Cursors.SizeAll
            };

            Canvas.SetLeft(border, 150);
            Canvas.SetTop(border, 150);
            ChartCanvas.Children.Add(border);
            annotations.Add(border);
        }

        private void CreateLineFromInfo(LineShapeInfo info, double x, double y)
        {
            var container = new Canvas { Background = Brushes.Transparent, Cursor = Cursors.SizeAll };
            container.Width = info.Width + 10;
            container.Height = info.Height;

            var newInfo = CloneLineInfo(info);
            container.Tag = newInfo;
            RedrawLineShape(container, newInfo);
            AddResizeHandles(container, newInfo.Type);

            var border = new Border
            {
                Child = container,
                BorderThickness = new Thickness(0),
                Background = Brushes.Transparent,
                Cursor = Cursors.SizeAll
            };

            Canvas.SetLeft(border, x);
            Canvas.SetTop(border, y);
            ChartCanvas.Children.Add(border);
            annotations.Add(border);
        }

        private LineShapeInfo CloneLineInfo(LineShapeInfo info)
        {
            return new LineShapeInfo
            {
                Type = info.Type,
                Stroke = info.Stroke,
                Thickness = info.Thickness,
                Width = info.Width,
                Height = info.Height,
                LeftHeight = info.LeftHeight,
                RightHeight = info.RightHeight,
                ArrowDirection = info.ArrowDirection,
                StartX = info.StartX,
                StartY = info.StartY,
                EndX = info.EndX,
                EndY = info.EndY
            };
        }

        private void RedrawLineShape(Canvas container, LineShapeInfo info)
        {
            ClearShapeLines(container);

            switch (info.Type)
            {
                case "Line":
                    var line = new Line
                    {
                        X1 = info.StartX,
                        Y1 = info.StartY,
                        X2 = info.EndX,
                        Y2 = info.EndY,
                        Stroke = info.Stroke,
                        StrokeThickness = info.Thickness,
                        Tag = "ShapeLine"
                    };
                    container.Children.Add(line);
                    break;

                case "Arrow":
                    DrawArrowShape(container, info);
                    break;

                case "UShape":
                    DrawUShape(container, info);
                    break;

                case "HShape":
                    DrawHShape(container, info);
                    break;
            }
        }

        private void DrawArrowShape(Canvas container, LineShapeInfo info)
        {
            double dx = info.EndX - info.StartX;
            double dy = info.EndY - info.StartY;
            double length = Math.Sqrt(dx * dx + dy * dy);
            if (length == 0) length = 1;

            double ux = dx / length, uy = dy / length;
            double px = -uy, py = ux;
            double arrowSize = 10;
            string dir = info.ArrowDirection ?? "Right";

            double lsx = info.StartX, lsy = info.StartY, lex = info.EndX, ley = info.EndY;

            if (dir == "Left" || dir == "Both") { lsx += ux * arrowSize; lsy += uy * arrowSize; }
            if (dir == "Right" || dir == "Both") { lex -= ux * arrowSize; ley -= uy * arrowSize; }

            container.Children.Add(new Line
            {
                X1 = lsx,
                Y1 = lsy,
                X2 = lex,
                Y2 = ley,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });

            if (dir == "Right" || dir == "Both")
            {
                container.Children.Add(new Polygon
                {
                    Points = new PointCollection {
                        new Point(info.EndX - ux * arrowSize + px * arrowSize * 0.5, info.EndY - uy * arrowSize + py * arrowSize * 0.5),
                        new Point(info.EndX, info.EndY),
                        new Point(info.EndX - ux * arrowSize - px * arrowSize * 0.5, info.EndY - uy * arrowSize - py * arrowSize * 0.5)
                    },
                    Fill = info.Stroke,
                    Tag = "ShapeLine"
                });
            }

            if (dir == "Left" || dir == "Both")
            {
                container.Children.Add(new Polygon
                {
                    Points = new PointCollection {
                        new Point(info.StartX + ux * arrowSize + px * arrowSize * 0.5, info.StartY + uy * arrowSize + py * arrowSize * 0.5),
                        new Point(info.StartX, info.StartY),
                        new Point(info.StartX + ux * arrowSize - px * arrowSize * 0.5, info.StartY + uy * arrowSize - py * arrowSize * 0.5)
                    },
                    Fill = info.Stroke,
                    Tag = "ShapeLine"
                });
            }
        }

        private void DrawUShape(Canvas container, LineShapeInfo info)
        {
            container.Children.Add(new Line
            {
                X1 = 0,
                Y1 = 0,
                X2 = 0,
                Y2 = info.LeftHeight,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });
            container.Children.Add(new Line
            {
                X1 = 0,
                Y1 = 0,
                X2 = info.Width,
                Y2 = 0,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });
            container.Children.Add(new Line
            {
                X1 = info.Width,
                Y1 = 0,
                X2 = info.Width,
                Y2 = info.RightHeight,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });
        }

        private void DrawHShape(Canvas container, LineShapeInfo info)
        {
            double midY = info.Height / 2;
            container.Children.Add(new Line
            {
                X1 = 0,
                Y1 = midY - info.LeftHeight / 2,
                X2 = 0,
                Y2 = midY + info.LeftHeight / 2,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });
            container.Children.Add(new Line
            {
                X1 = 0,
                Y1 = midY,
                X2 = info.Width,
                Y2 = midY,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });
            container.Children.Add(new Line
            {
                X1 = info.Width,
                Y1 = midY - info.RightHeight / 2,
                X2 = info.Width,
                Y2 = midY + info.RightHeight / 2,
                Stroke = info.Stroke,
                StrokeThickness = info.Thickness,
                Tag = "ShapeLine"
            });
        }

        private void ClearShapeLines(Canvas container)
        {
            var toRemove = container.Children.OfType<FrameworkElement>().Where(c => c.Tag?.ToString() != "Handle").ToList();
            foreach (var item in toRemove) container.Children.Remove(item);
        }

        private void AddResizeHandles(Canvas container, string lineType)
        {
            var color = new SolidColorBrush(Color.FromRgb(33, 150, 243));

            switch (lineType)
            {
                case "Line":
                case "Arrow":
                    AddHandle(container, "Start", color, Cursors.Cross);
                    AddHandle(container, "End", color, Cursors.Cross);
                    break;
                case "UShape":
                    AddHandle(container, "LeftBottom", color, Cursors.SizeNS);
                    AddHandle(container, "RightBottom", color, Cursors.SizeNS);
                    AddHandle(container, "TopRight", color, Cursors.SizeWE);
                    break;
                case "HShape":
                    AddHandle(container, "LeftTop", color, Cursors.SizeNS);
                    AddHandle(container, "LeftBottom", color, Cursors.SizeNS);
                    AddHandle(container, "RightTop", color, Cursors.SizeNS);
                    AddHandle(container, "RightBottom", color, Cursors.SizeNS);
                    AddHandle(container, "RightMid", color, Cursors.SizeWE);
                    break;
            }
            UpdateHandlePositions(container);
        }

        private void AddHandle(Canvas container, string name, Brush color, Cursor cursor)
        {
            var handle = new Ellipse
            {
                Width = 10,
                Height = 10,
                Fill = color,
                Stroke = Brushes.White,
                StrokeThickness = 1,
                Cursor = cursor,
                Tag = "Handle"
            };
            handle.SetValue(FrameworkElement.NameProperty, name);
            handle.MouseLeftButtonDown += Handle_MouseDown;
            handle.MouseMove += Handle_MouseMove;
            handle.MouseLeftButtonUp += Handle_MouseUp;
            container.Children.Add(handle);
        }

        private void UpdateHandlePositions(Canvas container)
        {
            if (container.Tag is not LineShapeInfo info) return;

            foreach (var child in container.Children.OfType<Ellipse>())
            {
                if (child.Tag?.ToString() != "Handle") continue;
                string name = child.GetValue(FrameworkElement.NameProperty) as string ?? "";

                switch (name)
                {
                    case "Start": Canvas.SetLeft(child, info.StartX - 5); Canvas.SetTop(child, info.StartY - 5); break;
                    case "End": Canvas.SetLeft(child, info.EndX - 5); Canvas.SetTop(child, info.EndY - 5); break;
                    case "LeftBottom":
                        Canvas.SetLeft(child, -5);
                        Canvas.SetTop(child, info.Type == "UShape" ? info.LeftHeight - 5 : info.Height / 2 + info.LeftHeight / 2 - 5); break;
                    case "LeftTop": Canvas.SetLeft(child, -5); Canvas.SetTop(child, info.Height / 2 - info.LeftHeight / 2 - 5); break;
                    case "RightBottom":
                        Canvas.SetLeft(child, info.Width - 5);
                        Canvas.SetTop(child, info.Type == "UShape" ? info.RightHeight - 5 : info.Height / 2 + info.RightHeight / 2 - 5); break;
                    case "RightTop": Canvas.SetLeft(child, info.Width - 5); Canvas.SetTop(child, info.Height / 2 - info.RightHeight / 2 - 5); break;
                    case "TopRight": Canvas.SetLeft(child, info.Width - 5); Canvas.SetTop(child, -5); break;
                    case "RightMid": Canvas.SetLeft(child, info.Width - 5); Canvas.SetTop(child, info.Height / 2 - 5); break;
                }
            }
        }

        private void Handle_MouseDown(object sender, MouseButtonEventArgs e)
        {
            if (sender is Ellipse handle && handle.Parent is Canvas container)
            {
                isResizing = true;
                currentResizeHandle = handle.GetValue(FrameworkElement.NameProperty) as string ?? "";
                currentLineCanvas = container;
                dragStart = e.GetPosition(ChartCanvas);
                handle.CaptureMouse();
                e.Handled = true;
            }
        }

        private void Handle_MouseMove(object sender, MouseEventArgs e)
        {
            if (!isResizing || currentLineCanvas == null) return;
            if (currentLineCanvas.Tag is not LineShapeInfo info) return;

            var pos = e.GetPosition(ChartCanvas);
            var border = currentLineCanvas.Parent as Border;
            if (border == null) return;

            double containerLeft = Canvas.GetLeft(border);
            double containerTop = Canvas.GetTop(border);
            double localX = pos.X - containerLeft;
            double localY = pos.Y - containerTop;

            bool shiftPressed = Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift);

            if (currentResizeHandle == "Start" || currentResizeHandle == "End")
            {
                double anchorX = currentResizeHandle == "Start" ? info.EndX : info.StartX;
                double anchorY = currentResizeHandle == "Start" ? info.EndY : info.StartY;

                double targetX = localX, targetY = localY;

                if (shiftPressed)
                {
                    double dx = localX - anchorX, dy = localY - anchorY;
                    double length = Math.Sqrt(dx * dx + dy * dy);
                    if (length > 0)
                    {
                        double angle = Math.Atan2(dy, dx);
                        double snapped = Math.Round(angle / (Math.PI / 4)) * (Math.PI / 4);
                        targetX = anchorX + length * Math.Cos(snapped);
                        targetY = anchorY + length * Math.Sin(snapped);
                    }
                }

                if (currentResizeHandle == "Start") { info.StartX = targetX; info.StartY = targetY; }
                else { info.EndX = targetX; info.EndY = targetY; }

                double minX = Math.Min(info.StartX, info.EndX) - 15;
                double minY = Math.Min(info.StartY, info.EndY) - 15;

                if (minX < 0) { info.StartX -= minX; info.EndX -= minX; Canvas.SetLeft(border, containerLeft + minX); }
                if (minY < 0) { info.StartY -= minY; info.EndY -= minY; Canvas.SetTop(border, containerTop + minY); }

                currentLineCanvas.Width = Math.Max(info.StartX, info.EndX) + 15;
                currentLineCanvas.Height = Math.Max(info.StartY, info.EndY) + 15;
            }
            else
            {
                double dx = pos.X - dragStart.X, dy = pos.Y - dragStart.Y;

                switch (currentResizeHandle)
                {
                    case "TopRight": case "RightMid": info.Width = Math.Max(20, info.Width + dx); currentLineCanvas.Width = info.Width; break;
                    case "LeftBottom":
                        if (info.Type == "UShape") { info.LeftHeight = Math.Max(10, info.LeftHeight + dy); info.Height = Math.Max(info.LeftHeight, info.RightHeight); }
                        else info.LeftHeight = Math.Max(10, info.LeftHeight + dy * 2);
                        break;
                    case "LeftTop": info.LeftHeight = Math.Max(10, info.LeftHeight - dy * 2); break;
                    case "RightBottom":
                        if (info.Type == "UShape") { info.RightHeight = Math.Max(10, info.RightHeight + dy); info.Height = Math.Max(info.LeftHeight, info.RightHeight); }
                        else info.RightHeight = Math.Max(10, info.RightHeight + dy * 2);
                        break;
                    case "RightTop": info.RightHeight = Math.Max(10, info.RightHeight - dy * 2); break;
                }

                if (info.Type == "HShape") { info.Height = Math.Max(info.LeftHeight, info.RightHeight) + 10; currentLineCanvas.Height = info.Height; }
                if (info.Type == "UShape") currentLineCanvas.Height = info.Height;
                dragStart = pos;
            }

            RedrawLineShape(currentLineCanvas, info);
            UpdateHandlePositions(currentLineCanvas);
            e.Handled = true;
        }

        private void Handle_MouseUp(object sender, MouseButtonEventArgs e)
        {
            isResizing = false;
            currentResizeHandle = "";
            currentLineCanvas = null;
            if (sender is Ellipse handle) handle.ReleaseMouseCapture();
            e.Handled = true;
        }

        #endregion

        #region Delete

        private void DeleteSelected_Click(object sender, RoutedEventArgs e)
        {
            DeleteSelectedAnnotations();
        }

        #endregion

        #region Settings Dialog

        private void OpenSettingsDialog()
        {
            var dialog = new ChartSettingsWindow(dataSeries, chartTitle, xAxisTitle, yAxisTitle, chartType);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                chartTitle = dialog.ChartTitle;
                xAxisTitle = dialog.XAxisTitle;
                yAxisTitle = dialog.YAxisTitle;
                DrawChart();
            }
        }

        #endregion

        #region Chart Drawing

        private void DrawChart()
        {
            var savedAnnotations = annotations.ToList();
            var positions = savedAnnotations.Select(a => new Point(Canvas.GetLeft(a), Canvas.GetTop(a))).ToList();

            ChartCanvas.Children.Clear();
            LegendPanel.Children.Clear();
            chartDataPoints.Clear();

            if (dataSeries == null || dataSeries.Count == 0) return;

            double width = ChartCanvas.ActualWidth, height = ChartCanvas.ActualHeight;
            if (width < 100 || height < 100) return;

            double plotWidth = width - marginLeft - marginRight;
            double plotHeight = height - marginTop - marginBottom;

            double xMin = dataSeries.SelectMany(s => s.XValues).DefaultIfEmpty(0).Min();
            double xMax = dataSeries.SelectMany(s => s.XValues).DefaultIfEmpty(1).Max();
            double yMin = 0;
            double yMax = dataSeries.SelectMany(s => s.YValues).DefaultIfEmpty(1).Max();

            double xPad = (xMax - xMin) * 0.1, yPad = yMax * 0.1;
            if (xPad == 0) xPad = 1; if (yPad == 0) yPad = 1;
            xMin -= xPad; xMax += xPad; yMax += yPad;

            if (errorType != "None")
            {
                foreach (var s in dataSeries)
                {
                    for (int i = 0; i < s.YValues.Count; i++)
                    {
                        double err = 0;
                        if (errorType == "SD" && i < s.YErrors.Count)
                            err = s.YErrors[i];
                        else if (errorType == "SEM" && i < s.SEMValues.Count)
                            err = s.SEMValues[i];
                        else if (errorType == "95CI" && i < s.SEMValues.Count && i < s.NValues.Count)
                        {
                            double sem = s.SEMValues[i];
                            int n = s.NValues[i];
                            err = GetTCritical(n - 1) * sem;
                        }
                        yMax = Math.Max(yMax, s.YValues[i] + err);
                    }
                }
            }

            ChartCanvas.Children.Add(new Rectangle
            {
                Width = plotWidth,
                Height = plotHeight,
                Fill = Brushes.White,
                Stroke = new SolidColorBrush(Color.FromRgb(200, 200, 200)),
                StrokeThickness = 1
            });
            Canvas.SetLeft(ChartCanvas.Children[0], marginLeft);
            Canvas.SetTop(ChartCanvas.Children[0], marginTop);

            DrawGridLines(plotWidth, plotHeight);
            DrawAxes(plotWidth, plotHeight, xMin, xMax, yMin, yMax);

            foreach (var series in dataSeries)
                DrawSeries(series, plotWidth, plotHeight, xMin, xMax, yMin, yMax);

            DrawTitle();
            BuildLegend();

            for (int i = 0; i < savedAnnotations.Count; i++)
            {
                ChartCanvas.Children.Add(savedAnnotations[i]);
                Canvas.SetLeft(savedAnnotations[i], positions[i].X);
                Canvas.SetTop(savedAnnotations[i], positions[i].Y);
            }
            annotations = savedAnnotations;
        }

        private void DrawTitle()
        {
            double width = ChartCanvas.ActualWidth;
            string[] parts = chartTitle.Split('|');
            string main = parts[0].Trim();
            string sub = parts.Length > 1 ? parts[1].Trim() : "";

            if (!string.IsNullOrEmpty(main))
            {
                var t = new TextBlock { Text = main, FontSize = 16, FontWeight = FontWeights.Bold, Foreground = Brushes.Black };
                t.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(t, (width - t.DesiredSize.Width) / 2);
                Canvas.SetTop(t, 8);
                ChartCanvas.Children.Add(t);
            }

            if (!string.IsNullOrEmpty(sub))
            {
                var s = new TextBlock { Text = sub, FontSize = 12, Foreground = new SolidColorBrush(Color.FromRgb(100, 100, 100)) };
                s.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(s, (width - s.DesiredSize.Width) / 2);
                Canvas.SetTop(s, 28);
                ChartCanvas.Children.Add(s);
            }
        }

        private void DrawGridLines(double plotWidth, double plotHeight)
        {
            var brush = new SolidColorBrush(Color.FromRgb(240, 240, 240));
            for (int i = 0; i <= 5; i++)
            {
                double y = marginTop + plotHeight - (plotHeight * i / 5);
                ChartCanvas.Children.Add(new Line { X1 = marginLeft, Y1 = y, X2 = marginLeft + plotWidth, Y2 = y, Stroke = brush, StrokeThickness = 1 });
                double x = marginLeft + (plotWidth * i / 5);
                ChartCanvas.Children.Add(new Line { X1 = x, Y1 = marginTop, X2 = x, Y2 = marginTop + plotHeight, Stroke = brush, StrokeThickness = 1 });
            }
        }

        private void DrawAxes(double plotWidth, double plotHeight, double xMin, double xMax, double yMin, double yMax)
        {
            for (int i = 0; i <= 5; i++)
            {
                double yVal = yMin + (yMax - yMin) * i / 5;
                double y = marginTop + plotHeight - (plotHeight * i / 5);
                var lbl = new TextBlock { Text = yVal.ToString("F1"), FontSize = 10, Foreground = Brushes.Black };
                lbl.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(lbl, marginLeft - lbl.DesiredSize.Width - 5);
                Canvas.SetTop(lbl, y - lbl.DesiredSize.Height / 2);
                ChartCanvas.Children.Add(lbl);

                double xVal = xMin + (xMax - xMin) * i / 5;
                double x = marginLeft + (plotWidth * i / 5);
                var xlbl = new TextBlock { Text = xVal.ToString("F1"), FontSize = 10, Foreground = Brushes.Black };
                xlbl.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(xlbl, x - xlbl.DesiredSize.Width / 2);
                Canvas.SetTop(xlbl, marginTop + plotHeight + 5);
                ChartCanvas.Children.Add(xlbl);
            }

            var xt = new TextBlock { Text = xAxisTitle, FontSize = 12, FontWeight = FontWeights.SemiBold, Foreground = Brushes.Black };
            xt.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            Canvas.SetLeft(xt, marginLeft + (plotWidth - xt.DesiredSize.Width) / 2);
            Canvas.SetTop(xt, marginTop + plotHeight + 25);
            ChartCanvas.Children.Add(xt);

            var yt = new TextBlock
            {
                Text = yAxisTitle,
                FontSize = 12,
                FontWeight = FontWeights.SemiBold,
                Foreground = Brushes.Black,
                RenderTransform = new RotateTransform(-90)
            };
            yt.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            Canvas.SetLeft(yt, 10);
            Canvas.SetTop(yt, marginTop + (plotHeight + yt.DesiredSize.Width) / 2);
            ChartCanvas.Children.Add(yt);
        }

        private void DrawSeries(ChartDataSeries series, double plotWidth, double plotHeight, double xMin, double xMax, double yMin, double yMax)
        {
            if (series.XValues.Count == 0 || series.YValues.Count == 0) return;

            var brush = new SolidColorBrush(series.LineColor);
            var points = new List<Point>();

            for (int i = 0; i < series.XValues.Count && i < series.YValues.Count; i++)
            {
                double x = marginLeft + ((series.XValues[i] - xMin) / (xMax - xMin)) * plotWidth;
                double y = marginTop + plotHeight - ((series.YValues[i] - yMin) / (yMax - yMin)) * plotHeight;
                points.Add(new Point(x, y));
                chartDataPoints.Add(new Point(x, y)); // Store for alignment
            }

            if (chartType == "Line" && points.Count > 1)
            {
                for (int i = 0; i < points.Count - 1; i++)
                    ChartCanvas.Children.Add(new Line
                    {
                        X1 = points[i].X,
                        Y1 = points[i].Y,
                        X2 = points[i + 1].X,
                        Y2 = points[i + 1].Y,
                        Stroke = brush,
                        StrokeThickness = series.LineThickness
                    });
            }

            if (errorType != "None")
            {
                for (int i = 0; i < points.Count; i++)
                {
                    double err = GetErrorValue(series, i, yMax - yMin, plotHeight);
                    if (err > 0)
                        DrawErrorBar(points[i], err, brush);
                }
            }

            foreach (var pt in points) DrawMarker(pt, series.MarkerSize, series.MarkerShape, brush);
        }

        private void DrawErrorBar(Point c, double err, Brush brush)
        {
            ChartCanvas.Children.Add(new Line { X1 = c.X, Y1 = c.Y - err, X2 = c.X, Y2 = c.Y + err, Stroke = brush, StrokeThickness = 1 });
            ChartCanvas.Children.Add(new Line { X1 = c.X - 4, Y1 = c.Y - err, X2 = c.X + 4, Y2 = c.Y - err, Stroke = brush, StrokeThickness = 1 });
            ChartCanvas.Children.Add(new Line { X1 = c.X - 4, Y1 = c.Y + err, X2 = c.X + 4, Y2 = c.Y + err, Stroke = brush, StrokeThickness = 1 });
        }

        private double GetErrorValue(ChartDataSeries series, int index, double yRange, double plotHeight)
        {
            double errValue = 0;

            if (errorType == "SD" && index < series.YErrors.Count)
            {
                errValue = series.YErrors[index];
            }
            else if (errorType == "SEM" && index < series.SEMValues.Count)
            {
                errValue = series.SEMValues[index];
            }
            else if (errorType == "95CI" && index < series.SEMValues.Count && index < series.NValues.Count)
            {
                double sem = series.SEMValues[index];
                int n = series.NValues[index];
                double tCrit = GetTCritical(n - 1);
                errValue = tCrit * sem;
            }

            return (errValue / yRange) * plotHeight;
        }

        private double GetTCritical(int df)
        {
            if (df <= 0) return 1.96;
            if (df == 1) return 12.706;
            if (df == 2) return 4.303;
            if (df == 3) return 3.182;
            if (df == 4) return 2.776;
            if (df == 5) return 2.571;
            if (df <= 10) return 2.228;
            if (df <= 20) return 2.086;
            if (df <= 30) return 2.042;
            return 1.96;
        }

        private void DrawMarker(Point c, int size, string shape, Brush brush)
        {
            Shape marker;
            switch (shape)
            {
                case "Square":
                    marker = new Rectangle { Width = size, Height = size, Fill = brush };
                    Canvas.SetLeft(marker, c.X - size / 2); Canvas.SetTop(marker, c.Y - size / 2);
                    break;
                case "Triangle":
                    ChartCanvas.Children.Add(new Polygon
                    {
                        Points = new PointCollection {
                        new Point(c.X, c.Y - size / 2), new Point(c.X - size / 2, c.Y + size / 2), new Point(c.X + size / 2, c.Y + size / 2)
                    },
                        Fill = brush
                    });
                    return;
                case "Diamond":
                    ChartCanvas.Children.Add(new Polygon
                    {
                        Points = new PointCollection {
                        new Point(c.X, c.Y - size / 2), new Point(c.X + size / 2, c.Y),
                        new Point(c.X, c.Y + size / 2), new Point(c.X - size / 2, c.Y)
                    },
                        Fill = brush
                    });
                    return;
                default:
                    marker = new Ellipse { Width = size, Height = size, Fill = brush };
                    Canvas.SetLeft(marker, c.X - size / 2); Canvas.SetTop(marker, c.Y - size / 2);
                    break;
            }
            ChartCanvas.Children.Add(marker);
        }

        private void BuildLegend()
        {
            foreach (var s in dataSeries)
            {
                var sp = new StackPanel { Orientation = Orientation.Horizontal, Margin = new Thickness(10, 5, 10, 5) };
                sp.Children.Add(new Rectangle { Width = 16, Height = 16, Fill = new SolidColorBrush(s.LineColor), Margin = new Thickness(0, 0, 5, 0) });
                sp.Children.Add(new TextBlock { Text = s.Name, VerticalAlignment = VerticalAlignment.Center });
                LegendPanel.Children.Add(sp);
            }
        }

        #endregion

        #region Save

        private void SaveAsPng_Click(object sender, RoutedEventArgs e)
        {
            var dlg = new SaveFileDialog { Filter = "PNG Image|*.png", FileName = "chart.png" };
            if (dlg.ShowDialog() == true)
            {
                var bmp = new RenderTargetBitmap((int)ChartCanvas.ActualWidth, (int)ChartCanvas.ActualHeight, 96, 96, PixelFormats.Pbgra32);
                bmp.Render(ChartCanvas);
                var enc = new PngBitmapEncoder();
                enc.Frames.Add(BitmapFrame.Create(bmp));
                using (var s = File.Create(dlg.FileName)) enc.Save(s);
                MessageBox.Show("Saved!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        private void SaveAsSvg_Click(object sender, RoutedEventArgs e)
        {
            var dlg = new SaveFileDialog { Filter = "SVG File|*.svg", FileName = "chart.svg" };
            if (dlg.ShowDialog() == true)
            {
                using (var w = new StreamWriter(dlg.FileName))
                {
                    w.WriteLine($"<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"{ChartCanvas.ActualWidth}\" height=\"{ChartCanvas.ActualHeight}\">");
                    w.WriteLine("<rect width=\"100%\" height=\"100%\" fill=\"white\"/>");
                    foreach (var c in ChartCanvas.Children)
                    {
                        if (c is Line l)
                        {
                            var col = (l.Stroke as SolidColorBrush)?.Color ?? Colors.Black;
                            w.WriteLine($"<line x1=\"{l.X1}\" y1=\"{l.Y1}\" x2=\"{l.X2}\" y2=\"{l.Y2}\" stroke=\"#{col.R:X2}{col.G:X2}{col.B:X2}\" stroke-width=\"{l.StrokeThickness}\"/>");
                        }
                        else if (c is Ellipse el && el.Tag?.ToString() != "Handle")
                        {
                            var col = (el.Fill as SolidColorBrush)?.Color ?? Colors.Black;
                            double cx = Canvas.GetLeft(el) + el.Width / 2, cy = Canvas.GetTop(el) + el.Height / 2;
                            w.WriteLine($"<circle cx=\"{cx}\" cy=\"{cy}\" r=\"{el.Width / 2}\" fill=\"#{col.R:X2}{col.G:X2}{col.B:X2}\"/>");
                        }
                    }
                    w.WriteLine("</svg>");
                }
                MessageBox.Show("Saved!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        #endregion
    }

    #region Helper Classes

    public class TextFormatInfo
    {
        public double FontSize { get; set; } = 12;
        public FontFamily FontFamily { get; set; } = new FontFamily("Segoe UI");
        public bool IsBold { get; set; } = false;
        public bool IsItalic { get; set; } = false;
        public bool ShowBorder { get; set; } = false;
        public Color TextColor { get; set; } = Colors.Black;
    }

    public class LineShapeInfo
    {
        public string Type { get; set; } = "Line";
        public Brush Stroke { get; set; } = Brushes.Black;
        public double Thickness { get; set; } = 2;
        public double Width { get; set; } = 100;
        public double Height { get; set; } = 40;
        public double LeftHeight { get; set; } = 40;
        public double RightHeight { get; set; } = 40;
        public string ArrowDirection { get; set; } = "Right";
        public double StartX { get; set; } = 0;
        public double StartY { get; set; } = 5;
        public double EndX { get; set; } = 100;
        public double EndY { get; set; } = 5;
    }

    public class AnnotationClipboardItem
    {
        public string Type { get; set; } = "";
        public string? Text { get; set; }
        public TextFormatInfo? FormatInfo { get; set; }
        public LineShapeInfo? LineInfo { get; set; }
        public double Left { get; set; }
        public double Top { get; set; }
    }

    #endregion
}

==================================================
FILE_NAME: ColorPickerDialog.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\ColorPickerDialog.xaml
==================================================
<Window x:Class="BioSAK.ColorPickerDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Choose Color" 
        Height="350" Width="400"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Select a Color" FontSize="16" FontWeight="Bold" Margin="0,0,0,15"/>

        <!-- Color Palette -->
        <Border Grid.Row="1" BorderBrush="#DDD" BorderThickness="1" CornerRadius="5" Padding="10">
            <WrapPanel x:Name="ColorPalette"/>
        </Border>

        <!-- Custom Color -->
        <GroupBox Grid.Row="2" Header="Custom Color (RGB)" Margin="0,15,0,0" Padding="10">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="80"/>
                </Grid.ColumnDefinitions>

                <StackPanel Grid.Column="0" Margin="0,0,5,0">
                    <TextBlock Text="R:" FontSize="11"/>
                    <TextBox x:Name="RedBox" Text="0" TextChanged="RGB_Changed"/>
                </StackPanel>
                <StackPanel Grid.Column="1" Margin="0,0,5,0">
                    <TextBlock Text="G:" FontSize="11"/>
                    <TextBox x:Name="GreenBox" Text="0" TextChanged="RGB_Changed"/>
                </StackPanel>
                <StackPanel Grid.Column="2" Margin="0,0,5,0">
                    <TextBlock Text="B:" FontSize="11"/>
                    <TextBox x:Name="BlueBox" Text="0" TextChanged="RGB_Changed"/>
                </StackPanel>
                <Border Grid.Column="3" x:Name="PreviewBox" Background="Black" 
                        CornerRadius="5" BorderBrush="#CCC" BorderThickness="1"/>
            </Grid>
        </GroupBox>

        <!-- Buttons -->
        <StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
            <Button Content="Cancel" Width="80" Padding="5,8" Margin="0,0,10,0"
                    Background="#EEE" BorderThickness="0" Cursor="Hand"
                    Click="Cancel_Click"/>
            <Button Content="OK" Width="80" Padding="5,8"
                    Background="#4FC3F7" Foreground="White" BorderThickness="0" Cursor="Hand"
                    Click="OK_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: ColorPickerDialog.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\ColorPickerDialog.xaml.cs
==================================================
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;

namespace BioSAK
{
    public partial class ColorPickerDialog : Window
    {
        public Color SelectedColor { get; private set; }

        private readonly Color[] paletteColors = new Color[]
        {
            // Row 1 - Reds
            Color.FromRgb(244, 67, 54),
            Color.FromRgb(233, 30, 99),
            Color.FromRgb(156, 39, 176),
            Color.FromRgb(103, 58, 183),
            Color.FromRgb(63, 81, 181),
            Color.FromRgb(33, 150, 243),
            Color.FromRgb(3, 169, 244),
            Color.FromRgb(0, 188, 212),

            // Row 2 - Greens/Yellows
            Color.FromRgb(0, 150, 136),
            Color.FromRgb(76, 175, 80),
            Color.FromRgb(139, 195, 74),
            Color.FromRgb(205, 220, 57),
            Color.FromRgb(255, 235, 59),
            Color.FromRgb(255, 193, 7),
            Color.FromRgb(255, 152, 0),
            Color.FromRgb(255, 87, 34),

            // Row 3 - Browns/Grays
            Color.FromRgb(121, 85, 72),
            Color.FromRgb(158, 158, 158),
            Color.FromRgb(96, 125, 139),
            Color.FromRgb(0, 0, 0),
            Color.FromRgb(66, 66, 66),
            Color.FromRgb(117, 117, 117),
            Color.FromRgb(189, 189, 189),
            Color.FromRgb(255, 255, 255),

            // Row 4 - Dark variants
            Color.FromRgb(183, 28, 28),
            Color.FromRgb(136, 14, 79),
            Color.FromRgb(74, 20, 140),
            Color.FromRgb(49, 27, 146),
            Color.FromRgb(26, 35, 126),
            Color.FromRgb(13, 71, 161),
            Color.FromRgb(1, 87, 155),
            Color.FromRgb(0, 96, 100),

            // Row 5 - Light variants
            Color.FromRgb(255, 205, 210),
            Color.FromRgb(248, 187, 208),
            Color.FromRgb(225, 190, 231),
            Color.FromRgb(209, 196, 233),
            Color.FromRgb(197, 202, 233),
            Color.FromRgb(187, 222, 251),
            Color.FromRgb(179, 229, 252),
            Color.FromRgb(178, 235, 242),
        };

        public ColorPickerDialog(Color initialColor)
        {
            InitializeComponent();

            SelectedColor = initialColor;
            RedBox.Text = initialColor.R.ToString();
            GreenBox.Text = initialColor.G.ToString();
            BlueBox.Text = initialColor.B.ToString();
            PreviewBox.Background = new SolidColorBrush(initialColor);

            BuildPalette();
        }

        private void BuildPalette()
        {
            foreach (var color in paletteColors)
            {
                var rect = new Rectangle
                {
                    Width = 32,
                    Height = 32,
                    Fill = new SolidColorBrush(color),
                    Margin = new Thickness(2),
                    Cursor = Cursors.Hand,
                    Stroke = new SolidColorBrush(Color.FromRgb(200, 200, 200)),
                    StrokeThickness = 1,
                    RadiusX = 3,
                    RadiusY = 3,
                    Tag = color
                };

                rect.MouseLeftButtonDown += ColorRect_Click;
                ColorPalette.Children.Add(rect);
            }
        }

        private void ColorRect_Click(object sender, MouseButtonEventArgs e)
        {
            if (sender is Rectangle rect && rect.Tag is Color color)
            {
                SelectedColor = color;
                RedBox.Text = color.R.ToString();
                GreenBox.Text = color.G.ToString();
                BlueBox.Text = color.B.ToString();
                PreviewBox.Background = new SolidColorBrush(color);
            }
        }

        private void RGB_Changed(object sender, TextChangedEventArgs e)
        {
            if (RedBox == null || GreenBox == null || BlueBox == null || PreviewBox == null) return;

            if (byte.TryParse(RedBox.Text, out byte r) &&
                byte.TryParse(GreenBox.Text, out byte g) &&
                byte.TryParse(BlueBox.Text, out byte b))
            {
                SelectedColor = Color.FromRgb(r, g, b);
                PreviewBox.Background = new SolidColorBrush(SelectedColor);
            }
        }

        private void OK_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = true;
            Close();
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}


==================================================
FILE_NAME: ErrorBarDialog.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\ErrorBarDialog.xaml
==================================================
<Window x:Class="BioSAK.ErrorBarDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Select Error Bar Type" 
        Height="450" Width="400"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">
    
    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Select Error Bar Type" FontSize="16" FontWeight="SemiBold" 
                   Foreground="#333" Margin="0,0,0,15"/>

        <!-- Error Bar Type -->
        <GroupBox Grid.Row="1" Header="Error Type" Padding="10" Margin="0,0,0,10">
            <StackPanel>
                <RadioButton x:Name="NoErrorBar" GroupName="ErrorType" Content="None" 
                             Margin="0,3" FontSize="12" IsChecked="True"/>
                <RadioButton x:Name="SDErrorBar" GroupName="ErrorType" Margin="0,3" FontSize="12">
                    <StackPanel Orientation="Horizontal">
                        <TextBlock Text="Standard Deviation (SD)" FontWeight="SemiBold"/>
                        <TextBlock Text=" - data spread" Foreground="#666"/>
                    </StackPanel>
                </RadioButton>
                <RadioButton x:Name="SEMErrorBar" GroupName="ErrorType" Margin="0,3" FontSize="12">
                    <StackPanel Orientation="Horizontal">
                        <TextBlock Text="Standard Error of Mean (SEM)" FontWeight="SemiBold"/>
                        <TextBlock Text=" - precision" Foreground="#666"/>
                    </StackPanel>
                </RadioButton>
                <RadioButton x:Name="CI95ErrorBar" GroupName="ErrorType" Margin="0,3" FontSize="12">
                    <StackPanel Orientation="Horizontal">
                        <TextBlock Text="95% Confidence Interval (95% CI)" FontWeight="SemiBold"/>
                    </StackPanel>
                </RadioButton>
            </StackPanel>
        </GroupBox>

        <!-- Error Bar Direction -->
        <GroupBox Grid.Row="2" Header="Error Bar Direction" Padding="10" Margin="0,0,0,10">
            <StackPanel>
                <RadioButton x:Name="DirectionBoth" GroupName="Direction" Content="Both" 
                             Margin="0,3" FontSize="12" IsChecked="True"/>
                <RadioButton x:Name="DirectionUp" GroupName="Direction" Content="Upper only" 
                             Margin="0,3" FontSize="12"/>
                <RadioButton x:Name="DirectionDown" GroupName="Direction" Content="Lower only" 
                             Margin="0,3" FontSize="12"/>
            </StackPanel>
        </GroupBox>

        <!-- Note -->
        <TextBlock Grid.Row="3" Text="Tip: You can change direction for individual bars by right-clicking on them." 
                   Foreground="#888" FontSize="11" TextWrapping="Wrap" Margin="0,5"/>

        <StackPanel Grid.Row="4" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
            <Button Content="Cancel" Width="80" Padding="5,8" Margin="0,0,10,0"
                    Background="#9E9E9E" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="Cancel_Click"/>
            <Button Content="OK" Width="80" Padding="5,8"
                    Background="#4CAF50" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="OK_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: ErrorBarDialog.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\ErrorBarDialog.xaml.cs
==================================================
using System.Windows;

namespace BioSAK
{
    public partial class ErrorBarDialog : Window
    {
        public string SelectedErrorType { get; private set; } = "None";
        public string SelectedDirection { get; private set; } = "Both"; // Both, Up, Down

        public ErrorBarDialog()
        {
            InitializeComponent();
        }

        private void OK_Click(object sender, RoutedEventArgs e)
        {
            if (SDErrorBar.IsChecked == true)
                SelectedErrorType = "SD";
            else if (SEMErrorBar.IsChecked == true)
                SelectedErrorType = "SEM";
            else if (CI95ErrorBar.IsChecked == true)
                SelectedErrorType = "95CI";
            else
                SelectedErrorType = "None";

            // Get direction
            if (DirectionUp.IsChecked == true)
                SelectedDirection = "Up";
            else if (DirectionDown.IsChecked == true)
                SelectedDirection = "Down";
            else
                SelectedDirection = "Both";

            DialogResult = true;
            Close();
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}


==================================================
FILE_NAME: GraphGen.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\GraphGen.xaml
==================================================
<Page x:Class="BioSAK.GraphGen"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      Background="#F5F5F5">

    <Page.Resources>
        <Style x:Key="DataGridStyle" TargetType="DataGrid">
            <Setter Property="AutoGenerateColumns" Value="False"/>
            <Setter Property="CanUserAddRows" Value="False"/>
            <Setter Property="CanUserDeleteRows" Value="False"/>
            <Setter Property="GridLinesVisibility" Value="All"/>
            <Setter Property="HorizontalGridLinesBrush" Value="#E0E0E0"/>
            <Setter Property="VerticalGridLinesBrush" Value="#E0E0E0"/>
            <Setter Property="Background" Value="White"/>
            <Setter Property="RowBackground" Value="White"/>
            <Setter Property="AlternatingRowBackground" Value="#FAFAFA"/>
            <Setter Property="HeadersVisibility" Value="Column"/>
            <Setter Property="SelectionMode" Value="Extended"/>
            <Setter Property="SelectionUnit" Value="Cell"/>
        </Style>
    </Page.Resources>

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Title -->
        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,15">
            <TextBlock Text="?? Graph Generator" FontSize="24" FontWeight="Bold" Foreground="#333"/>
            <Button Content="??Back to Selection" Margin="20,0,0,0" Padding="10,5"
                    Background="Transparent" BorderThickness="0" Foreground="#4FC3F7"
                    Cursor="Hand" Click="BackToSelection_Click"/>
        </StackPanel>

        <!-- Settings Panel -->
        <Border Grid.Row="1" Background="White" CornerRadius="10" Padding="15" Margin="0,0,0,15">
            <Border.Effect>
                <DropShadowEffect ShadowDepth="1" BlurRadius="10" Opacity="0.1"/>
            </Border.Effect>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- X Column Settings -->
                <StackPanel Grid.Column="0" Margin="0,0,30,0">
                    <TextBlock Text="X Column" FontWeight="SemiBold" Foreground="#333" Margin="0,0,0,8"/>
                    <StackPanel Orientation="Horizontal">
                        <RadioButton x:Name="XNoRepeat" Content="Single" IsChecked="True" Margin="0,0,10,0"
                                     Checked="XRepeatChanged"/>
                        <RadioButton x:Name="XHasRepeat" Content="Replicates:" Margin="0,0,5,0"
                                     Checked="XRepeatChanged"/>
                        <TextBox x:Name="XRepeatCount" Text="3" Width="40" IsEnabled="False"
                                 VerticalContentAlignment="Center"/>
                    </StackPanel>
                </StackPanel>

                <!-- Y Column Settings -->
                <StackPanel Grid.Column="1" Margin="0,0,30,0">
                    <TextBlock Text="Y Columns" FontWeight="SemiBold" Foreground="#333" Margin="0,0,0,8"/>
                    <StackPanel Orientation="Horizontal">
                        <TextBlock Text="Number:" VerticalAlignment="Center" Margin="0,0,5,0"/>
                        <TextBox x:Name="YColumnCount" Text="3" Width="40" VerticalContentAlignment="Center"/>
                    </StackPanel>
                </StackPanel>

                <!-- Y Data Mode -->
                <StackPanel Grid.Column="2" Margin="0,0,30,0">
                    <TextBlock Text="Y Data Mode" FontWeight="SemiBold" Foreground="#333" Margin="0,0,0,8"/>
                    <StackPanel Orientation="Horizontal">
                        <ComboBox x:Name="YDataMode" Width="150" SelectedIndex="0" SelectionChanged="YDataModeChanged">
                            <ComboBoxItem Content="Single Value"/>
                            <ComboBoxItem Content="Enter Replicates"/>
                            <ComboBoxItem Content="Mean/SD/N"/>
                        </ComboBox>
                        <TextBox x:Name="YRepeatCount" Text="3" Width="40" Margin="5,0,0,0" 
                                 IsEnabled="False" VerticalContentAlignment="Center"/>
                    </StackPanel>
                </StackPanel>

                <!-- Apply Button -->
                <Button Grid.Column="3" Content="Apply Settings" HorizontalAlignment="Left"
                        Padding="15,8" Background="#4CAF50" Foreground="White" BorderThickness="0"
                        Cursor="Hand" Click="ApplySettings_Click"/>
            </Grid>
        </Border>

        <!-- Data Grid Section -->
        <Border Grid.Row="2" Background="White" CornerRadius="10" Padding="10">
            <Border.Effect>
                <DropShadowEffect ShadowDepth="1" BlurRadius="10" Opacity="0.1"/>
            </Border.Effect>
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <!-- Column Headers -->
                <ScrollViewer Grid.Row="0" x:Name="HeaderScrollViewer" 
                              HorizontalScrollBarVisibility="Hidden" VerticalScrollBarVisibility="Disabled">
                    <StackPanel x:Name="ColumnHeadersPanel" Orientation="Horizontal" Margin="0,0,0,5"/>
                </ScrollViewer>

                <!-- Data Grid -->
                <DataGrid Grid.Row="1" x:Name="DataGridMain" Style="{StaticResource DataGridStyle}"
                          SelectionUnit="Cell" SelectionMode="Extended"
                          PreviewKeyDown="DataGrid_PreviewKeyDown"
                          ScrollViewer.ScrollChanged="DataGrid_ScrollChanged"
                          ClipboardCopyMode="IncludeHeader">
                    <DataGrid.ContextMenu>
                        <ContextMenu>
                            <MenuItem Header="Copy" Click="ContextCopy_Click" InputGestureText="Ctrl+C">
                                <MenuItem.Icon>
                                    <TextBlock Text="??" FontSize="14"/>
                                </MenuItem.Icon>
                            </MenuItem>
                            <MenuItem Header="Paste" Click="ContextPaste_Click" InputGestureText="Ctrl+V">
                                <MenuItem.Icon>
                                    <TextBlock Text="??" FontSize="14"/>
                                </MenuItem.Icon>
                            </MenuItem>
                            <MenuItem Header="Paste Transposed" Click="ContextPasteTransposed_Click">
                                <MenuItem.Icon>
                                    <TextBlock Text="??" FontSize="14"/>
                                </MenuItem.Icon>
                            </MenuItem>
                            <Separator/>
                            <MenuItem Header="Delete" Click="ContextDelete_Click" InputGestureText="Del">
                                <MenuItem.Icon>
                                    <TextBlock Text="??" FontSize="14"/>
                                </MenuItem.Icon>
                            </MenuItem>
                            <Separator/>
                            <MenuItem Header="Select All" Click="ContextSelectAll_Click" InputGestureText="Ctrl+A"/>
                        </ContextMenu>
                    </DataGrid.ContextMenu>
                </DataGrid>
            </Grid>
        </Border>

        <!-- Bottom Buttons -->
        <Border Grid.Row="3" Margin="0,15,0,0">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <StackPanel Grid.Column="0" Orientation="Horizontal">
                    <Button Content="?? Clear All" Padding="12,10" Margin="0,0,5,0"
                            Background="#F44336" Foreground="White" BorderThickness="0"
                            Cursor="Hand" Click="ClearAll_Click"/>
                    <Button Content="??Sort Asc" Padding="12,10" Margin="0,0,5,0"
                            Background="#9E9E9E" Foreground="White" BorderThickness="0"
                            Cursor="Hand" Click="SortXAscending_Click"/>
                    <Button Content="??Sort Desc" Padding="12,10" Margin="0,0,5,0"
                            Background="#757575" Foreground="White" BorderThickness="0"
                            Cursor="Hand" Click="SortXDescending_Click"/>
                    <Button Content="?? Import Clipboard" Padding="12,10" Margin="0,0,5,0"
                            Background="#FF9800" Foreground="White" BorderThickness="0"
                            Cursor="Hand" Click="ImportClipboard_Click"/>
                </StackPanel>

                <StackPanel Grid.Column="1" Orientation="Horizontal">
                    <Button Content="?? Line" Padding="12,10" Margin="0,0,5,0"
                            Background="#4CAF50" Foreground="White" BorderThickness="0"
                            Cursor="Hand" Click="GenerateLineChart_Click" ToolTip="Line Chart"/>
                    <Button Content="??Scatter" Padding="12,10" Margin="0,0,5,0"
                            Background="#2196F3" Foreground="White" BorderThickness="0"
                            Cursor="Hand" Click="GenerateScatterPlot_Click" ToolTip="Scatter Plot"/>
                    <Button Content="?? Volcano" Padding="12,10" Margin="0,0,5,0"
                            Background="#9C27B0" Foreground="White" BorderThickness="0"
                            Cursor="Hand" Click="GenerateVolcanoPlot_Click" ToolTip="Volcano Plot"/>
                    <Button Content="?? Column" Padding="12,10" Margin="0,0,5,0"
                            Background="#FF5722" Foreground="White" BorderThickness="0"
                            Cursor="Hand" Click="GenerateColumnChart_Click" ToolTip="Column Chart"/>
                    <Button Content="?? Multi Factors" Padding="12,10"
                            Background="#795548" Foreground="White" BorderThickness="0"
                            Cursor="Hand" Click="GenerateMultiGroupChart_Click" ToolTip="Multi Factors Bar Chart"/>
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</Page>


==================================================
FILE_NAME: GraphGen.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\GraphGen.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;

namespace BioSAK
{
    public partial class GraphGen : Page
    {
        private DataTable dataTable = new DataTable();
        private int currentYColumns = 3;
        private int currentYReplicates = 1;
        private int currentXReplicates = 1;
        private int currentDataMode = 0;
        private string currentChartType = ""; // Track current chart type
        private List<TextBox> columnTitleBoxes = new List<TextBox>();

        private const int DEFAULT_ROWS = 50;

        public GraphGen()
        {
            InitializeComponent();
            InitializeDataGrid();
        }

        private void InitializeDataGrid()
        {
            ApplySettings_Click(null, null);
        }

        private void BackToSelection_Click(object sender, RoutedEventArgs e)
        {
            var selector = new GraphTypeSelector();
            selector.Owner = Window.GetWindow(this);
            selector.ShowDialog();
        }

        private void XRepeatChanged(object sender, RoutedEventArgs e)
        {
            if (XRepeatCount != null)
                XRepeatCount.IsEnabled = XHasRepeat.IsChecked == true;
        }

        private void YDataModeChanged(object sender, SelectionChangedEventArgs e)
        {
            if (YRepeatCount != null && YDataMode != null)
                YRepeatCount.IsEnabled = YDataMode.SelectedIndex == 1;
        }

        /// <summary>
        /// Set Y Data Mode programmatically (0=Single Value, 1=Enter Replicates, 2=Mean/SD/N)
        /// </summary>
        public void SetYDataMode(int mode)
        {
            if (YDataMode != null)
            {
                YDataMode.SelectedIndex = mode;
                if (YRepeatCount != null)
                    YRepeatCount.IsEnabled = mode == 1;
                ApplySettings_Click(null, null);
            }
        }

        /// <summary>
        /// Set chart type to control X column behavior
        /// </summary>
        public void SetChartType(string chartType)
        {
            currentChartType = chartType;
            
            // For Column chart, disable X input section
            if (chartType == "Column")
            {
                // Disable X column settings
                if (XNoRepeat != null) XNoRepeat.IsEnabled = false;
                if (XHasRepeat != null) XHasRepeat.IsEnabled = false;
                if (XRepeatCount != null) XRepeatCount.IsEnabled = false;
            }
            
            ApplySettings_Click(null, null);
        }

        private void ApplySettings_Click(object? sender, RoutedEventArgs? e)
        {
            if (!int.TryParse(YColumnCount.Text, out currentYColumns) || currentYColumns < 1) currentYColumns = 3;
            if (!int.TryParse(YRepeatCount.Text, out currentYReplicates) || currentYReplicates < 1) currentYReplicates = 1;
            if (!int.TryParse(XRepeatCount.Text, out currentXReplicates) || currentXReplicates < 1) currentXReplicates = 1;
            if (XNoRepeat.IsChecked == true) currentXReplicates = 1;
            currentDataMode = YDataMode.SelectedIndex;
            BuildDataGrid();
        }

        private void BuildDataGrid()
        {
            dataTable = new DataTable();
            DataGridMain.Columns.Clear();
            ColumnHeadersPanel.Children.Clear();
            columnTitleBoxes.Clear();

            int xSubCols = (XHasRepeat.IsChecked == true) ? currentXReplicates : 1;
            int ySubCols = currentDataMode == 1 ? currentYReplicates : (currentDataMode == 2 ? 3 : 1);

            // For Column chart, X is not needed (uses Y series names)
            bool isColumnChart = currentChartType == "Column";

            var xHeaderPanel = CreateXColumnHeader(xSubCols, isColumnChart);
            ColumnHeadersPanel.Children.Add(xHeaderPanel);

            for (int i = 0; i < xSubCols; i++)
            {
                string colName = $"X_{i}";
                dataTable.Columns.Add(colName, typeof(string));
                
                var xColumn = new DataGridTextColumn
                {
                    Header = xSubCols > 1 ? $"X{i + 1}" : "X",
                    Binding = new Binding(colName) { UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged },
                    Width = 70,
                    IsReadOnly = isColumnChart
                };
                
                // Set gray background for Column chart X column
                if (isColumnChart)
                {
                    var style = new Style(typeof(DataGridCell));
                    style.Setters.Add(new Setter(DataGridCell.BackgroundProperty, new SolidColorBrush(Color.FromRgb(230, 230, 230))));
                    style.Setters.Add(new Setter(DataGridCell.ForegroundProperty, new SolidColorBrush(Color.FromRgb(150, 150, 150))));
                    xColumn.CellStyle = style;
                }
                
                DataGridMain.Columns.Add(xColumn);
            }

            for (int y = 0; y < currentYColumns; y++)
            {
                var yHeaderPanel = CreateYColumnHeader($"Y{y + 1}", ySubCols, y);
                ColumnHeadersPanel.Children.Add(yHeaderPanel);

                if (currentDataMode == 2)
                {
                    string[] subHeaders = { "Mean", "SD", "N" };
                    for (int s = 0; s < 3; s++)
                    {
                        string colName = $"Y{y}_{subHeaders[s]}";
                        dataTable.Columns.Add(colName, typeof(string));
                        DataGridMain.Columns.Add(new DataGridTextColumn
                        {
                            Header = subHeaders[s],
                            Binding = new Binding(colName) { UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged },
                            Width = 60
                        });
                    }
                }
                else
                {
                    for (int s = 0; s < ySubCols; s++)
                    {
                        string colName = $"Y{y}_{s}";
                        dataTable.Columns.Add(colName, typeof(string));
                        DataGridMain.Columns.Add(new DataGridTextColumn
                        {
                            Header = ySubCols > 1 ? $"Rep{s + 1}" : "Value",
                            Binding = new Binding(colName) { UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged },
                            Width = 70
                        });
                    }
                }
            }

            for (int i = 0; i < DEFAULT_ROWS; i++)
                dataTable.Rows.Add(dataTable.NewRow());

            DataGridMain.ItemsSource = dataTable.DefaultView;
        }

        private Border CreateXColumnHeader(int subColumns, bool isDisabled = false)
        {
            var border = new Border
            {
                BorderBrush = new SolidColorBrush(Color.FromRgb(224, 224, 224)),
                BorderThickness = new Thickness(1),
                Background = isDisabled 
                    ? new SolidColorBrush(Color.FromRgb(220, 220, 220))  // Gray for Column chart
                    : new SolidColorBrush(Color.FromRgb(230, 245, 255)),
                Margin = new Thickness(0, 0, 2, 0),
                Width = 70 * subColumns + (subColumns > 1 ? (subColumns - 1) * 2 : 0)
            };

            var stack = new StackPanel { Margin = new Thickness(5) };
            var headerPanel = new StackPanel { Orientation = Orientation.Horizontal, HorizontalAlignment = HorizontalAlignment.Center };

            headerPanel.Children.Add(new TextBlock
            {
                Text = "X",
                FontWeight = FontWeights.Bold,
                Foreground = isDisabled 
                    ? new SolidColorBrush(Color.FromRgb(150, 150, 150))
                    : new SolidColorBrush(Color.FromRgb(33, 150, 243)),
                Margin = new Thickness(0, 0, 5, 0)
            });

            var titleBox = new TextBox
            {
                Text = isDisabled ? "(Not used)" : "X",
                Width = isDisabled ? 70 : 50,
                FontSize = 10,
                BorderThickness = new Thickness(1),
                Padding = new Thickness(2),
                Tag = "X",
                IsEnabled = !isDisabled,
                Background = isDisabled 
                    ? new SolidColorBrush(Color.FromRgb(200, 200, 200)) 
                    : Brushes.White,
                Foreground = isDisabled 
                    ? new SolidColorBrush(Color.FromRgb(120, 120, 120))
                    : Brushes.Black
            };
            columnTitleBoxes.Add(titleBox);
            headerPanel.Children.Add(titleBox);

            stack.Children.Add(headerPanel);
            border.Child = stack;
            return border;
        }

        private Border CreateYColumnHeader(string title, int subColumns, int yIndex)
        {
            var border = new Border
            {
                BorderBrush = new SolidColorBrush(Color.FromRgb(224, 224, 224)),
                BorderThickness = new Thickness(1),
                Background = new SolidColorBrush(Color.FromRgb(255, 243, 224)),
                Margin = new Thickness(0, 0, 2, 0),
                Width = (currentDataMode == 2 ? 60 : 70) * subColumns + (subColumns > 1 ? (subColumns - 1) * 2 : 0)
            };

            var stack = new StackPanel { Margin = new Thickness(5) };
            var headerPanel = new StackPanel { Orientation = Orientation.Horizontal, HorizontalAlignment = HorizontalAlignment.Center };

            headerPanel.Children.Add(new TextBlock
            {
                Text = title,
                FontWeight = FontWeights.Bold,
                Foreground = new SolidColorBrush(Color.FromRgb(255, 152, 0)),
                Margin = new Thickness(0, 0, 5, 0)
            });

            var titleBox = new TextBox
            {
                Text = $"Series {yIndex + 1}",
                Width = 70,
                FontSize = 10,
                BorderThickness = new Thickness(1),
                Padding = new Thickness(2),
                Tag = $"Y{yIndex}"
            };
            columnTitleBoxes.Add(titleBox);
            headerPanel.Children.Add(titleBox);

            stack.Children.Add(headerPanel);
            border.Child = stack;
            return border;
        }

        private void SortXAscending_Click(object sender, RoutedEventArgs e) => SortByX(true);
        private void SortXDescending_Click(object sender, RoutedEventArgs e) => SortByX(false);

        private void SortByX(bool ascending)
        {
            DataGridMain.CommitEdit(DataGridEditingUnit.Row, true);
            DataGridMain.CommitEdit(DataGridEditingUnit.Cell, true);
            
            var rowsWithData = new List<(double xValue, DataRow row)>();

            foreach (DataRow row in dataTable.Rows)
            {
                string xStr = row["X_0"]?.ToString() ?? "";
                if (!double.TryParse(xStr, out double xValue)) continue;

                bool hasData = false;
                for (int c = 1; c < dataTable.Columns.Count; c++)
                {
                    if (!string.IsNullOrWhiteSpace(row[c]?.ToString())) { hasData = true; break; }
                }

                if (hasData)
                {
                    var newRow = dataTable.NewRow();
                    for (int c = 0; c < dataTable.Columns.Count; c++) newRow[c] = row[c];
                    rowsWithData.Add((xValue, newRow));
                }
            }

            if (rowsWithData.Count == 0) { MessageBox.Show("No data to sort.", "Sort"); return; }

            var sorted = ascending ? rowsWithData.OrderBy(r => r.xValue).ToList() : rowsWithData.OrderByDescending(r => r.xValue).ToList();
            dataTable.Rows.Clear();

            foreach (var item in sorted)
            {
                var newRow = dataTable.NewRow();
                for (int c = 0; c < dataTable.Columns.Count; c++) newRow[c] = item.row[c];
                dataTable.Rows.Add(newRow);
            }

            for (int i = 0; i < DEFAULT_ROWS - sorted.Count; i++)
                dataTable.Rows.Add(dataTable.NewRow());

            DataGridMain.Items.Refresh();
        }

        private void DataGrid_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (Keyboard.Modifiers == ModifierKeys.Control)
            {
                switch (e.Key)
                {
                    case Key.V: PasteFromClipboard(false); e.Handled = true; break;
                    case Key.C: CopySelectedToClipboard(); e.Handled = true; break;
                    case Key.A: DataGridMain.SelectAll(); e.Handled = true; break;
                }
            }
            else if (e.Key == Key.Delete)
            {
                DeleteSelectedCells();
                e.Handled = true;
            }
        }

        private void DeleteSelectedCells()
        {
            var selectedCells = DataGridMain.SelectedCells;
            if (selectedCells.Count == 0) return;

            DataGridMain.CommitEdit(DataGridEditingUnit.Row, true);

            foreach (var cell in selectedCells)
            {
                if (cell.Item is DataRowView drv)
                {
                    int colIndex = DataGridMain.Columns.IndexOf(cell.Column);
                    if (colIndex >= 0 && colIndex < dataTable.Columns.Count)
                    {
                        drv.Row[colIndex] = DBNull.Value;
                    }
                }
            }
            DataGridMain.Items.Refresh();
        }

        private void CopySelectedToClipboard()
        {
            var selectedCells = DataGridMain.SelectedCells;
            if (selectedCells.Count == 0) return;

            DataGridMain.CommitEdit(DataGridEditingUnit.Row, true);

            var cellsByRow = new Dictionary<int, Dictionary<int, string>>();
            foreach (var cell in selectedCells)
            {
                int rowIndex = DataGridMain.Items.IndexOf(cell.Item);
                int colIndex = DataGridMain.Columns.IndexOf(cell.Column);
                if (!cellsByRow.ContainsKey(rowIndex)) cellsByRow[rowIndex] = new Dictionary<int, string>();
                if (cell.Item is DataRowView drv && colIndex >= 0 && colIndex < dataTable.Columns.Count)
                    cellsByRow[rowIndex][colIndex] = drv.Row[colIndex]?.ToString() ?? "";
            }

            if (cellsByRow.Count == 0) return;

            var sb = new StringBuilder();
            int minCol = cellsByRow.Values.SelectMany(d => d.Keys).Min();
            int maxCol = cellsByRow.Values.SelectMany(d => d.Keys).Max();

            foreach (var row in cellsByRow.OrderBy(r => r.Key))
            {
                var values = new List<string>();
                for (int col = minCol; col <= maxCol; col++)
                    values.Add(row.Value.ContainsKey(col) ? row.Value[col] : "");
                sb.AppendLine(string.Join("\t", values));
            }
            Clipboard.SetText(sb.ToString());
        }

        private void PasteFromClipboard(bool transpose)
        {
            if (!Clipboard.ContainsText()) return;

            DataGridMain.CommitEdit(DataGridEditingUnit.Row, true);

            string[] lines = Clipboard.GetText().Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
            if (lines.Length == 0) return;

            var data = lines.Select(l => l.Split('\t')).ToArray();

            if (transpose && data.Length > 0)
            {
                int maxCols = data.Max(r => r.Length);
                var transposed = new string[maxCols][];
                for (int c = 0; c < maxCols; c++)
                {
                    transposed[c] = new string[data.Length];
                    for (int r = 0; r < data.Length; r++)
                        transposed[c][r] = c < data[r].Length ? data[r][c] : "";
                }
                data = transposed;
            }

            var currentCell = DataGridMain.CurrentCell;
            int startRow = 0, startCol = 0;
            if (currentCell.IsValid)
            {
                startRow = DataGridMain.Items.IndexOf(currentCell.Item);
                startCol = DataGridMain.Columns.IndexOf(currentCell.Column);
            }

            while (dataTable.Rows.Count < startRow + data.Length)
                dataTable.Rows.Add(dataTable.NewRow());

            for (int i = 0; i < data.Length; i++)
            {
                for (int j = 0; j < data[i].Length; j++)
                {
                    int colIndex = startCol + j;
                    if (colIndex < dataTable.Columns.Count && startRow + i < dataTable.Rows.Count)
                        dataTable.Rows[startRow + i][colIndex] = data[i][j].Trim();
                }
            }
            DataGridMain.Items.Refresh();
        }

        private void ImportClipboard_Click(object sender, RoutedEventArgs e)
        {
            if (DataGridMain.Items.Count > 0 && DataGridMain.Columns.Count > 0)
                DataGridMain.CurrentCell = new DataGridCellInfo(DataGridMain.Items[0], DataGridMain.Columns[0]);
            PasteFromClipboard(false);
        }

        private void TransposePaste_Click(object sender, RoutedEventArgs e)
        {
            PasteFromClipboard(true);
        }

        // Context menu handlers
        private void ContextCopy_Click(object sender, RoutedEventArgs e) => CopySelectedToClipboard();
        private void ContextPaste_Click(object sender, RoutedEventArgs e) => PasteFromClipboard(false);
        private void ContextPasteTransposed_Click(object sender, RoutedEventArgs e) => PasteFromClipboard(true);
        private void ContextDelete_Click(object sender, RoutedEventArgs e) => DeleteSelectedCells();
        private void ContextSelectAll_Click(object sender, RoutedEventArgs e) => DataGridMain.SelectAll();

        private void ClearAll_Click(object sender, RoutedEventArgs e)
        {
            DataGridMain.CommitEdit(DataGridEditingUnit.Row, true);
            DataGridMain.CommitEdit(DataGridEditingUnit.Cell, true);
            
            foreach (DataRow row in dataTable.Rows)
                for (int i = 0; i < dataTable.Columns.Count; i++) row[i] = DBNull.Value;
            DataGridMain.Items.Refresh();
        }

        private void DataGrid_ScrollChanged(object sender, ScrollChangedEventArgs e)
        {
            HeaderScrollViewer.ScrollToHorizontalOffset(e.HorizontalOffset);
        }

        /// <summary>
        /// Parse data based on Y Data Mode:
        /// Mode 0 (Single Value): Each row with same X is treated as a replicate. 
        ///                        Rows are grouped by X value, and SD/SEM/95CI are calculated.
        /// Mode 1 (Enter Replicates): Each row has multiple replicate columns per Y.
        /// Mode 2 (Mean/SD/N): User enters pre-calculated statistics.
        /// </summary>
        private List<ChartDataSeries> ParseData(bool allowTextX)
        {
            var seriesList = new List<ChartDataSeries>();
            int xSubCols = (XHasRepeat.IsChecked == true) ? currentXReplicates : 1;
            int ySubCols = currentDataMode == 1 ? currentYReplicates : (currentDataMode == 2 ? 3 : 1);

            // Column chart: special handling - each Y series is a single bar
            if (currentChartType == "Column")
            {
                return ParseDataColumnChart();
            }
            
            if (currentDataMode == 0)
            {
                // Single Value Mode: Group rows by X value, treat as replicates
                return ParseDataSingleValueMode(allowTextX, xSubCols);
            }
            else
            {
                // Mode 1 (replicates per row) or Mode 2 (Mean/SD/N)
                return ParseDataStandardMode(allowTextX, xSubCols, ySubCols);
            }
        }

        /// <summary>
        /// Column Chart: Each Y series becomes one bar, rows are replicates
        /// </summary>
        private List<ChartDataSeries> ParseDataColumnChart()
        {
            var seriesList = new List<ChartDataSeries>();
            
            for (int y = 0; y < currentYColumns; y++)
            {
                var series = new ChartDataSeries();
                string yTitle = columnTitleBoxes.FirstOrDefault(t => t.Tag?.ToString() == $"Y{y}")?.Text ?? $"Y{y + 1}";
                series.Name = yTitle;
                
                // Collect all values for this Y column (replicates)
                var yVals = new List<double>();
                for (int row = 0; row < dataTable.Rows.Count; row++)
                {
                    string cellVal = dataTable.Rows[row][$"Y{y}_0"]?.ToString()?.Trim() ?? "";
                    if (double.TryParse(cellVal, out double val))
                        yVals.Add(val);
                }
                
                if (yVals.Count > 0)
                {
                    double mean = yVals.Average();
                    double sd = CalculateSD(yVals);
                    double sem = yVals.Count > 1 ? sd / Math.Sqrt(yVals.Count) : 0;
                    
                    series.XLabels.Add(yTitle);  // Use Y series name as X label
                    series.XValues.Add(y);
                    series.YValues.Add(mean);
                    series.YErrors.Add(sd);
                    series.SEMValues.Add(sem);
                    series.NValues.Add(yVals.Count);
                    series.RawReplicates.Add(yVals);
                }
                
                seriesList.Add(series);
            }
            
            return seriesList;
        }

        /// <summary>
        /// Single Value Mode: Each row with same X value is treated as a replicate measurement.
        /// </summary>
        private List<ChartDataSeries> ParseDataSingleValueMode(bool allowTextX, int xSubCols)
        {
            var seriesList = new List<ChartDataSeries>();
            
            // Group data by X value for each Y series
            // Structure: yIndex -> xLabel -> list of Y values (replicates)
            var groupedData = new Dictionary<int, Dictionary<string, List<double>>>();
            
            for (int y = 0; y < currentYColumns; y++)
                groupedData[y] = new Dictionary<string, List<double>>();

            // Collect all data points grouped by X
            for (int row = 0; row < dataTable.Rows.Count; row++)
            {
                string firstXVal = dataTable.Rows[row]["X_0"]?.ToString()?.Trim() ?? "";
                if (string.IsNullOrEmpty(firstXVal)) continue;

                // Calculate X value (average if multiple X columns)
                var xVals = new List<double>();
                for (int x = 0; x < xSubCols; x++)
                {
                    string val = dataTable.Rows[row][$"X_{x}"]?.ToString() ?? "";
                    if (double.TryParse(val, out double d)) xVals.Add(d);
                }

                string xLabel;
                double xNumeric;
                
                if (xVals.Count > 0)
                {
                    xNumeric = xVals.Average();
                    xLabel = firstXVal;
                }
                else if (allowTextX)
                {
                    xNumeric = 0; // Will be set later
                    xLabel = firstXVal;
                }
                else
                {
                    continue; // Skip non-numeric X for charts requiring numeric X
                }

                // Collect Y values for each series
                for (int y = 0; y < currentYColumns; y++)
                {
                    string yStr = dataTable.Rows[row][$"Y{y}_0"]?.ToString() ?? "";
                    if (double.TryParse(yStr, out double yVal))
                    {
                        if (!groupedData[y].ContainsKey(xLabel))
                            groupedData[y][xLabel] = new List<double>();
                        groupedData[y][xLabel].Add(yVal);
                    }
                }
            }

            // Build series from grouped data
            for (int y = 0; y < currentYColumns; y++)
            {
                var series = new ChartDataSeries
                {
                    Name = columnTitleBoxes.FirstOrDefault(t => t.Tag?.ToString() == $"Y{y}")?.Text ?? $"Series {y + 1}",
                    XValues = new List<double>(),
                    XLabels = new List<string>(),
                    YValues = new List<double>(),
                    YErrors = new List<double>(),
                    SEMValues = new List<double>(),
                    NValues = new List<int>(),
                    RawReplicates = new List<List<double>>()
                };

                int xIndex = 0;
                foreach (var kvp in groupedData[y])
                {
                    string xLabel = kvp.Key;
                    List<double> yVals = kvp.Value;
                    
                    if (yVals.Count == 0) continue;

                    // Try to parse X as number
                    if (double.TryParse(xLabel, out double xNum))
                        series.XValues.Add(xNum);
                    else
                        series.XValues.Add(xIndex);
                    
                    series.XLabels.Add(xLabel);

                    double mean = yVals.Average();
                    double sd = yVals.Count > 1 ? CalculateSD(yVals) : 0;
                    double sem = yVals.Count > 1 ? sd / Math.Sqrt(yVals.Count) : 0;

                    series.YValues.Add(mean);
                    series.YErrors.Add(sd);
                    series.SEMValues.Add(sem);
                    series.NValues.Add(yVals.Count);
                    series.RawReplicates.Add(new List<double>(yVals));

                    xIndex++;
                }

                if (series.YValues.Count > 0)
                    seriesList.Add(series);
            }

            return seriesList;
        }

        /// <summary>
        /// Standard Mode: Mode 1 (replicates per row) or Mode 2 (Mean/SD/N)
        /// </summary>
        private List<ChartDataSeries> ParseDataStandardMode(bool allowTextX, int xSubCols, int ySubCols)
        {
            var seriesList = new List<ChartDataSeries>();
            var xValues = new List<double>();
            var xLabels = new List<string>();
            var validRowIndices = new List<int>();

            for (int row = 0; row < dataTable.Rows.Count; row++)
            {
                string firstXVal = dataTable.Rows[row]["X_0"]?.ToString()?.Trim() ?? "";

                // Check if this row has any Y data
                bool hasYData = false;
                for (int y = 0; y < currentYColumns && !hasYData; y++)
                {
                    if (currentDataMode == 2)
                    {
                        string meanStr = dataTable.Rows[row][$"Y{y}_Mean"]?.ToString() ?? "";
                        if (!string.IsNullOrWhiteSpace(meanStr) && double.TryParse(meanStr, out _))
                            hasYData = true;
                    }
                    else
                    {
                        for (int s = 0; s < ySubCols && !hasYData; s++)
                        {
                            string val = dataTable.Rows[row][$"Y{y}_{s}"]?.ToString() ?? "";
                            if (!string.IsNullOrWhiteSpace(val) && double.TryParse(val, out _))
                                hasYData = true;
                        }
                    }
                }

                if (!hasYData)
                {
                    if (validRowIndices.Count > 0) break;
                    continue;
                }

                validRowIndices.Add(row);

                // Handle X value
                if (!string.IsNullOrEmpty(firstXVal))
                {
                    var xVals = new List<double>();
                    for (int x = 0; x < xSubCols; x++)
                    {
                        string val = dataTable.Rows[row][$"X_{x}"]?.ToString() ?? "";
                        if (double.TryParse(val, out double d)) xVals.Add(d);
                    }

                    if (xVals.Count > 0)
                    {
                        xValues.Add(xVals.Average());
                        xLabels.Add(firstXVal);
                    }
                    else if (allowTextX)
                    {
                        xValues.Add(xLabels.Count);
                        xLabels.Add(firstXVal);
                    }
                    else
                    {
                        validRowIndices.RemoveAt(validRowIndices.Count - 1);
                        continue;
                    }
                }
                else if (allowTextX)
                {
                    xValues.Add(xLabels.Count);
                    xLabels.Add($"Group {xLabels.Count + 1}");
                }
                else
                {
                    validRowIndices.RemoveAt(validRowIndices.Count - 1);
                    continue;
                }
            }

            // Parse each Y series
            for (int y = 0; y < currentYColumns; y++)
            {
                var series = new ChartDataSeries
                {
                    Name = columnTitleBoxes.FirstOrDefault(t => t.Tag?.ToString() == $"Y{y}")?.Text ?? $"Series {y + 1}",
                    XValues = new List<double>(),
                    XLabels = new List<string>(),
                    YValues = new List<double>(),
                    YErrors = new List<double>(),
                    SEMValues = new List<double>(),
                    NValues = new List<int>(),
                    RawReplicates = new List<List<double>>()
                };

                for (int i = 0; i < validRowIndices.Count; i++)
                {
                    int row = validRowIndices[i];

                    if (currentDataMode == 2)
                    {
                        string meanStr = dataTable.Rows[row][$"Y{y}_Mean"]?.ToString() ?? "";
                        string sdStr = dataTable.Rows[row][$"Y{y}_SD"]?.ToString() ?? "";
                        string nStr = dataTable.Rows[row][$"Y{y}_N"]?.ToString() ?? "";

                        if (double.TryParse(meanStr, out double mean))
                        {
                            series.XValues.Add(xValues[i]);
                            series.XLabels.Add(xLabels[i]);
                            series.YValues.Add(mean);
                            double.TryParse(sdStr, out double sd);
                            int.TryParse(nStr, out int n);
                            if (n < 1) n = 1;
                            series.YErrors.Add(sd);
                            series.SEMValues.Add(n > 1 ? sd / Math.Sqrt(n) : 0);
                            series.NValues.Add(n);
                            series.RawReplicates.Add(new List<double>());
                        }
                    }
                    else
                    {
                        var yVals = new List<double>();
                        for (int s = 0; s < ySubCols; s++)
                        {
                            string val = dataTable.Rows[row][$"Y{y}_{s}"]?.ToString() ?? "";
                            if (double.TryParse(val, out double d)) yVals.Add(d);
                        }

                        if (yVals.Count > 0)
                        {
                            series.XValues.Add(xValues[i]);
                            series.XLabels.Add(xLabels[i]);
                            double mean = yVals.Average();
                            double sd = yVals.Count > 1 ? CalculateSD(yVals) : 0;
                            double sem = yVals.Count > 1 ? sd / Math.Sqrt(yVals.Count) : 0;

                            series.YValues.Add(mean);
                            series.YErrors.Add(sd);
                            series.SEMValues.Add(sem);
                            series.NValues.Add(yVals.Count);
                            series.RawReplicates.Add(new List<double>(yVals));
                        }
                    }
                }

                if (series.YValues.Count > 0) seriesList.Add(series);
            }

            return seriesList;
        }

        private double CalculateSD(List<double> values)
        {
            if (values.Count < 2) return 0;
            double mean = values.Average();
            return Math.Sqrt(values.Sum(v => Math.Pow(v - mean, 2)) / (values.Count - 1));
        }

        private void GenerateLineChart_Click(object sender, RoutedEventArgs e) => GenerateChart("Line");
        private void GenerateScatterPlot_Click(object sender, RoutedEventArgs e) => GenerateChart("Scatter");
        private void GenerateVolcanoPlot_Click(object sender, RoutedEventArgs e) => GenerateChart("Volcano");
        private void GenerateColumnChart_Click(object sender, RoutedEventArgs e) => GenerateBarChart("Column");
        private void GenerateMultiGroupChart_Click(object sender, RoutedEventArgs e) => GenerateBarChart("MultiGroup");

        private void GenerateChart(string chartType)
        {
            // Commit any pending edits
            DataGridMain.CommitEdit(DataGridEditingUnit.Row, true);
            DataGridMain.CommitEdit(DataGridEditingUnit.Cell, true);
            
            var data = ParseData(allowTextX: false);
            if (data.Count == 0 || data.All(s => s.YValues.Count == 0))
            {
                MessageBox.Show("No valid data to plot.\n\nPlease check:\n??Enter numeric values in X and Y columns\n??Apply Settings after changing column settings\n??Data should not be empty",
                    "No Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var errorDialog = new ErrorBarDialog();
            errorDialog.Owner = Window.GetWindow(this);
            if (errorDialog.ShowDialog() != true) return;

            string xTitle = columnTitleBoxes.FirstOrDefault(t => t.Tag?.ToString() == "X")?.Text ?? "X";
            var chartWindow = new ChartWindow(data, chartType, errorDialog.SelectedErrorType, xTitle);
            chartWindow.Owner = Window.GetWindow(this);
            chartWindow.Show();
        }

        private void GenerateBarChart(string chartType)
        {
            // Commit any pending edits
            DataGridMain.CommitEdit(DataGridEditingUnit.Row, true);
            DataGridMain.CommitEdit(DataGridEditingUnit.Cell, true);
            
            var data = ParseData(allowTextX: true);
            if (data.Count == 0 || data.All(s => s.YValues.Count == 0))
            {
                MessageBox.Show("No valid data to plot.\n\nPlease check:\n??Enter values in X column (text or numbers)\n??Enter numeric values in Y columns\n??Apply Settings after changing column settings",
                    "No Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var errorDialog = new ErrorBarDialog();
            errorDialog.Owner = Window.GetWindow(this);
            if (errorDialog.ShowDialog() != true) return;

            string xTitle = columnTitleBoxes.FirstOrDefault(t => t.Tag?.ToString() == "X")?.Text ?? "X";
            var barChartWindow = new BarChartWindow(data, chartType, errorDialog.SelectedErrorType, xTitle, 
                errorDialog.SelectedDirection);
            barChartWindow.Owner = Window.GetWindow(this);
            barChartWindow.Show();
        }

        // Load sample data
        public void LoadSampleData(string chartType)
        {
            ClearAll_Click(null, null);
            
            // Helper to safely set cell value
            void SetCell(int row, string col, string val)
            {
                if (dataTable.Columns.Contains(col) && row < dataTable.Rows.Count)
                    dataTable.Rows[row][col] = val;
            }
            
            if (chartType == "MultiGroup")
            {
                // Multi Factors uses Enter Replicates mode (Y0_0, Y0_1, Y0_2 are replicates)
                // Each row is one X value with 3 replicates per Y series
                SetCell(0, "X_0", "Control");
                SetCell(0, "Y0_0", "10"); SetCell(0, "Y0_1", "12"); SetCell(0, "Y0_2", "11");
                SetCell(0, "Y1_0", "15"); SetCell(0, "Y1_1", "14"); SetCell(0, "Y1_2", "16");
                SetCell(0, "Y2_0", "12"); SetCell(0, "Y2_1", "11"); SetCell(0, "Y2_2", "13");

                SetCell(1, "X_0", "Treatment A");
                SetCell(1, "Y0_0", "25"); SetCell(1, "Y0_1", "27"); SetCell(1, "Y0_2", "24");
                SetCell(1, "Y1_0", "30"); SetCell(1, "Y1_1", "32"); SetCell(1, "Y1_2", "29");
                SetCell(1, "Y2_0", "28"); SetCell(1, "Y2_1", "26"); SetCell(1, "Y2_2", "27");

                SetCell(2, "X_0", "Treatment B");
                SetCell(2, "Y0_0", "18"); SetCell(2, "Y0_1", "20"); SetCell(2, "Y0_2", "17");
                SetCell(2, "Y1_0", "22"); SetCell(2, "Y1_1", "24"); SetCell(2, "Y1_2", "21");
                SetCell(2, "Y2_0", "20"); SetCell(2, "Y2_1", "19"); SetCell(2, "Y2_2", "21");
            }
            else if (chartType == "Column")
            {
                // Column chart: X is not used, each Y series is a bar
                // Multiple rows are replicates for each Y series
                // Y1 replicates
                SetCell(0, "Y0_0", "10"); SetCell(0, "Y1_0", "15"); SetCell(0, "Y2_0", "12");
                SetCell(1, "Y0_0", "12"); SetCell(1, "Y1_0", "14"); SetCell(1, "Y2_0", "11");
                SetCell(2, "Y0_0", "11"); SetCell(2, "Y1_0", "16"); SetCell(2, "Y2_0", "13");
            }
            else
            {
                // Sample X-Y data
                SetCell(0, "X_0", "1"); SetCell(0, "Y0_0", "2.1"); SetCell(0, "Y1_0", "1.8");
                SetCell(1, "X_0", "2"); SetCell(1, "Y0_0", "4.2"); SetCell(1, "Y1_0", "3.5");
                SetCell(2, "X_0", "3"); SetCell(2, "Y0_0", "5.8"); SetCell(2, "Y1_0", "5.2");
                SetCell(3, "X_0", "4"); SetCell(3, "Y0_0", "8.1"); SetCell(3, "Y1_0", "7.0");
                SetCell(4, "X_0", "5"); SetCell(4, "Y0_0", "10.5"); SetCell(4, "Y1_0", "9.2");
            }

            DataGridMain.Items.Refresh();
        }
    }

    public class ChartDataSeries
    {
        public string Name { get; set; } = "";
        public List<double> XValues { get; set; } = new List<double>();
        public List<string> XLabels { get; set; } = new List<string>();
        public List<double> YValues { get; set; } = new List<double>();
        public List<double> YErrors { get; set; } = new List<double>();
        public List<double> SEMValues { get; set; } = new List<double>();
        public List<int> NValues { get; set; } = new List<int>();
        public List<List<double>> RawReplicates { get; set; } = new List<List<double>>();
        public Color LineColor { get; set; } = Colors.Blue;
        public double LineThickness { get; set; } = 2;
        public int MarkerSize { get; set; } = 8;
        public string MarkerShape { get; set; } = "Circle";
    }
}


==================================================
FILE_NAME: GraphTypeSelector.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\GraphTypeSelector.xaml
==================================================
<Window x:Class="BioSAK.GraphTypeSelector"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Select Graph Type" 
        Height="350" Width="500"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Select Graph Type" 
                   FontSize="20" FontWeight="Bold" Foreground="#333"
                   Margin="0,0,0,20"/>

        <UniformGrid Grid.Row="1" Columns="3" Rows="1">
            <!-- X-Y Graph -->
            <Button x:Name="XYButton" Click="XYButton_Click" Margin="5" Cursor="Hand">
                <Button.Template>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="White" CornerRadius="10" 
                                BorderBrush="#E0E0E0" BorderThickness="2">
                            <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                                <TextBlock Text="??" FontSize="40" HorizontalAlignment="Center"/>
                                <TextBlock Text="X-Y Graph" FontSize="14" FontWeight="SemiBold" 
                                           HorizontalAlignment="Center" Margin="0,10,0,0"/>
                                <TextBlock Text="Line, Scatter, Volcano" FontSize="10" 
                                           Foreground="#888" HorizontalAlignment="Center"/>
                            </StackPanel>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="BorderBrush" Value="#4FC3F7"/>
                                <Setter TargetName="border" Property="Background" Value="#F0F9FF"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Button.Template>
            </Button>

            <!-- Column Graph -->
            <Button x:Name="ColumnButton" Click="ColumnButton_Click" Margin="5" Cursor="Hand">
                <Button.Template>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="White" CornerRadius="10" 
                                BorderBrush="#E0E0E0" BorderThickness="2">
                            <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                                <TextBlock Text="??" FontSize="40" HorizontalAlignment="Center"/>
                                <TextBlock Text="Column" FontSize="14" FontWeight="SemiBold" 
                                           HorizontalAlignment="Center" Margin="0,10,0,0"/>
                                <TextBlock Text="Bar Charts" FontSize="10" 
                                           Foreground="#888" HorizontalAlignment="Center"/>
                            </StackPanel>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="BorderBrush" Value="#4FC3F7"/>
                                <Setter TargetName="border" Property="Background" Value="#F0F9FF"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Button.Template>
            </Button>

            <!-- Multi Factors Graph -->
            <Button x:Name="GroupedButton" Click="GroupedButton_Click" Margin="5" Cursor="Hand">
                <Button.Template>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="White" CornerRadius="10" 
                                BorderBrush="#E0E0E0" BorderThickness="2">
                            <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                                <TextBlock Text="??" FontSize="40" HorizontalAlignment="Center"/>
                                <TextBlock Text="Multi Factors" FontSize="14" FontWeight="SemiBold" 
                                           HorizontalAlignment="Center" Margin="0,10,0,0"/>
                                <TextBlock Text="Grouped Analysis" FontSize="10" 
                                           Foreground="#888" HorizontalAlignment="Center"/>
                            </StackPanel>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="BorderBrush" Value="#4FC3F7"/>
                                <Setter TargetName="border" Property="Background" Value="#F0F9FF"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Button.Template>
            </Button>
        </UniformGrid>

        <!-- Sample Data Option -->
        <Border Grid.Row="2" Background="White" CornerRadius="8" Padding="15" Margin="0,15,0,0">
            <StackPanel>
                <CheckBox x:Name="LoadSampleCheck" Content="Load sample data for selected chart type" 
                          FontSize="12" Foreground="#555"/>
                <TextBlock Text="Sample data will be loaded when you select a chart type above." 
                           FontSize="10" Foreground="#888" Margin="20,5,0,0"/>
            </StackPanel>
        </Border>
    </Grid>
</Window>


==================================================
FILE_NAME: GraphTypeSelector.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\GraphTypeSelector.xaml.cs
==================================================
using System.Windows;
using System.Windows.Controls;

namespace BioSAK
{
    public partial class GraphTypeSelector : Window
    {
        public string SelectedType { get; private set; } = "";
        public bool LoadSampleData { get; private set; } = false;

        public GraphTypeSelector()
        {
            InitializeComponent();
        }

        private void XYButton_Click(object sender, RoutedEventArgs e)
        {
            SelectedType = "XY";
            LoadSampleData = LoadSampleCheck.IsChecked == true;
            NavigateToGraphGen("XY", useReplicateMode: false);
        }

        private void ColumnButton_Click(object sender, RoutedEventArgs e)
        {
            SelectedType = "Column";
            LoadSampleData = LoadSampleCheck.IsChecked == true;
            NavigateToGraphGen("Column", useReplicateMode: false);
        }

        private void GroupedButton_Click(object sender, RoutedEventArgs e)
        {
            SelectedType = "MultiGroup";
            LoadSampleData = LoadSampleCheck.IsChecked == true;
            NavigateToGraphGen("MultiGroup", useReplicateMode: true);
        }

        private void NavigateToGraphGen(string chartType, bool useReplicateMode)
        {
            var mainWindow = Owner as MainWindow;
            if (mainWindow != null)
            {
                var graphGen = new GraphGen();
                mainWindow.MainFrame.Navigate(graphGen);
                
                // Set chart type first (affects X column behavior)
                graphGen.SetChartType(chartType);
                
                // Set Enter Replicates mode for Multi Factors
                if (useReplicateMode)
                {
                    graphGen.SetYDataMode(1); // 1 = Enter Replicates
                }
                
                if (LoadSampleData)
                {
                    graphGen.LoadSampleData(chartType);
                }
            }
            this.Close();
        }
    }
}


==================================================
FILE_NAME: LineSettingsDialog.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\LineSettingsDialog.xaml
==================================================
<Window x:Class="BioSAK.LineSettingsDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Line Settings" 
        Height="320" Width="380"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Line Settings" FontSize="18" FontWeight="Bold" Margin="0,0,0,15"/>

        <!-- Line Thickness -->
        <GroupBox Grid.Row="1" Header="Line Thickness" Padding="10" Margin="0,0,0,10">
            <StackPanel Orientation="Horizontal">
                <Slider x:Name="ThicknessSlider" Width="200" Minimum="1" Maximum="10" 
                        Value="2" TickFrequency="0.5" IsSnapToTickEnabled="True"
                        ValueChanged="ThicknessSlider_ValueChanged"/>
                <TextBlock x:Name="ThicknessLabel" Text="2.0" Margin="15,0,0,0" 
                           VerticalAlignment="Center" FontWeight="SemiBold"/>
            </StackPanel>
        </GroupBox>

        <!-- Line Color -->
        <GroupBox Grid.Row="2" Header="Line Color" Padding="10" Margin="0,0,0,10">
            <StackPanel Orientation="Horizontal">
                <Border x:Name="ColorPreview" Width="40" Height="25" Background="Black"
                        BorderBrush="#CCC" BorderThickness="1" CornerRadius="3"/>
                <Button Content="Choose Color..." Margin="15,0,0,0" Padding="10,5"
                        Click="ChooseColor_Click"/>
            </StackPanel>
        </GroupBox>

        <!-- Arrow Direction (only visible for arrows) -->
        <GroupBox Grid.Row="3" x:Name="ArrowDirectionGroup" Header="Arrow Direction" 
                  Padding="10" Margin="0,0,0,10" Visibility="Collapsed">
            <StackPanel Orientation="Horizontal">
                <RadioButton x:Name="ArrowRightRadio" Content="→ Right" Margin="0,0,20,0" IsChecked="True"/>
                <RadioButton x:Name="ArrowLeftRadio" Content="← Left" Margin="0,0,20,0"/>
                <RadioButton x:Name="ArrowBothRadio" Content="↔ Both"/>
            </StackPanel>
        </GroupBox>

        <!-- Preview -->
        <GroupBox Grid.Row="4" Header="Preview" Padding="10">
            <Canvas x:Name="PreviewCanvas" Background="White" Height="50"/>
        </GroupBox>

        <!-- Buttons -->
        <StackPanel Grid.Row="5" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
            <Button Content="Cancel" Width="80" Padding="5,8" Margin="0,0,10,0"
                    Background="#EEE" BorderThickness="0" Cursor="Hand" Click="Cancel_Click"/>
            <Button Content="Apply" Width="80" Padding="5,8"
                    Background="#4FC3F7" Foreground="White" BorderThickness="0" 
                    Cursor="Hand" Click="Apply_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: LineSettingsDialog.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\LineSettingsDialog.xaml.cs
==================================================
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;

namespace BioSAK
{
    public partial class LineSettingsDialog : Window
    {
        public double LineThickness { get; private set; } = 2;
        public Color LineColor { get; private set; } = Colors.Black;
        public string ArrowDirection { get; private set; } = "Right";

        private string lineType;
        private bool isInitialized = false;

        public LineSettingsDialog(LineShapeInfo info)
        {
            InitializeComponent();

            lineType = info.Type;
            LineThickness = info.Thickness;
            LineColor = (info.Stroke as SolidColorBrush)?.Color ?? Colors.Black;

            this.Loaded += (s, e) =>
            {
                ThicknessSlider.Value = LineThickness;
                ThicknessLabel.Text = LineThickness.ToString("F1");
                ColorPreview.Background = new SolidColorBrush(LineColor);

                // Show arrow direction options only for arrows
                if (lineType == "Arrow")
                {
                    ArrowDirectionGroup.Visibility = Visibility.Visible;

                    // Set current direction
                    switch (info.ArrowDirection)
                    {
                        case "Left":
                            ArrowLeftRadio.IsChecked = true;
                            break;
                        case "Both":
                            ArrowBothRadio.IsChecked = true;
                            break;
                        default:
                            ArrowRightRadio.IsChecked = true;
                            break;
                    }
                }

                isInitialized = true;
                UpdatePreview();
            };

            // Event handlers for preview update
            ArrowRightRadio.Checked += (s, e) => UpdatePreview();
            ArrowLeftRadio.Checked += (s, e) => UpdatePreview();
            ArrowBothRadio.Checked += (s, e) => UpdatePreview();
        }

        private void ThicknessSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (!isInitialized || ThicknessLabel == null) return;

            LineThickness = ThicknessSlider.Value;
            ThicknessLabel.Text = LineThickness.ToString("F1");
            UpdatePreview();
        }

        private void ChooseColor_Click(object sender, RoutedEventArgs e)
        {
            var colorDialog = new ColorPickerDialog(LineColor);
            colorDialog.Owner = this;
            if (colorDialog.ShowDialog() == true)
            {
                LineColor = colorDialog.SelectedColor;
                ColorPreview.Background = new SolidColorBrush(LineColor);
                UpdatePreview();
            }
        }

        private void UpdatePreview()
        {
            if (!isInitialized || PreviewCanvas == null) return;

            PreviewCanvas.Children.Clear();

            var brush = new SolidColorBrush(LineColor);
            double canvasWidth = PreviewCanvas.ActualWidth > 0 ? PreviewCanvas.ActualWidth : 280;
            double midY = 25;
            double padding = 20;

            switch (lineType)
            {
                case "Line":
                    var line = new Line
                    {
                        X1 = padding,
                        Y1 = midY,
                        X2 = canvasWidth - padding,
                        Y2 = midY,
                        Stroke = brush,
                        StrokeThickness = LineThickness
                    };
                    PreviewCanvas.Children.Add(line);
                    break;

                case "Arrow":
                    DrawArrowPreview(brush, canvasWidth, midY, padding);
                    break;

                case "UShape":
                    DrawUShapePreview(brush, canvasWidth, padding);
                    break;

                case "HShape":
                    DrawHShapePreview(brush, canvasWidth, midY, padding);
                    break;
            }
        }

        private void DrawArrowPreview(Brush brush, double canvasWidth, double midY, double padding)
        {
            string direction = "Right";
            if (ArrowLeftRadio.IsChecked == true) direction = "Left";
            else if (ArrowBothRadio.IsChecked == true) direction = "Both";

            double lineStart = padding;
            double lineEnd = canvasWidth - padding;
            double arrowSize = 8;

            if (direction == "Right" || direction == "Both")
            {
                // Right arrow
                var line = new Line
                {
                    X1 = lineStart + (direction == "Both" ? arrowSize : 0),
                    Y1 = midY,
                    X2 = lineEnd - arrowSize,
                    Y2 = midY,
                    Stroke = brush,
                    StrokeThickness = LineThickness
                };
                PreviewCanvas.Children.Add(line);

                var rightHead = new Polygon
                {
                    Points = new PointCollection
                    {
                        new Point(lineEnd - arrowSize, midY - arrowSize),
                        new Point(lineEnd, midY),
                        new Point(lineEnd - arrowSize, midY + arrowSize)
                    },
                    Fill = brush
                };
                PreviewCanvas.Children.Add(rightHead);
            }

            if (direction == "Left" || direction == "Both")
            {
                if (direction == "Left")
                {
                    var line = new Line
                    {
                        X1 = lineStart + arrowSize,
                        Y1 = midY,
                        X2 = lineEnd,
                        Y2 = midY,
                        Stroke = brush,
                        StrokeThickness = LineThickness
                    };
                    PreviewCanvas.Children.Add(line);
                }

                var leftHead = new Polygon
                {
                    Points = new PointCollection
                    {
                        new Point(lineStart + arrowSize, midY - arrowSize),
                        new Point(lineStart, midY),
                        new Point(lineStart + arrowSize, midY + arrowSize)
                    },
                    Fill = brush
                };
                PreviewCanvas.Children.Add(leftHead);
            }
        }

        private void DrawUShapePreview(Brush brush, double canvasWidth, double padding)
        {
            double height = 35;

            var leftLine = new Line
            {
                X1 = padding,
                Y1 = 5,
                X2 = padding,
                Y2 = height,
                Stroke = brush,
                StrokeThickness = LineThickness
            };
            PreviewCanvas.Children.Add(leftLine);

            var topLine = new Line
            {
                X1 = padding,
                Y1 = 5,
                X2 = canvasWidth - padding,
                Y2 = 5,
                Stroke = brush,
                StrokeThickness = LineThickness
            };
            PreviewCanvas.Children.Add(topLine);

            var rightLine = new Line
            {
                X1 = canvasWidth - padding,
                Y1 = 5,
                X2 = canvasWidth - padding,
                Y2 = height,
                Stroke = brush,
                StrokeThickness = LineThickness
            };
            PreviewCanvas.Children.Add(rightLine);
        }

        private void DrawHShapePreview(Brush brush, double canvasWidth, double midY, double padding)
        {
            double halfHeight = 15;

            var leftLine = new Line
            {
                X1 = padding,
                Y1 = midY - halfHeight,
                X2 = padding,
                Y2 = midY + halfHeight,
                Stroke = brush,
                StrokeThickness = LineThickness
            };
            PreviewCanvas.Children.Add(leftLine);

            var midLine = new Line
            {
                X1 = padding,
                Y1 = midY,
                X2 = canvasWidth - padding,
                Y2 = midY,
                Stroke = brush,
                StrokeThickness = LineThickness
            };
            PreviewCanvas.Children.Add(midLine);

            var rightLine = new Line
            {
                X1 = canvasWidth - padding,
                Y1 = midY - halfHeight,
                X2 = canvasWidth - padding,
                Y2 = midY + halfHeight,
                Stroke = brush,
                StrokeThickness = LineThickness
            };
            PreviewCanvas.Children.Add(rightLine);
        }

        private void Apply_Click(object sender, RoutedEventArgs e)
        {
            LineThickness = ThicknessSlider.Value;

            if (ArrowLeftRadio.IsChecked == true)
                ArrowDirection = "Left";
            else if (ArrowBothRadio.IsChecked == true)
                ArrowDirection = "Both";
            else
                ArrowDirection = "Right";

            DialogResult = true;
            Close();
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}


==================================================
FILE_NAME: SingleBarStyleDialog.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\SingleBarStyleDialog.xaml
==================================================
<Window x:Class="BioSAK.SingleBarStyleDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Edit Bar Style" 
        Height="420" Width="400"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" x:Name="TitleText" Text="Edit Bar" FontSize="16" FontWeight="Bold" Margin="0,0,0,15"/>

        <Grid Grid.Row="1">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="110"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>

            <!-- Fill Color -->
            <TextBlock Grid.Row="0" Grid.Column="0" Text="Fill Color:" VerticalAlignment="Center" Margin="0,8"/>
            <StackPanel Grid.Row="0" Grid.Column="1" Orientation="Horizontal" Margin="0,8">
                <Border x:Name="FillColorPreview" Width="30" Height="25" BorderBrush="Gray" BorderThickness="1" Margin="0,0,10,0"/>
                <Button Content="Choose..." Padding="10,3" Click="ChooseFillColor_Click"/>
            </StackPanel>

            <!-- Border Color -->
            <TextBlock Grid.Row="1" Grid.Column="0" Text="Border Color:" VerticalAlignment="Center" Margin="0,8"/>
            <StackPanel Grid.Row="1" Grid.Column="1" Orientation="Horizontal" Margin="0,8">
                <Border x:Name="BorderColorPreview" Width="30" Height="25" BorderBrush="Gray" BorderThickness="1" Margin="0,0,10,0"/>
                <Button Content="Choose..." Padding="10,3" Click="ChooseBorderColor_Click"/>
            </StackPanel>

            <!-- Border Thickness -->
            <TextBlock Grid.Row="2" Grid.Column="0" Text="Border Width:" VerticalAlignment="Center" Margin="0,8"/>
            <StackPanel Grid.Row="2" Grid.Column="1" Orientation="Horizontal" Margin="0,8">
                <Slider x:Name="BorderThicknessSlider" Width="120" Minimum="0" Maximum="5" Value="1" TickFrequency="0.5" IsSnapToTickEnabled="True"/>
                <TextBlock x:Name="BorderThicknessLabel" Text="1" Margin="10,0,0,0" VerticalAlignment="Center"/>
            </StackPanel>

            <!-- Fill Pattern -->
            <TextBlock Grid.Row="3" Grid.Column="0" Text="Fill Pattern:" VerticalAlignment="Center" Margin="0,8"/>
            <ComboBox Grid.Row="3" Grid.Column="1" x:Name="PatternCombo" Width="150" HorizontalAlignment="Left" Margin="0,8">
                <ComboBoxItem Content="Solid" Tag="Solid"/>
                <ComboBoxItem Content="Horizontal Lines" Tag="HorizontalLines"/>
                <ComboBoxItem Content="Vertical Lines" Tag="VerticalLines"/>
                <ComboBoxItem Content="Diagonal Up (/)" Tag="DiagonalUp"/>
                <ComboBoxItem Content="Diagonal Down (\)" Tag="DiagonalDown"/>
                <ComboBoxItem Content="Cross Hatch" Tag="CrossHatch"/>
                <ComboBoxItem Content="Dots" Tag="Dots"/>
            </ComboBox>

            <!-- Error Bar Direction -->
            <TextBlock Grid.Row="4" Grid.Column="0" Text="Error Bar:" VerticalAlignment="Center" Margin="0,8"/>
            <ComboBox Grid.Row="4" Grid.Column="1" x:Name="ErrorDirectionCombo" Width="150" HorizontalAlignment="Left" Margin="0,8">
                <ComboBoxItem Content="Both" Tag="Both"/>
                <ComboBoxItem Content="Upper only" Tag="Up"/>
                <ComboBoxItem Content="Lower only" Tag="Down"/>
            </ComboBox>

            <!-- Preview -->
            <TextBlock Grid.Row="5" Grid.Column="0" Text="Preview:" VerticalAlignment="Top" Margin="0,15,0,0"/>
            <Border Grid.Row="5" Grid.Column="1" x:Name="PreviewBorder" Width="80" Height="50" 
                    HorizontalAlignment="Left" Margin="0,15,0,0"
                    BorderBrush="Black" BorderThickness="1"/>
        </Grid>

        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
            <Button Content="Cancel" Width="80" Padding="5,8" Margin="0,0,10,0"
                    Background="#9E9E9E" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="Cancel_Click"/>
            <Button Content="OK" Width="80" Padding="5,8"
                    Background="#4CAF50" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="OK_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: SingleBarStyleDialog.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\SingleBarStyleDialog.xaml.cs
==================================================
using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace BioSAK
{
    public partial class SingleBarStyleDialog : Window
    {
        public BarStyle UpdatedStyle { get; private set; } = new BarStyle();
        private Color currentFillColor;
        private Color currentBorderColor;

        public SingleBarStyleDialog(BarStyle currentStyle, string seriesName, string xLabel)
        {
            InitializeComponent();

            TitleText.Text = $"Edit Bar: {seriesName} at {xLabel}";

            currentFillColor = currentStyle.FillColor;
            currentBorderColor = currentStyle.BorderColor;

            FillColorPreview.Background = new SolidColorBrush(currentFillColor);
            BorderColorPreview.Background = new SolidColorBrush(currentBorderColor);
            BorderThicknessSlider.Value = currentStyle.BorderThickness;
            BorderThicknessLabel.Text = currentStyle.BorderThickness.ToString("F1");

            // Set pattern combo
            foreach (ComboBoxItem item in PatternCombo.Items)
            {
                if (item.Tag?.ToString() == currentStyle.Pattern.ToString())
                {
                    PatternCombo.SelectedItem = item;
                    break;
                }
            }
            if (PatternCombo.SelectedItem == null && PatternCombo.Items.Count > 0)
                PatternCombo.SelectedIndex = 0;

            // Set error direction combo
            foreach (ComboBoxItem item in ErrorDirectionCombo.Items)
            {
                if (item.Tag?.ToString() == currentStyle.ErrorDirection.ToString())
                {
                    ErrorDirectionCombo.SelectedItem = item;
                    break;
                }
            }
            if (ErrorDirectionCombo.SelectedItem == null && ErrorDirectionCombo.Items.Count > 0)
                ErrorDirectionCombo.SelectedIndex = 0;

            BorderThicknessSlider.ValueChanged += (s, e) => { BorderThicknessLabel.Text = BorderThicknessSlider.Value.ToString("F1"); UpdatePreview(); };
            PatternCombo.SelectionChanged += (s, e) => UpdatePreview();

            UpdatePreview();
        }

        private void ChooseFillColor_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new ColorPickerDialog(currentFillColor);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                currentFillColor = dialog.SelectedColor;
                FillColorPreview.Background = new SolidColorBrush(currentFillColor);
                UpdatePreview();
            }
        }

        private void ChooseBorderColor_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new ColorPickerDialog(currentBorderColor);
            dialog.Owner = this;
            if (dialog.ShowDialog() == true)
            {
                currentBorderColor = dialog.SelectedColor;
                BorderColorPreview.Background = new SolidColorBrush(currentBorderColor);
                UpdatePreview();
            }
        }

        private FillPattern GetSelectedPattern()
        {
            if (PatternCombo.SelectedItem is ComboBoxItem item && item.Tag is string tag)
            {
                return Enum.TryParse<FillPattern>(tag, out var pattern) ? pattern : FillPattern.Solid;
            }
            return FillPattern.Solid;
        }

        private ErrorBarDirection GetSelectedErrorDirection()
        {
            if (ErrorDirectionCombo.SelectedItem is ComboBoxItem item && item.Tag is string tag)
            {
                return Enum.TryParse<ErrorBarDirection>(tag, out var dir) ? dir : ErrorBarDirection.Both;
            }
            return ErrorBarDirection.Both;
        }

        private void UpdatePreview()
        {
            var style = new BarStyle
            {
                FillColor = currentFillColor,
                BorderColor = currentBorderColor,
                BorderThickness = BorderThicknessSlider.Value,
                Pattern = GetSelectedPattern()
            };

            PreviewBorder.Background = CreatePatternBrush(style);
            PreviewBorder.BorderBrush = new SolidColorBrush(style.BorderColor);
            PreviewBorder.BorderThickness = new Thickness(style.BorderThickness);
        }

        private Brush CreatePatternBrush(BarStyle style)
        {
            var color = style.FillColor;

            switch (style.Pattern)
            {
                case FillPattern.Solid:
                    return new SolidColorBrush(color);
                case FillPattern.HorizontalLines:
                    return CreateLineBrush(color, 0);
                case FillPattern.VerticalLines:
                    return CreateLineBrush(color, 90);
                case FillPattern.DiagonalUp:
                    return CreateLineBrush(color, 45);
                case FillPattern.DiagonalDown:
                    return CreateLineBrush(color, -45);
                case FillPattern.CrossHatch:
                    return CreateCrossHatchBrush(color);
                case FillPattern.Dots:
                    return CreateDotsBrush(color);
                default:
                    return new SolidColorBrush(color);
            }
        }

        private Brush CreateLineBrush(Color color, double angle)
        {
            var brush = new DrawingBrush
            {
                TileMode = TileMode.Tile,
                Viewport = new Rect(0, 0, 8, 8),
                ViewportUnits = BrushMappingMode.Absolute
            };

            var group = new DrawingGroup();
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(Color.FromArgb(50, color.R, color.G, color.B)),
                null, new RectangleGeometry(new Rect(0, 0, 8, 8))));
            group.Children.Add(new GeometryDrawing(
                null, new Pen(new SolidColorBrush(color), 2),
                new LineGeometry(new Point(0, 4), new Point(8, 4))));

            brush.Drawing = group;
            brush.Transform = new RotateTransform(angle, 4, 4);
            return brush;
        }

        private Brush CreateCrossHatchBrush(Color color)
        {
            var brush = new DrawingBrush
            {
                TileMode = TileMode.Tile,
                Viewport = new Rect(0, 0, 8, 8),
                ViewportUnits = BrushMappingMode.Absolute
            };

            var group = new DrawingGroup();
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(Color.FromArgb(50, color.R, color.G, color.B)),
                null, new RectangleGeometry(new Rect(0, 0, 8, 8))));
            group.Children.Add(new GeometryDrawing(null, new Pen(new SolidColorBrush(color), 1),
                new LineGeometry(new Point(0, 0), new Point(8, 8))));
            group.Children.Add(new GeometryDrawing(null, new Pen(new SolidColorBrush(color), 1),
                new LineGeometry(new Point(8, 0), new Point(0, 8))));

            brush.Drawing = group;
            return brush;
        }

        private Brush CreateDotsBrush(Color color)
        {
            var brush = new DrawingBrush
            {
                TileMode = TileMode.Tile,
                Viewport = new Rect(0, 0, 8, 8),
                ViewportUnits = BrushMappingMode.Absolute
            };

            var group = new DrawingGroup();
            group.Children.Add(new GeometryDrawing(
                new SolidColorBrush(Color.FromArgb(50, color.R, color.G, color.B)),
                null, new RectangleGeometry(new Rect(0, 0, 8, 8))));
            group.Children.Add(new GeometryDrawing(new SolidColorBrush(color), null,
                new EllipseGeometry(new Point(4, 4), 2, 2)));

            brush.Drawing = group;
            return brush;
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }

        private void OK_Click(object sender, RoutedEventArgs e)
        {
            UpdatedStyle = new BarStyle
            {
                FillColor = currentFillColor,
                BorderColor = currentBorderColor,
                BorderThickness = BorderThicknessSlider.Value,
                Pattern = GetSelectedPattern(),
                ErrorDirection = GetSelectedErrorDirection()
            };

            DialogResult = true;
            Close();
        }
    }
}


==================================================
FILE_NAME: StatisticsWindow.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\StatisticsWindow.xaml
==================================================
<Window x:Class="BioSAK.StatisticsWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Statistical Analysis" 
        Height="700" Width="850"
        WindowStartupLocation="CenterOwner"
        Background="#F5F5F5">

    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Title -->
        <TextBlock Grid.Row="0" Text="?? Statistical Analysis" FontSize="22" FontWeight="Bold" 
                   Foreground="#333" Margin="0,0,0,15"/>

        <!-- Main Content - Switches between Setup and Results -->
        <Grid Grid.Row="1">
            <!-- Step 1: Method Selection Panel -->
            <Border x:Name="MethodSelectionPanel" Background="White" CornerRadius="8" Padding="20">
                <Border.Effect>
                    <DropShadowEffect ShadowDepth="2" BlurRadius="10" Opacity="0.1"/>
                </Border.Effect>
                <StackPanel>
                    <TextBlock Text="Step 1: Select Statistical Method" FontSize="16" FontWeight="SemiBold" 
                               Foreground="#333" Margin="0,0,0,20"/>

                    <RadioButton x:Name="MethodRegression" GroupName="Method" Margin="0,5" FontSize="14">
                        <StackPanel>
                            <TextBlock Text="?? Linear Regression" FontWeight="SemiBold"/>
                            <TextBlock Text="R簡, Pearson correlation, slope significance for each series" 
                                       Foreground="#666" FontSize="12" Margin="20,2,0,0"/>
                        </StackPanel>
                    </RadioButton>

                    <RadioButton x:Name="MethodTTest" GroupName="Method" Margin="0,10" FontSize="14">
                        <StackPanel>
                            <TextBlock Text="? T-Test (Two Groups)" FontWeight="SemiBold"/>
                            <TextBlock Text="Compare two series at a specific X value using replicate data" 
                                       Foreground="#666" FontSize="12" Margin="20,2,0,0"/>
                        </StackPanel>
                    </RadioButton>

                    <RadioButton x:Name="MethodOneWayAnovaSameX" GroupName="Method" Margin="0,10" FontSize="14">
                        <StackPanel>
                            <TextBlock Text="?? One-Way ANOVA (Same X)" FontWeight="SemiBold"/>
                            <TextBlock Text="Compare multiple series at a specific X value" 
                                       Foreground="#666" FontSize="12" Margin="20,2,0,0"/>
                        </StackPanel>
                    </RadioButton>

                    <RadioButton x:Name="MethodOneWayAnovaSameRow" GroupName="Method" Margin="0,10" FontSize="14">
                        <StackPanel>
                            <TextBlock Text="?? One-Way ANOVA (Same Series)" FontWeight="SemiBold"/>
                            <TextBlock Text="Compare different X values within one series" 
                                       Foreground="#666" FontSize="12" Margin="20,2,0,0"/>
                        </StackPanel>
                    </RadioButton>

                    <RadioButton x:Name="MethodTwoWayAnova" GroupName="Method" Margin="0,10" FontSize="14">
                        <StackPanel>
                            <TextBlock Text="?? Two-Way ANOVA" FontWeight="SemiBold"/>
                            <TextBlock Text="Analyze effects of Series and X value (requires multiple rows)" 
                                       Foreground="#666" FontSize="12" Margin="20,2,0,0"/>
                        </StackPanel>
                    </RadioButton>

                    <RadioButton x:Name="MethodDescriptive" GroupName="Method" Margin="0,10" FontSize="14">
                        <StackPanel>
                            <TextBlock Text="?? Descriptive Statistics" FontWeight="SemiBold"/>
                            <TextBlock Text="Mean, SD, SEM, Min, Max, Median for each series" 
                                       Foreground="#666" FontSize="12" Margin="20,2,0,0"/>
                        </StackPanel>
                    </RadioButton>

                    <Button Content="Next ?? HorizontalAlignment="Right" Margin="0,25,0,0" Padding="25,10"
                            Background="#2196F3" Foreground="White" BorderThickness="0" FontSize="14"
                            Cursor="Hand" Click="NextToSetup_Click"/>
                </StackPanel>
            </Border>

            <!-- Step 2: Setup Panel (shown after method selection) -->
            <Border x:Name="SetupPanel" Background="White" CornerRadius="8" Padding="20" Visibility="Collapsed">
                <Border.Effect>
                    <DropShadowEffect ShadowDepth="2" BlurRadius="10" Opacity="0.1"/>
                </Border.Effect>
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <StackPanel Grid.Row="0">
                        <TextBlock x:Name="SetupTitle" Text="Step 2: Configure Analysis" FontSize="16" FontWeight="SemiBold" 
                                   Foreground="#333" Margin="0,0,0,15"/>
                    </StackPanel>

                    <!-- Dynamic setup content -->
                    <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto">
                        <StackPanel x:Name="SetupContent" Margin="0,0,0,10"/>
                    </ScrollViewer>

                    <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right">
                        <Button Content="??Back" Margin="0,0,10,0" Padding="20,10"
                                Background="#9E9E9E" Foreground="White" BorderThickness="0" FontSize="14"
                                Cursor="Hand" Click="BackToMethodSelection_Click"/>
                        <Button Content="Run Analysis" Padding="25,10"
                                Background="#4CAF50" Foreground="White" BorderThickness="0" FontSize="14"
                                Cursor="Hand" Click="RunAnalysis_Click"/>
                    </StackPanel>
                </Grid>
            </Border>

            <!-- Step 3: Results Panel -->
            <Border x:Name="ResultsPanel" Background="White" CornerRadius="8" Padding="20" Visibility="Collapsed">
                <Border.Effect>
                    <DropShadowEffect ShadowDepth="2" BlurRadius="10" Opacity="0.1"/>
                </Border.Effect>
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <TextBlock x:Name="ResultsTitle" Grid.Row="0" Text="Results" FontSize="16" FontWeight="SemiBold" 
                               Foreground="#333" Margin="0,0,0,10"/>

                    <!-- ?啣?: 銴ˊ?內 -->
                    <TextBlock Grid.Row="1" Text="? Tip: Select cells and press Ctrl+C to copy, or use the Copy Results button to copy all" 
                               Foreground="#666" FontSize="11" FontStyle="Italic" Margin="0,0,0,10"/>

                    <!-- 靽格: 瘛餃? SelectionUnit ??SelectionMode ?舀?桀??潮??-->
                    <DataGrid Grid.Row="2" x:Name="ResultsGrid" 
                              AutoGenerateColumns="True" IsReadOnly="True"
                              CanUserAddRows="False" CanUserDeleteRows="False"
                              GridLinesVisibility="All" Background="White"
                              HorizontalGridLinesBrush="#E0E0E0" VerticalGridLinesBrush="#E0E0E0"
                              AlternatingRowBackground="#FAFAFA"
                              SelectionUnit="CellOrRowHeader"
                              SelectionMode="Extended"
                              ClipboardCopyMode="IncludeHeader"
                              PreviewKeyDown="ResultsGrid_PreviewKeyDown"/>

                    <StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
                        <Button Content="??New Analysis" Margin="0,0,10,0" Padding="20,10"
                                Background="#FF9800" Foreground="White" BorderThickness="0" FontSize="14"
                                Cursor="Hand" Click="BackToMethodSelection_Click"/>
                        <Button Content="?? Copy Results" Padding="20,10"
                                Background="#4CAF50" Foreground="White" BorderThickness="0" FontSize="14"
                                Cursor="Hand" Click="CopyResults_Click"/>
                    </StackPanel>
                </Grid>
            </Border>
        </Grid>

        <!-- Footer -->
        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
            <Button Content="Close" Padding="20,10"
                    Background="#757575" Foreground="White" BorderThickness="0"
                    Cursor="Hand" Click="Close_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: StatisticsWindow.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\StatisticsWindow.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;

namespace BioSAK
{
    public partial class StatisticsWindow : Window
    {
        private List<ChartDataSeries> dataSeries;
        private List<double> allXValues = new List<double>();
        private string selectedMethod = "";
        private string chartType = ""; // "Column" or "MultiGroup"
        
        // Setup controls (dynamic)
        private ComboBox? xValueCombo;
        private ComboBox? series1Combo;
        private ComboBox? series2Combo;
        private ComboBox? singleSeriesCombo;
        private ListBox? multiSeriesListBox;
        private ListBox? multiXListBox;
        
        // T-Test controls
        private RadioButton? tTestModeAll;
        private RadioButton? tTestModeSelect;
        private CheckBox? tTestPairedCheck;
        private CheckBox? tTestAutoVarianceCheck;
        private ComboBox? tTestTailCombo;
        
        // One-Way ANOVA controls
        private CheckBox? anovaPostHocCheck;
        private ListBox? anovaPostHocGroupsListBox;
        
        // Two-Way ANOVA controls
        private CheckBox? twoWayIncludeInteraction;
        private ComboBox? twoWaySsTypeCombo;
        
        // X value to label mapping
        private Dictionary<double, string> xValueToLabel = new Dictionary<double, string>();

        public StatisticsWindow(List<ChartDataSeries> data, string chartType = "")
        {
            InitializeComponent();
            dataSeries = data;
            this.chartType = chartType;
            
            // Collect all unique X values
            allXValues = dataSeries
                .SelectMany(s => s.XValues)
                .Distinct()
                .OrderBy(x => x)
                .ToList();
            
            // Build X value to label mapping
            foreach (var series in dataSeries)
            {
                for (int i = 0; i < series.XValues.Count && i < series.XLabels.Count; i++)
                {
                    double xVal = series.XValues[i];
                    if (!xValueToLabel.ContainsKey(xVal) && !string.IsNullOrEmpty(series.XLabels[i]))
                    {
                        xValueToLabel[xVal] = series.XLabels[i];
                    }
                }
            }

            // Update UI based on chart type
            UpdateMethodDescriptions();
            MethodRegression.IsChecked = true;
        }
        
        /// <summary>
        /// Get display label for X value (uses text label if available, otherwise numeric)
        /// </summary>
        private string GetXLabel(double x)
        {
            if (xValueToLabel.TryGetValue(x, out string? label) && !string.IsNullOrEmpty(label))
                return label;
            return x.ToString("G6");
        }

        private void UpdateMethodDescriptions()
        {
            if (chartType == "Column")
            {
                // For Column chart, each series is a bar with replicates
                MethodRegression.Visibility = Visibility.Collapsed; // Not applicable for Column
                
                // Update T-Test description
                var tTestDesc = MethodTTest.Content as StackPanel;
                if (tTestDesc != null && tTestDesc.Children.Count > 1)
                {
                    ((TextBlock)tTestDesc.Children[1]).Text = "Compare two bars (columns) using their replicate data";
                }
                
                // Update ANOVA Same X description
                var anovaSameXDesc = MethodOneWayAnovaSameX.Content as StackPanel;
                if (anovaSameXDesc != null)
                {
                    ((TextBlock)anovaSameXDesc.Children[0]).Text = "?? One-Way ANOVA (Compare Bars)";
                    if (anovaSameXDesc.Children.Count > 1)
                        ((TextBlock)anovaSameXDesc.Children[1]).Text = "Compare multiple bars using their replicate data";
                }
                
                // Hide ANOVA Same Series (not applicable)
                MethodOneWayAnovaSameRow.Visibility = Visibility.Collapsed;
                MethodTwoWayAnova.Visibility = Visibility.Collapsed;
                
                // Update Descriptive
                var descDesc = MethodDescriptive.Content as StackPanel;
                if (descDesc != null && descDesc.Children.Count > 1)
                {
                    ((TextBlock)descDesc.Children[1]).Text = "Mean, SD, SEM, Min, Max, Median for each bar (column)";
                }
                
                // Set default selection to T-Test since Regression is hidden
                MethodTTest.IsChecked = true;
            }
            else if (chartType == "MultiGroup")
            {
                // For Multi Factors, update descriptions
                var anovaSameXDesc = MethodOneWayAnovaSameX.Content as StackPanel;
                if (anovaSameXDesc != null)
                {
                    ((TextBlock)anovaSameXDesc.Children[0]).Text = "?? One-Way ANOVA (Compare Groups at Same X)";
                }
                
                var anovaSameSeriesDesc = MethodOneWayAnovaSameRow.Content as StackPanel;
                if (anovaSameSeriesDesc != null)
                {
                    ((TextBlock)anovaSameSeriesDesc.Children[0]).Text = "?? One-Way ANOVA (Compare X Values in Same Group)";
                }
            }
        }

        #region Navigation

        private void NextToSetup_Click(object sender, RoutedEventArgs e)
        {
            // Determine which method is selected
            if (MethodRegression.IsChecked == true) selectedMethod = "Regression";
            else if (MethodTTest.IsChecked == true) selectedMethod = "TTest";
            else if (MethodOneWayAnovaSameX.IsChecked == true) selectedMethod = "ANOVA_SameX";
            else if (MethodOneWayAnovaSameRow.IsChecked == true) selectedMethod = "ANOVA_SameSeries";
            else if (MethodTwoWayAnova.IsChecked == true) selectedMethod = "TwoWayANOVA";
            else if (MethodDescriptive.IsChecked == true) selectedMethod = "Descriptive";
            else
            {
                MessageBox.Show("Please select a statistical method.", "Selection Required", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            // Build setup UI based on method
            BuildSetupUI();
            
            MethodSelectionPanel.Visibility = Visibility.Collapsed;
            SetupPanel.Visibility = Visibility.Visible;
        }

        private void BackToMethodSelection_Click(object sender, RoutedEventArgs e)
        {
            SetupPanel.Visibility = Visibility.Collapsed;
            ResultsPanel.Visibility = Visibility.Collapsed;
            MethodSelectionPanel.Visibility = Visibility.Visible;
        }

        private void Close_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        #endregion

        #region Build Setup UI

        private void BuildSetupUI()
        {
            SetupContent.Children.Clear();
            
            switch (selectedMethod)
            {
                case "Regression":
                    SetupTitle.Text = "Step 2: Linear Regression";
                    BuildRegressionSetup();
                    break;
                case "TTest":
                    SetupTitle.Text = "Step 2: T-Test Setup";
                    BuildTTestSetup();
                    break;
                case "ANOVA_SameX":
                    SetupTitle.Text = "Step 2: One-Way ANOVA (Compare Series at Same X)";
                    BuildAnovaSameXSetup();
                    break;
                case "ANOVA_SameSeries":
                    SetupTitle.Text = "Step 2: One-Way ANOVA (Compare X Values in Same Series)";
                    BuildAnovaSameSeriesSetup();
                    break;
                case "TwoWayANOVA":
                    SetupTitle.Text = "Step 2: Two-Way ANOVA Setup";
                    BuildTwoWayAnovaSetup();
                    break;
                case "Descriptive":
                    SetupTitle.Text = "Step 2: Descriptive Statistics";
                    BuildDescriptiveSetup();
                    break;
            }
        }

        private void BuildRegressionSetup()
        {
            var info = new TextBlock
            {
                Text = "Linear regression will be calculated for each series (X vs Y mean values).\n" +
                       "Results include: R簡, Pearson r, Slope, Intercept, and significance test for slope ??0.",
                TextWrapping = TextWrapping.Wrap,
                Foreground = new SolidColorBrush(Color.FromRgb(100, 100, 100)),
                Margin = new Thickness(0, 0, 0, 20)
            };
            SetupContent.Children.Add(info);

            var label = new TextBlock { Text = "Series to analyze:", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 0, 0, 10) };
            SetupContent.Children.Add(label);

            multiSeriesListBox = new ListBox { Height = 150, SelectionMode = SelectionMode.Multiple };
            foreach (var s in dataSeries)
            {
                var cb = new CheckBox { Content = s.Name, IsChecked = true, Margin = new Thickness(5) };
                multiSeriesListBox.Items.Add(cb);
            }
            SetupContent.Children.Add(multiSeriesListBox);
        }

        private void BuildTTestSetup()
        {
            var info = new TextBlock
            {
                Text = chartType == "Column" 
                    ? "Compare bars using their replicate data with t-test."
                    : "Compare series at a specific X value using their replicate data.",
                TextWrapping = TextWrapping.Wrap,
                Foreground = new SolidColorBrush(Color.FromRgb(100, 100, 100)),
                Margin = new Thickness(0, 0, 0, 15)
            };
            SetupContent.Children.Add(info);

            // === Comparison Mode ===
            var modeLabel = new TextBlock { Text = "Comparison Mode:", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 0, 0, 8) };
            SetupContent.Children.Add(modeLabel);

            tTestModeAll = new RadioButton 
            { 
                Content = "Compare all pairs", 
                GroupName = "TTestMode", 
                IsChecked = true,
                Margin = new Thickness(10, 0, 0, 5)
            };
            tTestModeAll.Checked += TTestMode_Changed;
            SetupContent.Children.Add(tTestModeAll);

            tTestModeSelect = new RadioButton 
            { 
                Content = "Select two groups to compare", 
                GroupName = "TTestMode",
                Margin = new Thickness(10, 0, 0, 10)
            };
            tTestModeSelect.Checked += TTestMode_Changed;
            SetupContent.Children.Add(tTestModeSelect);

            // === X Value Selection (for Multi Factors only) ===
            if (chartType != "Column")
            {
                AddLabelAndCombo("Select X value:", out xValueCombo, allXValues.Select(x => GetXLabel(x)).ToList());
            }

            // === Group Selection (for "all pairs" mode) ===
            var groupLabel = new TextBlock 
            { 
                Text = chartType == "Column" ? "Select Bars to compare:" : "Select Series to compare:", 
                FontWeight = FontWeights.SemiBold, 
                Margin = new Thickness(0, 10, 0, 8) 
            };
            SetupContent.Children.Add(groupLabel);

            multiSeriesListBox = new ListBox { Height = 120, SelectionMode = SelectionMode.Multiple };
            foreach (var s in dataSeries)
            {
                var cb = new CheckBox { Content = s.Name, IsChecked = true, Tag = s.Name, Margin = new Thickness(5) };
                multiSeriesListBox.Items.Add(cb);
            }
            SetupContent.Children.Add(multiSeriesListBox);

            // === Two-group selection (initially hidden) ===
            var selectPanel = new StackPanel { Tag = "SelectPanel", Visibility = Visibility.Collapsed };
            
            var label1 = new TextBlock { Text = chartType == "Column" ? "Bar 1:" : "Series 1:", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 10, 0, 5) };
            selectPanel.Children.Add(label1);
            series1Combo = new ComboBox { Width = 200, HorizontalAlignment = HorizontalAlignment.Left };
            foreach (var s in dataSeries) series1Combo.Items.Add(s.Name);
            if (series1Combo.Items.Count > 0) series1Combo.SelectedIndex = 0;
            selectPanel.Children.Add(series1Combo);

            var label2 = new TextBlock { Text = chartType == "Column" ? "Bar 2:" : "Series 2:", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 10, 0, 5) };
            selectPanel.Children.Add(label2);
            series2Combo = new ComboBox { Width = 200, HorizontalAlignment = HorizontalAlignment.Left };
            foreach (var s in dataSeries) series2Combo.Items.Add(s.Name);
            if (series2Combo.Items.Count > 1) series2Combo.SelectedIndex = 1;
            selectPanel.Children.Add(series2Combo);

            SetupContent.Children.Add(selectPanel);

            // === T-Test Parameters ===
            var paramLabel = new TextBlock { Text = "T-Test Parameters:", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 15, 0, 8) };
            SetupContent.Children.Add(paramLabel);

            var paramPanel = new StackPanel { Margin = new Thickness(10, 0, 0, 0) };

            // Paired option
            tTestPairedCheck = new CheckBox 
            { 
                Content = "Paired t-test", 
                IsChecked = false,
                Margin = new Thickness(0, 0, 0, 8),
                ToolTip = "Use when samples are related (e.g., before/after measurements on same subjects)"
            };
            paramPanel.Children.Add(tTestPairedCheck);

            // Auto variance check
            tTestAutoVarianceCheck = new CheckBox 
            { 
                Content = "Auto-detect variance equality (F-test, 帢=0.05)", 
                IsChecked = true,
                Margin = new Thickness(0, 0, 0, 8),
                ToolTip = "If checked: F-test p>0.05 ??Student's t-test, else ??Welch's t-test\nIf unchecked: always use Welch's t-test"
            };
            paramPanel.Children.Add(tTestAutoVarianceCheck);

            // Tail selection
            var tailPanel = new StackPanel { Orientation = Orientation.Horizontal, Margin = new Thickness(0, 0, 0, 5) };
            tailPanel.Children.Add(new TextBlock { Text = "Tail:", VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(0, 0, 10, 0) });
            tTestTailCombo = new ComboBox { Width = 150 };
            tTestTailCombo.Items.Add("Two-tailed");
            tTestTailCombo.Items.Add("One-tailed (Group 1>Group 2)");
            tTestTailCombo.Items.Add("One-tailed (Group 1<Group 2)");
            tTestTailCombo.SelectedIndex = 0;
            tailPanel.Children.Add(tTestTailCombo);
            paramPanel.Children.Add(tailPanel);

            SetupContent.Children.Add(paramPanel);

            // Update visibility based on mode
            UpdateTTestModeVisibility();
        }

        private void TTestMode_Changed(object sender, RoutedEventArgs e)
        {
            UpdateTTestModeVisibility();
        }

        private void UpdateTTestModeVisibility()
        {
            if (multiSeriesListBox == null) return;

            bool isAllMode = tTestModeAll?.IsChecked == true;

            // Show/hide group list vs two-group selection
            multiSeriesListBox.Visibility = isAllMode ? Visibility.Visible : Visibility.Collapsed;
            
            // Find and update SelectPanel visibility
            foreach (var child in SetupContent.Children)
            {
                if (child is StackPanel sp && sp.Tag?.ToString() == "SelectPanel")
                {
                    sp.Visibility = isAllMode ? Visibility.Collapsed : Visibility.Visible;
                }
            }

            // Update label above multiSeriesListBox
            int listIndex = SetupContent.Children.IndexOf(multiSeriesListBox);
            if (listIndex > 0 && SetupContent.Children[listIndex - 1] is TextBlock labelAbove)
            {
                labelAbove.Visibility = isAllMode ? Visibility.Visible : Visibility.Collapsed;
            }
        }

        private void BuildAnovaSameXSetup()
        {
            var info = new TextBlock
            {
                Text = chartType == "Column" 
                    ? "Compare multiple bars using One-Way ANOVA.\n" +
                      "Variance equality is auto-detected via Levene's test (帢=0.05).\n" +
                      "??Equal variances: Standard One-Way ANOVA\n" +
                      "??Unequal variances: Welch's ANOVA"
                    : "Compare multiple series at a specific X value using One-Way ANOVA.\n" +
                      "Variance equality is auto-detected via Levene's test.",
                TextWrapping = TextWrapping.Wrap,
                Foreground = new SolidColorBrush(Color.FromRgb(100, 100, 100)),
                Margin = new Thickness(0, 0, 0, 15)
            };
            SetupContent.Children.Add(info);

            // X value selection (for Multi Factors only)
            if (chartType != "Column")
            {
                AddLabelAndCombo("Select X value:", out xValueCombo, allXValues.Select(x => GetXLabel(x)).ToList());
            }

            // Group selection
            var groupLabel = new TextBlock 
            { 
                Text = chartType == "Column" ? "Select Bars to compare (at least 3):" : "Select Series to compare (at least 3):", 
                FontWeight = FontWeights.SemiBold, 
                Margin = new Thickness(0, 10, 0, 8) 
            };
            SetupContent.Children.Add(groupLabel);

            multiSeriesListBox = new ListBox { Height = 120, SelectionMode = SelectionMode.Multiple };
            foreach (var s in dataSeries)
            {
                var cb = new CheckBox { Content = s.Name, IsChecked = true, Tag = s.Name, Margin = new Thickness(5) };
                multiSeriesListBox.Items.Add(cb);
            }
            SetupContent.Children.Add(multiSeriesListBox);

            // Post-hoc test options
            var postHocLabel = new TextBlock { Text = "Post-hoc Tests:", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 15, 0, 8) };
            SetupContent.Children.Add(postHocLabel);

            anovaPostHocCheck = new CheckBox 
            { 
                Content = "Perform post-hoc pairwise comparisons", 
                IsChecked = true,
                Margin = new Thickness(10, 0, 0, 5),
                ToolTip = "If equal variances: Tukey's HSD\nIf unequal variances: Games-Howell"
            };
            anovaPostHocCheck.Checked += AnovaPostHocCheck_Changed;
            anovaPostHocCheck.Unchecked += AnovaPostHocCheck_Changed;
            SetupContent.Children.Add(anovaPostHocCheck);

            var postHocInfo = new TextBlock
            {
                Text = "Post-hoc method is auto-selected based on Levene's test:\n" +
                       "??Levene's p > 0.05 ??Tukey's HSD\n" +
                       "??Levene's p ??0.05 ??Games-Howell",
                TextWrapping = TextWrapping.Wrap,
                Foreground = new SolidColorBrush(Color.FromRgb(120, 120, 120)),
                FontSize = 11,
                Margin = new Thickness(25, 0, 0, 10)
            };
            SetupContent.Children.Add(postHocInfo);

            // Post-hoc group selection
            var postHocGroupLabel = new TextBlock 
            { 
                Text = "Select groups for post-hoc (or leave all checked for all pairs):", 
                Margin = new Thickness(10, 5, 0, 5),
                Foreground = new SolidColorBrush(Color.FromRgb(80, 80, 80))
            };
            SetupContent.Children.Add(postHocGroupLabel);

            anovaPostHocGroupsListBox = new ListBox { Height = 100, SelectionMode = SelectionMode.Multiple, Margin = new Thickness(10, 0, 0, 0) };
            foreach (var s in dataSeries)
            {
                var cb = new CheckBox { Content = s.Name, IsChecked = true, Tag = s.Name, Margin = new Thickness(5) };
                anovaPostHocGroupsListBox.Items.Add(cb);
            }
            SetupContent.Children.Add(anovaPostHocGroupsListBox);
        }

        private void AnovaPostHocCheck_Changed(object sender, RoutedEventArgs e)
        {
            if (anovaPostHocGroupsListBox != null)
            {
                anovaPostHocGroupsListBox.IsEnabled = anovaPostHocCheck?.IsChecked == true;
            }
        }

        private void BuildAnovaSameSeriesSetup()
        {
            var info = new TextBlock
            {
                Text = "Compare different X values within one series.\n" +
                       "Uses replicate data at each selected X point.\n" +
                       "Variance equality is auto-detected via Levene's test.",
                TextWrapping = TextWrapping.Wrap,
                Foreground = new SolidColorBrush(Color.FromRgb(100, 100, 100)),
                Margin = new Thickness(0, 0, 0, 15)
            };
            SetupContent.Children.Add(info);

            // Series selection
            AddLabelAndCombo("Select Series:", out singleSeriesCombo, dataSeries.Select(s => s.Name).ToList());

            // X values selection (multiple)
            var label = new TextBlock { Text = "Select X values to compare (at least 3):", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 15, 0, 8) };
            SetupContent.Children.Add(label);

            multiXListBox = new ListBox { Height = 120, SelectionMode = SelectionMode.Multiple };
            foreach (var x in allXValues)
            {
                var cb = new CheckBox { Content = GetXLabel(x), IsChecked = true, Tag = x, Margin = new Thickness(5) };
                multiXListBox.Items.Add(cb);
            }
            SetupContent.Children.Add(multiXListBox);

            // Post-hoc test options
            var postHocLabel = new TextBlock { Text = "Post-hoc Tests:", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 15, 0, 8) };
            SetupContent.Children.Add(postHocLabel);

            anovaPostHocCheck = new CheckBox 
            { 
                Content = "Perform post-hoc pairwise comparisons", 
                IsChecked = true,
                Margin = new Thickness(10, 0, 0, 5),
                ToolTip = "If equal variances: Tukey's HSD\nIf unequal variances: Games-Howell"
            };
            SetupContent.Children.Add(anovaPostHocCheck);
        }

        private void BuildTwoWayAnovaSetup()
        {
            var info = new TextBlock
            {
                Text = "Two-Way ANOVA analyzes:\n" +
                       "??Main effect of Series (Factor A)\n" +
                       "??Main effect of X value (Factor B)\n" +
                       "??Interaction between Series ? X (optional)\n\n" +
                       "Requires multiple series and multiple X values with replicates.",
                TextWrapping = TextWrapping.Wrap,
                Foreground = new SolidColorBrush(Color.FromRgb(100, 100, 100)),
                Margin = new Thickness(0, 0, 0, 15)
            };
            SetupContent.Children.Add(info);

            // Series selection
            var label1 = new TextBlock { Text = "Select Series (Factor A, at least 2):", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 0, 0, 8) };
            SetupContent.Children.Add(label1);

            multiSeriesListBox = new ListBox { Height = 100, SelectionMode = SelectionMode.Multiple };
            foreach (var s in dataSeries)
            {
                var cb = new CheckBox { Content = s.Name, IsChecked = true, Tag = s.Name, Margin = new Thickness(5) };
                multiSeriesListBox.Items.Add(cb);
            }
            SetupContent.Children.Add(multiSeriesListBox);

            // X values selection
            var label2 = new TextBlock { Text = "Select X values (Factor B, at least 2):", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 12, 0, 8) };
            SetupContent.Children.Add(label2);

            multiXListBox = new ListBox { Height = 100, SelectionMode = SelectionMode.Multiple };
            foreach (var x in allXValues)
            {
                var cb = new CheckBox { Content = GetXLabel(x), IsChecked = true, Tag = x, Margin = new Thickness(5) };
                multiXListBox.Items.Add(cb);
            }
            SetupContent.Children.Add(multiXListBox);

            // ANOVA Options
            var optLabel = new TextBlock { Text = "ANOVA Options:", FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 15, 0, 8) };
            SetupContent.Children.Add(optLabel);

            var optPanel = new StackPanel { Margin = new Thickness(10, 0, 0, 0) };

            // Include interaction
            twoWayIncludeInteraction = new CheckBox 
            { 
                Content = "Include interaction term (A ? B)", 
                IsChecked = true,
                Margin = new Thickness(0, 0, 0, 10),
                ToolTip = "If checked, tests whether the effect of Factor A depends on Factor B"
            };
            optPanel.Children.Add(twoWayIncludeInteraction);

            // Sum of Squares Type
            var ssPanel = new StackPanel { Orientation = Orientation.Horizontal, Margin = new Thickness(0, 0, 0, 10) };
            ssPanel.Children.Add(new TextBlock 
            { 
                Text = "Sum of Squares Type:", 
                VerticalAlignment = VerticalAlignment.Center, 
                Margin = new Thickness(0, 0, 10, 0) 
            });
            
            twoWaySsTypeCombo = new ComboBox { Width = 180 };
            twoWaySsTypeCombo.Items.Add("Type III (Marginal) - Default");
            twoWaySsTypeCombo.Items.Add("Type I (Sequential)");
            twoWaySsTypeCombo.Items.Add("Type II (Hierarchical)");
            twoWaySsTypeCombo.SelectedIndex = 0;
            twoWaySsTypeCombo.ToolTip = "Type I: Sequential - order matters\n" +
                                        "Type II: Hierarchical - each effect adjusted for others at same level\n" +
                                        "Type III: Marginal - each effect adjusted for all others (recommended for unbalanced designs)";
            ssPanel.Children.Add(twoWaySsTypeCombo);
            optPanel.Children.Add(ssPanel);

            SetupContent.Children.Add(optPanel);

            // Post-hoc explanation
            var postHocInfo = new TextBlock
            {
                Text = "Post-hoc Tests (auto-performed):\n" +
                       "??If interaction p < 0.05: Simple Main Effects analysis\n" +
                       "??If interaction p ??0.05: Main Effects pairwise comparisons",
                TextWrapping = TextWrapping.Wrap,
                Foreground = new SolidColorBrush(Color.FromRgb(100, 100, 100)),
                FontSize = 11,
                Margin = new Thickness(0, 10, 0, 0)
            };
            SetupContent.Children.Add(postHocInfo);
        }

        private void BuildDescriptiveSetup()
        {
            string infoText = chartType == "Column" 
                ? "Calculate descriptive statistics for each bar (column).\n" +
                  "Uses all replicate values for each bar.\n" +
                  "Includes: N, Mean, SD, SEM, Min, Max, Median, 95% CI."
                : "Calculate descriptive statistics for each series.\n" +
                  "Includes: N, Mean, SD, SEM, Min, Max, Median, 95% CI.";
            
            var info = new TextBlock
            {
                Text = infoText,
                TextWrapping = TextWrapping.Wrap,
                Foreground = new SolidColorBrush(Color.FromRgb(100, 100, 100)),
                Margin = new Thickness(0, 0, 0, 20)
            };
            SetupContent.Children.Add(info);

            string labelText = chartType == "Column" ? "Bars to analyze:" : "Series to analyze:";
            var label = new TextBlock { Text = labelText, FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 0, 0, 10) };
            SetupContent.Children.Add(label);

            multiSeriesListBox = new ListBox { Height = 180, SelectionMode = SelectionMode.Multiple };
            foreach (var s in dataSeries)
            {
                var cb = new CheckBox { Content = s.Name, IsChecked = true, Margin = new Thickness(5) };
                multiSeriesListBox.Items.Add(cb);
            }
            SetupContent.Children.Add(multiSeriesListBox);
        }

        private void AddLabelAndCombo(string labelText, out ComboBox combo, List<string> items)
        {
            var label = new TextBlock { Text = labelText, FontWeight = FontWeights.SemiBold, Margin = new Thickness(0, 10, 0, 5) };
            SetupContent.Children.Add(label);

            combo = new ComboBox { Width = 200, HorizontalAlignment = HorizontalAlignment.Left };
            foreach (var item in items) combo.Items.Add(item);
            if (combo.Items.Count > 0) combo.SelectedIndex = 0;
            SetupContent.Children.Add(combo);
        }

        #endregion

        #region Run Analysis

        private void RunAnalysis_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                DataTable? results = null;

                switch (selectedMethod)
                {
                    case "Regression":
                        results = RunRegression();
                        ResultsTitle.Text = "?? Linear Regression Results";
                        break;
                    case "TTest":
                        results = RunTTest();
                        ResultsTitle.Text = "? T-Test Results";
                        break;
                    case "ANOVA_SameX":
                        results = RunAnovaSameX();
                        ResultsTitle.Text = "?? One-Way ANOVA Results (Same X)";
                        break;
                    case "ANOVA_SameSeries":
                        results = RunAnovaSameSeries();
                        ResultsTitle.Text = "?? One-Way ANOVA Results (Same Series)";
                        break;
                    case "TwoWayANOVA":
                        results = RunTwoWayAnova();
                        ResultsTitle.Text = "?? Two-Way ANOVA Results";
                        break;
                    case "Descriptive":
                        results = RunDescriptive();
                        ResultsTitle.Text = "?? Descriptive Statistics";
                        break;
                }

                if (results != null && results.Rows.Count > 0)
                {
                    ResultsGrid.AutoGenerateColumns = true;
                    ResultsGrid.ItemsSource = results.DefaultView;
                    
                    SetupPanel.Visibility = Visibility.Collapsed;
                    ResultsPanel.Visibility = Visibility.Visible;
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Analysis error: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #endregion

        #region Statistical Methods

        private DataTable RunRegression()
        {
            var dt = new DataTable();
            dt.Columns.Add("Series", typeof(string));
            dt.Columns.Add("N", typeof(int));
            dt.Columns.Add("R簡", typeof(string));
            dt.Columns.Add("Pearson r", typeof(string));
            dt.Columns.Add("Slope", typeof(string));
            dt.Columns.Add("Intercept", typeof(string));
            dt.Columns.Add("SE(slope)", typeof(string));
            dt.Columns.Add("t-value", typeof(string));
            dt.Columns.Add("p-value", typeof(string));
            dt.Columns.Add("Sig.", typeof(string));

            var selectedSeries = GetSelectedSeriesFromListBox(multiSeriesListBox);

            foreach (var series in selectedSeries)
            {
                int n = Math.Min(series.XValues.Count, series.YValues.Count);
                if (n < 2) continue;

                var x = series.XValues.Take(n).ToList();
                var y = series.YValues.Take(n).ToList();

                double xMean = x.Average(), yMean = y.Average();
                double ssxy = 0, ssxx = 0, ssyy = 0;

                for (int i = 0; i < n; i++)
                {
                    ssxy += (x[i] - xMean) * (y[i] - yMean);
                    ssxx += Math.Pow(x[i] - xMean, 2);
                    ssyy += Math.Pow(y[i] - yMean, 2);
                }

                if (ssxx < 1e-10) continue;

                double slope = ssxy / ssxx;
                double intercept = yMean - slope * xMean;
                double rSquared = ssyy > 0 ? Math.Pow(ssxy, 2) / (ssxx * ssyy) : 0;
                double pearsonR = ssyy > 0 ? ssxy / Math.Sqrt(ssxx * ssyy) : 0;

                double ssRes = 0;
                for (int i = 0; i < n; i++)
                    ssRes += Math.Pow(y[i] - (slope * x[i] + intercept), 2);

                double mse = n > 2 ? ssRes / (n - 2) : 0;
                double seSlope = Math.Sqrt(mse / ssxx);
                double tValue = seSlope > 1e-10 ? slope / seSlope : 0;
                double pValue = CalculateTwoTailedTPValue(Math.Abs(tValue), n - 2);

                dt.Rows.Add(series.Name, n, rSquared.ToString("F4"), pearsonR.ToString("F4"),
                    slope.ToString("F4"), intercept.ToString("F4"), seSlope.ToString("F4"),
                    tValue.ToString("F3"), FormatPValue(pValue), GetSig(pValue));
            }

            return dt;
        }

        private DataTable RunTTest()
        {
            var dt = new DataTable();
            
            bool isAllPairs = tTestModeAll?.IsChecked == true;
            bool isPaired = tTestPairedCheck?.IsChecked == true;
            bool autoVariance = tTestAutoVarianceCheck?.IsChecked == true;
            int tailType = tTestTailCombo?.SelectedIndex ?? 0; // 0=two-tailed, 1=one-tailed(>), 2=one-tailed(<)

            // Setup columns
            if (chartType != "Column")
            {
                dt.Columns.Add("X Value", typeof(string));
            }
            dt.Columns.Add("Group 1", typeof(string));
            dt.Columns.Add("N??, typeof(int));
            dt.Columns.Add("Mean??, typeof(string));
            dt.Columns.Add("SD??, typeof(string));
            dt.Columns.Add("Group 2", typeof(string));
            dt.Columns.Add("N??, typeof(int));
            dt.Columns.Add("Mean??, typeof(string));
            dt.Columns.Add("SD??, typeof(string));
            dt.Columns.Add("Test Type", typeof(string));
            dt.Columns.Add("t", typeof(string));
            dt.Columns.Add("df", typeof(string));
            dt.Columns.Add("p-value", typeof(string));
            dt.Columns.Add("Sig.", typeof(string));

            // Get X value for Multi Factors
            double xVal = 0;
            if (chartType != "Column")
            {
                if (xValueCombo?.SelectedIndex < 0)
                {
                    MessageBox.Show("Please select an X value.", "Selection Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return dt;
                }
                xVal = allXValues[xValueCombo!.SelectedIndex];
            }

            // Get groups to compare
            List<(string name, List<double> data)> groups = new List<(string, List<double>)>();

            if (isAllPairs)
            {
                var selectedSeries = GetSelectedSeriesFromListBox(multiSeriesListBox);
                if (selectedSeries.Count < 2)
                {
                    MessageBox.Show("Please select at least 2 groups.", "Selection Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return dt;
                }

                foreach (var s in selectedSeries)
                {
                    var data = chartType == "Column" ? GetAllReplicatesForSeries(s) : GetReplicatesAtX(s, xVal);
                    if (data.Count >= 2)
                    {
                        groups.Add((s.Name, data));
                    }
                }
            }
            else
            {
                // Select two mode
                if (series1Combo?.SelectedIndex < 0 || series2Combo?.SelectedIndex < 0)
                {
                    MessageBox.Show("Please select both groups.", "Selection Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return dt;
                }

                if (series1Combo!.SelectedIndex == series2Combo!.SelectedIndex)
                {
                    MessageBox.Show("Please select two different groups.", "Selection Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return dt;
                }

                var s1 = dataSeries[series1Combo.SelectedIndex];
                var s2 = dataSeries[series2Combo.SelectedIndex];

                var data1 = chartType == "Column" ? GetAllReplicatesForSeries(s1) : GetReplicatesAtX(s1, xVal);
                var data2 = chartType == "Column" ? GetAllReplicatesForSeries(s2) : GetReplicatesAtX(s2, xVal);

                groups.Add((s1.Name, data1));
                groups.Add((s2.Name, data2));
            }

            if (groups.Count < 2)
            {
                MessageBox.Show("Need at least 2 groups with sufficient data.", "Insufficient Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                return dt;
            }

            // Perform t-tests for all pairs
            for (int i = 0; i < groups.Count; i++)
            {
                for (int j = i + 1; j < groups.Count; j++)
                {
                    var g1 = groups[i];
                    var g2 = groups[j];

                    if (g1.data.Count < 2 || g2.data.Count < 2)
                        continue;

                    // Check for paired t-test requirements
                    if (isPaired && g1.data.Count != g2.data.Count)
                    {
                        // Skip this pair if paired is selected but counts don't match
                        var row = dt.NewRow();
                        if (chartType != "Column") row["X Value"] = GetXLabel(xVal);
                        row["Group 1"] = g1.name;
                        row["N??] = g1.data.Count;
                        row["Mean??] = g1.data.Average().ToString("F4");
                        row["SD??] = CalcSD(g1.data).ToString("F4");
                        row["Group 2"] = g2.name;
                        row["N??] = g2.data.Count;
                        row["Mean??] = g2.data.Average().ToString("F4");
                        row["SD??] = CalcSD(g2.data).ToString("F4");
                        row["Test Type"] = "N/A";
                        row["t"] = "-";
                        row["df"] = "-";
                        row["p-value"] = "N? (paired requires equal N)";
                        row["Sig."] = "-";
                        dt.Rows.Add(row);
                        continue;
                    }

                    string testType;
                    double t, df, p;

                    if (isPaired)
                    {
                        // Paired t-test
                        (t, df, p) = PairedTTest(g1.data, g2.data);
                        testType = "Paired";
                    }
                    else
                    {
                        // Independent t-test - check variance equality if auto
                        bool useWelch = true;
                        string varianceNote = "";

                        if (autoVariance)
                        {
                            var (fStat, fP) = FTestForVarianceEquality(g1.data, g2.data);
                            useWelch = fP <= 0.05; // Use Welch if variances are unequal
                            varianceNote = fP > 0.05 ? " (F-test p=" + fP.ToString("F3") + ", equal var)" 
                                                     : " (F-test p=" + fP.ToString("F3") + ", unequal var)";
                        }

                        if (useWelch)
                        {
                            (t, df, p) = WelchTTest(g1.data, g2.data);
                            testType = "Welch" + (autoVariance ? varianceNote : "");
                        }
                        else
                        {
                            (t, df, p) = StudentTTest(g1.data, g2.data);
                            testType = "Student" + varianceNote;
                        }
                    }

                    // Adjust p-value for one-tailed test
                    double pDisplay = p;
                    if (tailType == 1) // One-tailed (>)
                    {
                        pDisplay = t > 0 ? p / 2 : 1 - p / 2;
                        testType += ", 1-tail(>)";
                    }
                    else if (tailType == 2) // One-tailed (<)
                    {
                        pDisplay = t < 0 ? p / 2 : 1 - p / 2;
                        testType += ", 1-tail(<)";
                    }
                    else
                    {
                        testType += ", 2-tail";
                    }

                    var dataRow = dt.NewRow();
                    if (chartType != "Column") dataRow["X Value"] = GetXLabel(xVal);
                    dataRow["Group 1"] = g1.name;
                    dataRow["N??] = g1.data.Count;
                    dataRow["Mean??] = g1.data.Average().ToString("F4");
                    dataRow["SD??] = CalcSD(g1.data).ToString("F4");
                    dataRow["Group 2"] = g2.name;
                    dataRow["N??] = g2.data.Count;
                    dataRow["Mean??] = g2.data.Average().ToString("F4");
                    dataRow["SD??] = CalcSD(g2.data).ToString("F4");
                    dataRow["Test Type"] = testType;
                    dataRow["t"] = t.ToString("F4");
                    dataRow["df"] = df.ToString("F1");
                    dataRow["p-value"] = FormatPValue(pDisplay);
                    dataRow["Sig."] = GetSig(pDisplay);
                    dt.Rows.Add(dataRow);
                }
            }

            return dt;
        }

        /// <summary>
        /// Paired t-test for dependent samples
        /// </summary>
        private (double t, double df, double p) PairedTTest(List<double> g1, List<double> g2)
        {
            int n = Math.Min(g1.Count, g2.Count);
            if (n < 2) return (0, 0, 1);

            var diffs = new List<double>();
            for (int i = 0; i < n; i++)
                diffs.Add(g1[i] - g2[i]);

            double meanD = diffs.Average();
            double sdD = CalcSD(diffs);
            double seD = sdD / Math.Sqrt(n);

            if (seD < 1e-10) return (0, n - 1, 1);

            double t = meanD / seD;
            double df = n - 1;
            double p = CalculateTwoTailedTPValue(Math.Abs(t), df);

            return (t, df, p);
        }

        /// <summary>
        /// Student's t-test (assumes equal variances)
        /// </summary>
        private (double t, double df, double p) StudentTTest(List<double> g1, List<double> g2)
        {
            double m1 = g1.Average(), m2 = g2.Average();
            int n1 = g1.Count, n2 = g2.Count;
            double df = n1 + n2 - 2;

            // Pooled variance
            double ss1 = g1.Sum(v => Math.Pow(v - m1, 2));
            double ss2 = g2.Sum(v => Math.Pow(v - m2, 2));
            double pooledVar = (ss1 + ss2) / df;

            double se = Math.Sqrt(pooledVar * (1.0 / n1 + 1.0 / n2));
            if (se < 1e-10) return (0, df, 1);

            double t = (m1 - m2) / se;
            double p = CalculateTwoTailedTPValue(Math.Abs(t), df);

            return (t, df, p);
        }

        /// <summary>
        /// F-test for equality of variances
        /// </summary>
        private (double f, double p) FTestForVarianceEquality(List<double> g1, List<double> g2)
        {
            double v1 = CalcVar(g1);
            double v2 = CalcVar(g2);

            if (v2 < 1e-10 && v1 < 1e-10) return (1, 1); // Both have zero variance
            if (v2 < 1e-10) return (double.PositiveInfinity, 0);
            if (v1 < 1e-10) return (0, 0);

            // F is ratio of larger to smaller variance
            double f = v1 >= v2 ? v1 / v2 : v2 / v1;
            int df1 = v1 >= v2 ? g1.Count - 1 : g2.Count - 1;
            int df2 = v1 >= v2 ? g2.Count - 1 : g1.Count - 1;

            // Two-tailed F-test p-value
            double p = 2 * CalculateFPValue(f, df1, df2);
            if (p > 1) p = 1;

            return (f, p);
        }

        private DataTable RunAnovaSameX()
        {
            var dt = new DataTable();

            var selectedSeries = GetSelectedSeriesFromListBox(multiSeriesListBox);
            if (selectedSeries.Count < 2)
            {
                MessageBox.Show("Please select at least 2 groups.", "Selection Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                return dt;
            }

            // Collect replicate data from each series
            var groups = new List<List<double>>();
            var groupNames = new List<string>();

            if (chartType == "Column")
            {
                foreach (var s in selectedSeries)
                {
                    var reps = GetAllReplicatesForSeries(s);
                    if (reps.Count > 0)
                    {
                        groups.Add(reps);
                        groupNames.Add(s.Name);
                    }
                }
            }
            else
            {
                if (xValueCombo?.SelectedIndex < 0)
                {
                    MessageBox.Show("Please select an X value.", "Selection Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return dt;
                }

                double xVal = allXValues[xValueCombo!.SelectedIndex];

                foreach (var s in selectedSeries)
                {
                    var reps = GetReplicatesAtX(s, xVal);
                    if (reps.Count > 0)
                    {
                        groups.Add(reps);
                        groupNames.Add(s.Name);
                    }
                }
            }

            if (groups.Count < 2)
            {
                MessageBox.Show("Need data from at least 2 groups.", "Insufficient Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                return dt;
            }

            // Levene's test for homogeneity of variances
            var (leveneF, leveneP) = LevenesTest(groups);
            bool equalVariances = leveneP > 0.05 || double.IsNaN(leveneP);

            // Setup columns
            dt.Columns.Add("Source", typeof(string));
            dt.Columns.Add("SS", typeof(string));
            dt.Columns.Add("df", typeof(string));
            dt.Columns.Add("MS", typeof(string));
            dt.Columns.Add("F", typeof(string));
            dt.Columns.Add("p-value", typeof(string));
            dt.Columns.Add("Sig.", typeof(string));

            string anovaType;
            double f, p;
            int dfBetween, dfWithin;
            double ssBetween, ssWithin, ssTotal;

            if (equalVariances)
            {
                // Standard One-Way ANOVA
                anovaType = "Standard One-Way ANOVA";
                var result = CalculateOneWayAnova(groups);
                ssBetween = result.ssBetween;
                ssWithin = result.ssWithin;
                ssTotal = result.ssTotal;
                dfBetween = result.dfBetween;
                dfWithin = result.dfWithin;
                f = result.f;
                p = result.p;

                dt.Rows.Add($"ANOVA Type: {anovaType}", "", "", "", "", "", "");
                dt.Rows.Add($"Levene's Test: F={leveneF:F3}, p={FormatPValue(leveneP)} (Equal variances assumed)", "", "", "", "", "", "");
                dt.Rows.Add("", "", "", "", "", "", "");
                dt.Rows.Add("Between Groups", ssBetween.ToString("F4"), dfBetween.ToString(), 
                    (ssBetween / dfBetween).ToString("F4"), f.ToString("F4"), FormatPValue(p), GetSig(p));
                dt.Rows.Add("Within Groups", ssWithin.ToString("F4"), dfWithin.ToString(), 
                    (dfWithin > 0 ? ssWithin / dfWithin : 0).ToString("F4"), "-", "-", "-");
                dt.Rows.Add("Total", ssTotal.ToString("F4"), (dfBetween + dfWithin).ToString(), "-", "-", "-", "-");
            }
            else
            {
                // Welch's ANOVA
                anovaType = "Welch's ANOVA";
                var (welchF, welchDf1, welchDf2, welchP) = WelchsAnova(groups);
                f = welchF;
                p = welchP;
                dfBetween = (int)welchDf1;

                dt.Rows.Add($"ANOVA Type: {anovaType}", "", "", "", "", "", "");
                dt.Rows.Add($"Levene's Test: F={leveneF:F3}, p={FormatPValue(leveneP)} (Unequal variances)", "", "", "", "", "", "");
                dt.Rows.Add("", "", "", "", "", "", "");
                dt.Rows.Add("Welch's F", "-", $"{welchDf1:F1}, {welchDf2:F1}", "-", f.ToString("F4"), FormatPValue(p), GetSig(p));
            }

            // Group Summary
            dt.Rows.Add("", "", "", "", "", "", "");
            dt.Rows.Add("Group Summary:", "", "", "", "", "", "");
            for (int i = 0; i < groups.Count; i++)
            {
                dt.Rows.Add($"  {groupNames[i]}", $"N={groups[i].Count}", "", 
                    $"Mean={groups[i].Average():F4}", $"SD={CalcSD(groups[i]):F4}", "", "");
            }

            // Post-hoc tests if requested
            if (anovaPostHocCheck?.IsChecked == true)
            {
                dt.Rows.Add("", "", "", "", "", "", "");
                
                // Get selected groups for post-hoc
                var postHocGroups = GetSelectedSeriesNamesFromListBox(anovaPostHocGroupsListBox);
                if (postHocGroups.Count == 0) postHocGroups = groupNames;

                // Warning if ANOVA not significant
                if (p >= 0.05)
                {
                    dt.Rows.Add("Note: ANOVA p ??0.05; post-hoc results should be interpreted with caution.", "", "", "", "", "", "");
                    dt.Rows.Add("", "", "", "", "", "", "");
                }

                if (equalVariances)
                {
                    // Tukey's HSD
                    dt.Rows.Add("Post-hoc: Tukey's HSD (equal variances)", "", "", "", "", "", "");
                    dt.Rows.Add("Comparison", "Mean Diff", "", "SE", "q", "p-value", "Sig.");
                    var tukeyResults = TukeyHSD(groups, groupNames, postHocGroups);
                    if (tukeyResults.Count == 0)
                    {
                        dt.Rows.Add("  No comparisons (select at least 2 groups)", "", "", "", "", "", "");
                    }
                    else
                    {
                        foreach (var row in tukeyResults)
                        {
                            dt.Rows.Add($"  {row.comparison}", row.meanDiff, "", row.se, row.q, FormatPValue(row.p), GetSig(row.p));
                        }
                    }
                }
                else
                {
                    // Games-Howell
                    dt.Rows.Add("Post-hoc: Games-Howell (unequal variances)", "", "", "", "", "", "");
                    dt.Rows.Add("Comparison", "Mean Diff", "df", "SE", "t", "p-value", "Sig.");
                    var ghResults = GamesHowell(groups, groupNames, postHocGroups);
                    if (ghResults.Count == 0)
                    {
                        dt.Rows.Add("  No comparisons (select at least 2 groups)", "", "", "", "", "", "");
                    }
                    else
                    {
                        foreach (var row in ghResults)
                        {
                            dt.Rows.Add($"  {row.comparison}", row.meanDiff, row.df, row.se, row.t, FormatPValue(row.p), GetSig(row.p));
                        }
                    }
                }
            }

            return dt;
        }

        /// <summary>
        /// Levene's test for homogeneity of variances
        /// </summary>
        private (double f, double p) LevenesTest(List<List<double>> groups)
        {
            if (groups.Count < 2) return (double.NaN, double.NaN);

            // Calculate absolute deviations from group medians
            var deviations = new List<List<double>>();
            foreach (var g in groups)
            {
                if (g.Count == 0) return (double.NaN, double.NaN);
                double median = CalcMedian(g);
                deviations.Add(g.Select(x => Math.Abs(x - median)).ToList());
            }

            // Perform ANOVA on deviations
            var result = CalculateOneWayAnova(deviations);
            return (result.f, result.p);
        }

        /// <summary>
        /// Welch's ANOVA for unequal variances
        /// </summary>
        private (double f, double df1, double df2, double p) WelchsAnova(List<List<double>> groups)
        {
            int k = groups.Count;
            var weights = new double[k];
            var means = new double[k];
            var vars = new double[k];
            var ns = new int[k];

            for (int i = 0; i < k; i++)
            {
                ns[i] = groups[i].Count;
                means[i] = groups[i].Average();
                vars[i] = CalcVar(groups[i]);
                weights[i] = vars[i] > 1e-10 ? ns[i] / vars[i] : ns[i] * 1e10;
            }

            double sumWeights = weights.Sum();
            double grandMean = 0;
            for (int i = 0; i < k; i++)
                grandMean += weights[i] * means[i];
            grandMean /= sumWeights;

            // Welch's F
            double numerator = 0;
            for (int i = 0; i < k; i++)
                numerator += weights[i] * Math.Pow(means[i] - grandMean, 2);
            numerator /= (k - 1);

            double lambda = 0;
            for (int i = 0; i < k; i++)
            {
                double wi = weights[i] / sumWeights;
                lambda += Math.Pow(1 - wi, 2) / (ns[i] - 1);
            }
            lambda *= 3.0 / (k * k - 1);

            double denominator = 1 + 2 * (k - 2) * lambda / (k * k - 1);
            double f = numerator / denominator;

            // Degrees of freedom
            double df1 = k - 1;
            double df2 = 1 / lambda;

            double p = CalculateFPValue(f, (int)Math.Round(df1), (int)Math.Round(df2));
            return (f, df1, df2, p);
        }

        /// <summary>
        /// Tukey's HSD post-hoc test
        /// </summary>
        private List<(string comparison, string meanDiff, string se, string q, double p)> TukeyHSD(
            List<List<double>> groups, List<string> names, List<string> selectedNames)
        {
            var results = new List<(string, string, string, string, double)>();
            
            if (groups.Count < 2) return results;
            
            // Calculate MSE
            var allData = groups.SelectMany(g => g).ToList();
            int totalN = allData.Count;
            int k = groups.Count;
            
            if (totalN <= k) return results;
            
            double mse = groups.Sum(g => g.Sum(v => Math.Pow(v - g.Average(), 2))) / (totalN - k);

            for (int i = 0; i < groups.Count; i++)
            {
                for (int j = i + 1; j < groups.Count; j++)
                {
                    // Include pair if either group is in selected list, or if all groups selected
                    bool includeI = selectedNames.Count == 0 || selectedNames.Contains(names[i]);
                    bool includeJ = selectedNames.Count == 0 || selectedNames.Contains(names[j]);
                    
                    if (!includeI && !includeJ)
                        continue;

                    double meanDiff = groups[i].Average() - groups[j].Average();
                    double se = Math.Sqrt(mse * (1.0 / groups[i].Count + 1.0 / groups[j].Count) / 2);
                    double q = se > 1e-10 ? Math.Abs(meanDiff) / se : 0;
                    
                    // Approximate p-value using studentized range distribution
                    double pVal = CalculateTukeyP(q, k, totalN - k);

                    results.Add(($"{names[i]} vs {names[j]}", meanDiff.ToString("F4"), se.ToString("F4"), q.ToString("F4"), pVal));
                }
            }
            return results;
        }

        /// <summary>
        /// Games-Howell post-hoc test for unequal variances
        /// </summary>
        private List<(string comparison, string meanDiff, string df, string se, string t, double p)> GamesHowell(
            List<List<double>> groups, List<string> names, List<string> selectedNames)
        {
            var results = new List<(string, string, string, string, string, double)>();

            if (groups.Count < 2) return results;

            for (int i = 0; i < groups.Count; i++)
            {
                for (int j = i + 1; j < groups.Count; j++)
                {
                    // Include pair if either group is in selected list, or if all groups selected
                    bool includeI = selectedNames.Count == 0 || selectedNames.Contains(names[i]);
                    bool includeJ = selectedNames.Count == 0 || selectedNames.Contains(names[j]);
                    
                    if (!includeI && !includeJ)
                        continue;

                    var g1 = groups[i];
                    var g2 = groups[j];
                    
                    if (g1.Count < 2 || g2.Count < 2) continue;
                    
                    double m1 = g1.Average(), m2 = g2.Average();
                    double v1 = CalcVar(g1), v2 = CalcVar(g2);
                    int n1 = g1.Count, n2 = g2.Count;

                    double se = Math.Sqrt(v1 / n1 + v2 / n2);
                    double meanDiff = m1 - m2;
                    double t = se > 1e-10 ? Math.Abs(meanDiff) / se : 0;

                    // Welch-Satterthwaite df
                    double num = Math.Pow(v1 / n1 + v2 / n2, 2);
                    double den = Math.Pow(v1 / n1, 2) / (n1 - 1) + Math.Pow(v2 / n2, 2) / (n2 - 1);
                    double df = den > 0 ? num / den : n1 + n2 - 2;

                    double pVal = CalculateTwoTailedTPValue(t, df);

                    results.Add(($"{names[i]} vs {names[j]}", meanDiff.ToString("F4"), df.ToString("F1"), se.ToString("F4"), t.ToString("F4"), pVal));
                }
            }
            return results;
        }

        /// <summary>
        /// Approximate Tukey p-value using studentized range distribution
        /// </summary>
        private double CalculateTukeyP(double q, int k, int df)
        {
            // Simplified approximation - convert to F and use F distribution
            // This is an approximation; exact requires studentized range tables
            double fApprox = q * q / 2;
            return CalculateFPValue(fApprox, k - 1, df);
        }

        private List<string> GetSelectedSeriesNamesFromListBox(ListBox? lb)
        {
            var result = new List<string>();
            if (lb == null) return result;

            foreach (var item in lb.Items)
            {
                if (item is CheckBox cb && cb.IsChecked == true)
                    result.Add(cb.Content?.ToString() ?? "");
            }
            return result;
        }

        private DataTable RunAnovaSameSeries()
        {
            var dt = new DataTable();

            if (singleSeriesCombo?.SelectedIndex < 0)
            {
                MessageBox.Show("Please select a series.", "Selection Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                return dt;
            }

            var selectedXValues = GetSelectedXValues();
            if (selectedXValues.Count < 2)
            {
                MessageBox.Show("Please select at least 2 X values.", "Selection Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                return dt;
            }

            var series = dataSeries[singleSeriesCombo!.SelectedIndex];

            // Collect replicate data at each X
            var groups = new List<List<double>>();
            var groupLabels = new List<string>();

            foreach (var x in selectedXValues)
            {
                var reps = GetReplicatesAtX(series, x);
                if (reps.Count > 0)
                {
                    groups.Add(reps);
                    groupLabels.Add(GetXLabel(x));
                }
            }

            if (groups.Count < 2)
            {
                MessageBox.Show("Need data at least 2 X values.", "Insufficient Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                return dt;
            }

            // Levene's test for homogeneity of variances
            var (leveneF, leveneP) = LevenesTest(groups);
            bool equalVariances = leveneP > 0.05 || double.IsNaN(leveneP);

            // Setup columns
            dt.Columns.Add("Source", typeof(string));
            dt.Columns.Add("SS", typeof(string));
            dt.Columns.Add("df", typeof(string));
            dt.Columns.Add("MS", typeof(string));
            dt.Columns.Add("F", typeof(string));
            dt.Columns.Add("p-value", typeof(string));
            dt.Columns.Add("Sig.", typeof(string));

            string anovaType;
            double f, p;

            if (equalVariances)
            {
                // Standard One-Way ANOVA
                anovaType = "Standard One-Way ANOVA";
                var result = CalculateOneWayAnova(groups);

                dt.Rows.Add($"ANOVA Type: {anovaType}", "", "", "", "", "", "");
                dt.Rows.Add($"Levene's Test: F={leveneF:F3}, p={FormatPValue(leveneP)} (Equal variances assumed)", "", "", "", "", "", "");
                dt.Rows.Add("", "", "", "", "", "", "");
                dt.Rows.Add("Between X Values", result.ssBetween.ToString("F4"), result.dfBetween.ToString(), 
                    (result.ssBetween / result.dfBetween).ToString("F4"), result.f.ToString("F4"), FormatPValue(result.p), GetSig(result.p));
                dt.Rows.Add("Within X Values", result.ssWithin.ToString("F4"), result.dfWithin.ToString(), 
                    (result.dfWithin > 0 ? result.ssWithin / result.dfWithin : 0).ToString("F4"), "-", "-", "-");
                dt.Rows.Add("Total", result.ssTotal.ToString("F4"), (result.dfBetween + result.dfWithin).ToString(), "-", "-", "-", "-");
                
                f = result.f;
                p = result.p;
            }
            else
            {
                // Welch's ANOVA
                anovaType = "Welch's ANOVA";
                var (welchF, welchDf1, welchDf2, welchP) = WelchsAnova(groups);
                f = welchF;
                p = welchP;

                dt.Rows.Add($"ANOVA Type: {anovaType}", "", "", "", "", "", "");
                dt.Rows.Add($"Levene's Test: F={leveneF:F3}, p={FormatPValue(leveneP)} (Unequal variances)", "", "", "", "", "", "");
                dt.Rows.Add("", "", "", "", "", "", "");
                dt.Rows.Add("Welch's F", "-", $"{welchDf1:F1}, {welchDf2:F1}", "-", f.ToString("F4"), FormatPValue(p), GetSig(p));
            }

            // Group Summary
            dt.Rows.Add("", "", "", "", "", "", "");
            dt.Rows.Add("Group Summary:", "", "", "", "", "", "");
            for (int i = 0; i < groups.Count; i++)
            {
                dt.Rows.Add($"  {groupLabels[i]}", $"N={groups[i].Count}", "",
                    $"Mean={groups[i].Average():F4}", $"SD={CalcSD(groups[i]):F4}", "", "");
            }

            // Post-hoc tests if requested
            if (anovaPostHocCheck?.IsChecked == true)
            {
                dt.Rows.Add("", "", "", "", "", "", "");

                // Warning if ANOVA not significant
                if (p >= 0.05)
                {
                    dt.Rows.Add("Note: ANOVA p ??0.05; post-hoc results should be interpreted with caution.", "", "", "", "", "", "");
                    dt.Rows.Add("", "", "", "", "", "", "");
                }

                if (equalVariances)
                {
                    dt.Rows.Add("Post-hoc: Tukey's HSD (equal variances)", "", "", "", "", "", "");
                    dt.Rows.Add("Comparison", "Mean Diff", "", "SE", "q", "p-value", "Sig.");
                    var tukeyResults = TukeyHSD(groups, groupLabels, groupLabels);
                    foreach (var row in tukeyResults)
                    {
                        dt.Rows.Add($"  {row.comparison}", row.meanDiff, "", row.se, row.q, FormatPValue(row.p), GetSig(row.p));
                    }
                }
                else
                {
                    dt.Rows.Add("Post-hoc: Games-Howell (unequal variances)", "", "", "", "", "", "");
                    dt.Rows.Add("Comparison", "Mean Diff", "df", "SE", "t", "p-value", "Sig.");
                    var ghResults = GamesHowell(groups, groupLabels, groupLabels);
                    foreach (var row in ghResults)
                    {
                        dt.Rows.Add($"  {row.comparison}", row.meanDiff, row.df, row.se, row.t, FormatPValue(row.p), GetSig(row.p));
                    }
                }
            }

            return dt;
        }

        private DataTable RunTwoWayAnova()
        {
            var dt = new DataTable();
            dt.Columns.Add("Source", typeof(string));
            dt.Columns.Add("SS", typeof(string));
            dt.Columns.Add("df", typeof(string));
            dt.Columns.Add("MS", typeof(string));
            dt.Columns.Add("F", typeof(string));
            dt.Columns.Add("p-value", typeof(string));
            dt.Columns.Add("Sig.", typeof(string));

            var selectedSeries = GetSelectedSeriesFromListBox(multiSeriesListBox);
            var selectedXValues = GetSelectedXValues();

            if (selectedSeries.Count < 2 || selectedXValues.Count < 2)
            {
                MessageBox.Show("Please select at least 2 series and 2 X values.", "Selection Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                return dt;
            }

            bool includeInteraction = twoWayIncludeInteraction?.IsChecked ?? true;
            int ssType = (twoWaySsTypeCombo?.SelectedIndex ?? 0) switch
            {
                1 => 1, // Type I
                2 => 2, // Type II
                _ => 3  // Type III (default)
            };

            // Build data matrix: data[series][xValue] = list of replicates
            var dataMatrix = new Dictionary<string, Dictionary<double, List<double>>>();
            
            foreach (var s in selectedSeries)
            {
                dataMatrix[s.Name] = new Dictionary<double, List<double>>();
                foreach (var x in selectedXValues)
                {
                    var reps = GetReplicatesAtX(s, x);
                    if (reps.Count > 0)
                        dataMatrix[s.Name][x] = reps;
                }
            }

            // Check for balanced design
            int totalN = 0;
            var allData = new List<double>();
            var cellNs = new Dictionary<(string, double), int>();

            foreach (var s in selectedSeries)
            {
                foreach (var x in selectedXValues)
                {
                    if (!dataMatrix[s.Name].ContainsKey(x) || dataMatrix[s.Name][x].Count == 0)
                    {
                        MessageBox.Show($"Missing data for {s.Name} at {GetXLabel(x)}.\nTwo-way ANOVA requires data at all combinations.", 
                            "Incomplete Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                        return dt;
                    }
                    cellNs[(s.Name, x)] = dataMatrix[s.Name][x].Count;
                    totalN += dataMatrix[s.Name][x].Count;
                    allData.AddRange(dataMatrix[s.Name][x]);
                }
            }

            // Check if design is balanced
            bool isBalanced = cellNs.Values.Distinct().Count() == 1;

            int a = selectedSeries.Count;  // Factor A levels (Series)
            int b = selectedXValues.Count; // Factor B levels (X values)
            double grandMean = allData.Average();

            // Calculate means
            var seriesMeans = new Dictionary<string, double>();
            var xMeans = new Dictionary<double, double>();
            var cellMeans = new Dictionary<(string, double), double>();

            foreach (var s in selectedSeries)
            {
                var sData = new List<double>();
                foreach (var x in selectedXValues)
                    sData.AddRange(dataMatrix[s.Name][x]);
                seriesMeans[s.Name] = sData.Average();
            }

            foreach (var x in selectedXValues)
            {
                var xData = new List<double>();
                foreach (var s in selectedSeries)
                    xData.AddRange(dataMatrix[s.Name][x]);
                xMeans[x] = xData.Average();
            }

            foreach (var s in selectedSeries)
                foreach (var x in selectedXValues)
                    cellMeans[(s.Name, x)] = dataMatrix[s.Name][x].Average();

            // Calculate SS based on Type
            double ssA = 0, ssB = 0, ssAB = 0, ssError = 0;

            // Error SS is always the same
            foreach (var s in selectedSeries)
            {
                foreach (var x in selectedXValues)
                {
                    foreach (var val in dataMatrix[s.Name][x])
                        ssError += Math.Pow(val - cellMeans[(s.Name, x)], 2);
                }
            }

            double ssTotal = allData.Sum(v => Math.Pow(v - grandMean, 2));

            // Type III (Marginal) - Each effect adjusted for all others
            if (ssType == 3 || !isBalanced)
            {
                // For unbalanced designs, always use Type III
                foreach (var s in selectedSeries)
                {
                    int nPerSeries = selectedXValues.Sum(x => cellNs[(s.Name, x)]);
                    ssA += nPerSeries * Math.Pow(seriesMeans[s.Name] - grandMean, 2);
                }
                
                foreach (var x in selectedXValues)
                {
                    int nPerX = selectedSeries.Sum(s => cellNs[(s.Name, x)]);
                    ssB += nPerX * Math.Pow(xMeans[x] - grandMean, 2);
                }

                if (includeInteraction)
                {
                    foreach (var s in selectedSeries)
                    {
                        foreach (var x in selectedXValues)
                        {
                            int n = cellNs[(s.Name, x)];
                            double cellDev = cellMeans[(s.Name, x)] - seriesMeans[s.Name] - xMeans[x] + grandMean;
                            ssAB += n * Math.Pow(cellDev, 2);
                        }
                    }
                }
            }
            else if (ssType == 1)
            {
                // Type I (Sequential) - A first, then B|A, then AB|A,B
                foreach (var s in selectedSeries)
                {
                    int nPerSeries = selectedXValues.Sum(x => cellNs[(s.Name, x)]);
                    ssA += nPerSeries * Math.Pow(seriesMeans[s.Name] - grandMean, 2);
                }
                
                // B adjusted for A
                ssB = ssTotal - ssA - ssError;
                if (includeInteraction)
                {
                    foreach (var s in selectedSeries)
                    {
                        foreach (var x in selectedXValues)
                        {
                            int n = cellNs[(s.Name, x)];
                            double cellDev = cellMeans[(s.Name, x)] - seriesMeans[s.Name] - xMeans[x] + grandMean;
                            ssAB += n * Math.Pow(cellDev, 2);
                        }
                    }
                    ssB = ssTotal - ssA - ssAB - ssError;
                }
            }
            else // Type II
            {
                // Type II (Hierarchical) - Each main effect adjusted for other main effect only
                foreach (var s in selectedSeries)
                {
                    int nPerSeries = selectedXValues.Sum(x => cellNs[(s.Name, x)]);
                    ssA += nPerSeries * Math.Pow(seriesMeans[s.Name] - grandMean, 2);
                }
                
                foreach (var x in selectedXValues)
                {
                    int nPerX = selectedSeries.Sum(s => cellNs[(s.Name, x)]);
                    ssB += nPerX * Math.Pow(xMeans[x] - grandMean, 2);
                }

                if (includeInteraction)
                {
                    ssAB = ssTotal - ssA - ssB - ssError;
                    if (ssAB < 0) ssAB = 0;
                }
            }

            int dfA = a - 1;
            int dfB = b - 1;
            int dfAB = includeInteraction ? dfA * dfB : 0;
            int dfError = totalN - (includeInteraction ? a * b : a + b - 1);
            if (dfError < 1) dfError = 1;
            int dfTotal = totalN - 1;

            double msA = dfA > 0 ? ssA / dfA : 0;
            double msB = dfB > 0 ? ssB / dfB : 0;
            double msAB = dfAB > 0 ? ssAB / dfAB : 0;
            double msError = dfError > 0 ? ssError / dfError : 0;

            double fA = msError > 1e-10 ? msA / msError : 0;
            double fB = msError > 1e-10 ? msB / msError : 0;
            double fAB = msError > 1e-10 ? msAB / msError : 0;

            double pA = CalculateFPValue(fA, dfA, dfError);
            double pB = CalculateFPValue(fB, dfB, dfError);
            double pAB = includeInteraction ? CalculateFPValue(fAB, dfAB, dfError) : 1;

            // Header info
            string ssTypeStr = ssType switch { 1 => "Type I (Sequential)", 2 => "Type II (Hierarchical)", _ => "Type III (Marginal)" };
            dt.Rows.Add($"Sum of Squares: {ssTypeStr}", "", "", "", "", "", "");
            dt.Rows.Add($"Design: {(isBalanced ? "Balanced" : "Unbalanced")}", "", "", "", "", "", "");
            dt.Rows.Add("", "", "", "", "", "", "");

            // ANOVA table
            dt.Rows.Add("Series (Factor A)", ssA.ToString("F4"), dfA.ToString(), msA.ToString("F4"), fA.ToString("F4"), FormatPValue(pA), GetSig(pA));
            dt.Rows.Add("X Value (Factor B)", ssB.ToString("F4"), dfB.ToString(), msB.ToString("F4"), fB.ToString("F4"), FormatPValue(pB), GetSig(pB));
            
            if (includeInteraction)
            {
                dt.Rows.Add("Interaction (A?B)", ssAB.ToString("F4"), dfAB.ToString(), msAB.ToString("F4"), fAB.ToString("F4"), FormatPValue(pAB), GetSig(pAB));
            }
            
            dt.Rows.Add("Error", ssError.ToString("F4"), dfError.ToString(), msError.ToString("F4"), "-", "-", "-");
            dt.Rows.Add("Total", ssTotal.ToString("F4"), dfTotal.ToString(), "-", "-", "-", "-");

            // Post-hoc analysis
            dt.Rows.Add("", "", "", "", "", "", "");
            
            if (includeInteraction && pAB < 0.05)
            {
                // Simple Main Effects
                dt.Rows.Add("Post-hoc: Simple Main Effects (Interaction p < 0.05)", "", "", "", "", "", "");
                dt.Rows.Add("", "", "", "", "", "", "");
                
                // Effect of Factor A at each level of Factor B
                dt.Rows.Add("Effect of Series at each X value:", "", "", "", "", "", "");
                foreach (var x in selectedXValues)
                {
                    var groupsAtX = new List<List<double>>();
                    var namesAtX = new List<string>();
                    foreach (var s in selectedSeries)
                    {
                        groupsAtX.Add(dataMatrix[s.Name][x]);
                        namesAtX.Add(s.Name);
                    }
                    var (_, _, _, _, _, _, fSimple, pSimple) = CalculateOneWayAnova(groupsAtX);
                    dt.Rows.Add($"  {GetXLabel(x)}", "", "", "", fSimple.ToString("F4"), FormatPValue(pSimple), GetSig(pSimple));
                }

                dt.Rows.Add("", "", "", "", "", "", "");
                dt.Rows.Add("Effect of X value at each Series:", "", "", "", "", "", "");
                foreach (var s in selectedSeries)
                {
                    var groupsAtS = new List<List<double>>();
                    foreach (var x in selectedXValues)
                        groupsAtS.Add(dataMatrix[s.Name][x]);
                    var (_, _, _, _, _, _, fSimple, pSimple) = CalculateOneWayAnova(groupsAtS);
                    dt.Rows.Add($"  {s.Name}", "", "", "", fSimple.ToString("F4"), FormatPValue(pSimple), GetSig(pSimple));
                }
            }
            else
            {
                // Main Effects Tests
                dt.Rows.Add("Post-hoc: Main Effects Tests (Interaction p ??0.05 or excluded)", "", "", "", "", "", "");
                
                if (pA < 0.05)
                {
                    dt.Rows.Add("", "", "", "", "", "", "");
                    dt.Rows.Add("Pairwise comparisons for Factor A (Series):", "", "", "", "", "", "");
                    for (int i = 0; i < selectedSeries.Count; i++)
                    {
                        for (int j = i + 1; j < selectedSeries.Count; j++)
                        {
                            var s1 = selectedSeries[i];
                            var s2 = selectedSeries[j];
                            var d1 = selectedXValues.SelectMany(x => dataMatrix[s1.Name][x]).ToList();
                            var d2 = selectedXValues.SelectMany(x => dataMatrix[s2.Name][x]).ToList();
                            var (t, df, p) = WelchTTest(d1, d2);
                            dt.Rows.Add($"  {s1.Name} vs {s2.Name}", $"?={(d1.Average() - d2.Average()):F4}", df.ToString("F1"), "", t.ToString("F4"), FormatPValue(p), GetSig(p));
                        }
                    }
                }

                if (pB < 0.05)
                {
                    dt.Rows.Add("", "", "", "", "", "", "");
                    dt.Rows.Add("Pairwise comparisons for Factor B (X values):", "", "", "", "", "", "");
                    for (int i = 0; i < selectedXValues.Count; i++)
                    {
                        for (int j = i + 1; j < selectedXValues.Count; j++)
                        {
                            var x1 = selectedXValues[i];
                            var x2 = selectedXValues[j];
                            var d1 = selectedSeries.SelectMany(s => dataMatrix[s.Name][x1]).ToList();
                            var d2 = selectedSeries.SelectMany(s => dataMatrix[s.Name][x2]).ToList();
                            var (t, df, p) = WelchTTest(d1, d2);
                            dt.Rows.Add($"  {GetXLabel(x1)} vs {GetXLabel(x2)}", $"?={(d1.Average() - d2.Average()):F4}", df.ToString("F1"), "", t.ToString("F4"), FormatPValue(p), GetSig(p));
                        }
                    }
                }
            }

            // Cell means summary
            dt.Rows.Add("", "", "", "", "", "", "");
            dt.Rows.Add("Cell Means:", "", "", "", "", "", "");
            foreach (var s in selectedSeries)
            {
                var row = $"  {s.Name}: ";
                foreach (var x in selectedXValues)
                {
                    row += $"{GetXLabel(x)}?cellMeans[(s.Name, x)]:F3}  ";
                }
                dt.Rows.Add(row, "", "", "", "", "", "");
            }

            return dt;
        }

        private DataTable RunDescriptive()
        {
            var dt = new DataTable();
            
            if (chartType == "Column")
            {
                dt.Columns.Add("Bar", typeof(string));
            }
            else
            {
                dt.Columns.Add("Series", typeof(string));
            }
            
            dt.Columns.Add("N", typeof(int));
            dt.Columns.Add("Mean", typeof(string));
            dt.Columns.Add("SD", typeof(string));
            dt.Columns.Add("SEM", typeof(string));
            dt.Columns.Add("Min", typeof(string));
            dt.Columns.Add("Max", typeof(string));
            dt.Columns.Add("Median", typeof(string));
            dt.Columns.Add("95% CI", typeof(string));

            var selectedSeries = GetSelectedSeriesFromListBox(multiSeriesListBox);

            foreach (var series in selectedSeries)
            {
                // For Column chart, use all replicates; for Multi Factors, use YValues
                var values = (chartType == "Column") 
                    ? GetAllReplicatesForSeries(series) 
                    : series.YValues;
                    
                if (values.Count == 0) continue;

                int n = values.Count;
                double mean = values.Average();
                double sd = CalcSD(values);
                double sem = sd / Math.Sqrt(n);
                double tCrit = GetTCritical(n - 1);

                dt.Rows.Add(series.Name, n, mean.ToString("F4"), sd.ToString("F4"), sem.ToString("F4"),
                    values.Min().ToString("F4"), values.Max().ToString("F4"), CalcMedian(values).ToString("F4"),
                    $"[{(mean - tCrit * sem):F3}, {(mean + tCrit * sem):F3}]");
            }

            return dt;
        }

        #endregion

        #region Helper Methods

        private List<ChartDataSeries> GetSelectedSeriesFromListBox(ListBox? lb)
        {
            var result = new List<ChartDataSeries>();
            if (lb == null) return result;

            foreach (var item in lb.Items)
            {
                if (item is CheckBox cb && cb.IsChecked == true)
                {
                    var series = dataSeries.FirstOrDefault(s => s.Name == cb.Content?.ToString());
                    if (series != null) result.Add(series);
                }
            }
            return result;
        }

        private List<double> GetSelectedXValues()
        {
            var result = new List<double>();
            if (multiXListBox == null) return result;

            foreach (var item in multiXListBox.Items)
            {
                if (item is CheckBox cb && cb.IsChecked == true && cb.Tag is double x)
                    result.Add(x);
            }
            return result;
        }

        private List<double> GetReplicatesAtX(ChartDataSeries series, double xVal)
        {
            for (int i = 0; i < series.XValues.Count; i++)
            {
                if (Math.Abs(series.XValues[i] - xVal) < 1e-9)
                {
                    if (i < series.RawReplicates.Count && series.RawReplicates[i].Count > 0)
                        return series.RawReplicates[i];
                    
                    // If no raw replicates, return single mean value
                    if (i < series.YValues.Count)
                        return new List<double> { series.YValues[i] };
                }
            }
            return new List<double>();
        }

        /// <summary>
        /// Get all replicate values for a series (used for Column chart where each series is one bar)
        /// </summary>
        private List<double> GetAllReplicatesForSeries(ChartDataSeries series)
        {
            var result = new List<double>();
            
            // For Column chart, replicates are stored in RawReplicates[0]
            if (series.RawReplicates.Count > 0 && series.RawReplicates[0].Count > 0)
            {
                result.AddRange(series.RawReplicates[0]);
            }
            else
            {
                // Fallback: collect from all RawReplicates
                foreach (var reps in series.RawReplicates)
                {
                    if (reps != null && reps.Count > 0)
                        result.AddRange(reps);
                }
                
                // If still empty, use YValues
                if (result.Count == 0 && series.YValues.Count > 0)
                {
                    result.AddRange(series.YValues);
                }
            }
            
            return result;
        }

        private (double t, double df, double p) WelchTTest(List<double> g1, List<double> g2)
        {
            double m1 = g1.Average(), m2 = g2.Average();
            double v1 = CalcVar(g1), v2 = CalcVar(g2);
            int n1 = g1.Count, n2 = g2.Count;

            double se = Math.Sqrt(v1 / n1 + v2 / n2);
            if (se < 1e-10) return (0, n1 + n2 - 2, 1);

            double t = (m1 - m2) / se;

            double num = Math.Pow(v1 / n1 + v2 / n2, 2);
            double den = Math.Pow(v1 / n1, 2) / (n1 - 1) + Math.Pow(v2 / n2, 2) / (n2 - 1);
            double df = den > 0 ? num / den : n1 + n2 - 2;

            double p = CalculateTwoTailedTPValue(Math.Abs(t), df);
            return (t, df, p);
        }

        private (double ssBetween, double ssWithin, double ssTotal, int dfBetween, int dfWithin, int dfTotal, double f, double p) 
            CalculateOneWayAnova(List<List<double>> groups)
        {
            var allData = groups.SelectMany(g => g).ToList();
            double grandMean = allData.Average();
            int k = groups.Count;
            int totalN = allData.Count;

            double ssBetween = groups.Sum(g => g.Count * Math.Pow(g.Average() - grandMean, 2));
            double ssWithin = groups.Sum(g => g.Sum(v => Math.Pow(v - g.Average(), 2)));
            double ssTotal = allData.Sum(v => Math.Pow(v - grandMean, 2));

            int dfBetween = k - 1;
            int dfWithin = totalN - k;
            int dfTotal = totalN - 1;

            double msBetween = dfBetween > 0 ? ssBetween / dfBetween : 0;
            double msWithin = dfWithin > 0 ? ssWithin / dfWithin : 0;
            double f = msWithin > 1e-10 ? msBetween / msWithin : 0;
            double p = CalculateFPValue(f, dfBetween, dfWithin);

            return (ssBetween, ssWithin, ssTotal, dfBetween, dfWithin, dfTotal, f, p);
        }

        private double CalcSD(List<double> vals)
        {
            if (vals.Count < 2) return 0;
            double m = vals.Average();
            return Math.Sqrt(vals.Sum(v => Math.Pow(v - m, 2)) / (vals.Count - 1));
        }

        private double CalcVar(List<double> vals)
        {
            double sd = CalcSD(vals);
            return sd * sd;
        }

        private double CalcMedian(List<double> vals)
        {
            var sorted = vals.OrderBy(v => v).ToList();
            int n = sorted.Count;
            return n % 2 == 0 ? (sorted[n / 2 - 1] + sorted[n / 2]) / 2 : sorted[n / 2];
        }

        private double GetTCritical(int df)
        {
            if (df <= 0) return 1.96;
            if (df == 1) return 12.706; if (df == 2) return 4.303;
            if (df <= 5) return 2.571; if (df <= 10) return 2.228;
            if (df <= 20) return 2.086; if (df <= 30) return 2.042;
            return 1.96;
        }

        private double CalculateTwoTailedTPValue(double t, double df)
        {
            if (df < 1) return 1;
            double x = df / (df + t * t);
            return BetaInc(df / 2.0, 0.5, x);
        }

        private double CalculateFPValue(double f, int df1, int df2)
        {
            if (f < 0 || df1 < 1 || df2 < 1) return 1;
            double x = df2 / (df2 + df1 * f);
            return BetaInc(df2 / 2.0, df1 / 2.0, x);
        }

        private double BetaInc(double a, double b, double x)
        {
            if (x <= 0) return 0; if (x >= 1) return 1;
            double bt = Math.Exp(LogGamma(a + b) - LogGamma(a) - LogGamma(b) + a * Math.Log(x) + b * Math.Log(1 - x));
            return x < (a + 1) / (a + b + 2) ? bt * BetaCF(a, b, x) / a : 1 - bt * BetaCF(b, a, 1 - x) / b;
        }

        private double BetaCF(double a, double b, double x)
        {
            double qab = a + b, qap = a + 1, qam = a - 1;
            double c = 1, d = 1 - qab * x / qap;
            if (Math.Abs(d) < 1e-10) d = 1e-10;
            d = 1 / d;
            double h = d;

            for (int m = 1; m <= 100; m++)
            {
                int m2 = 2 * m;
                double aa = m * (b - m) * x / ((qam + m2) * (a + m2));
                d = 1 + aa * d; if (Math.Abs(d) < 1e-10) d = 1e-10;
                c = 1 + aa / c; if (Math.Abs(c) < 1e-10) c = 1e-10;
                d = 1 / d; h *= d * c;
                aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
                d = 1 + aa * d; if (Math.Abs(d) < 1e-10) d = 1e-10;
                c = 1 + aa / c; if (Math.Abs(c) < 1e-10) c = 1e-10;
                d = 1 / d;
                double del = d * c; h *= del;
                if (Math.Abs(del - 1) < 1e-10) break;
            }
            return h;
        }

        private double LogGamma(double x)
        {
            double[] c = { 76.18009172947146, -86.50532032941677, 24.01409824083091, -1.231739572450155, 1.208650973866179e-3, -5.395239384953e-6 };
            double tmp = x + 5.5 - (x + 0.5) * Math.Log(x + 5.5);
            double ser = 1.000000000190015;
            for (int j = 0; j < 6; j++) ser += c[j] / (x + 1 + j);
            return -tmp + Math.Log(2.5066282746310005 * ser / x);
        }

        private string FormatPValue(double p)
        {
            if (double.IsNaN(p)) return "N/A";
            if (p < 0.0001) return "< 0.0001";
            return p.ToString("F4");
        }

        private string GetSig(double p)
        {
            if (double.IsNaN(p)) return "-";
            if (p < 0.001) return "***";
            if (p < 0.01) return "**";
            if (p < 0.05) return "*";
            return "ns";
        }

        #endregion

        #region Copy Results
        private void ResultsGrid_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            // ?? Ctrl+C 銴ˊ?訾葉?摮
            if (e.Key == Key.C && Keyboard.Modifiers == ModifierKeys.Control)
            {
                CopySelectedCells();
                e.Handled = true;
            }
        }

        private void CopySelectedCells()
        {
            if (ResultsGrid.SelectedCells.Count == 0)
            {
                // 憒?瘝??訾葉?摮嚗?鋆賣?”??
                CopyResults_Click(null, null);
                return;
            }

            var sb = new StringBuilder();

            // ?脣???銝剔??脣??潘???????
            var selectedCells = ResultsGrid.SelectedCells
                .Select(cell => new
                {
                    RowIndex = ResultsGrid.Items.IndexOf(cell.Item),
                    ColumnIndex = cell.Column.DisplayIndex,
                    Cell = cell
                })
                .OrderBy(x => x.RowIndex)
                .ThenBy(x => x.ColumnIndex)
                .ToList();

            if (selectedCells.Count == 0) return;

            // 瑼Ｘ?臬?芷銝凋??桐??脣???
            if (selectedCells.Count == 1)
            {
                var cell = selectedCells[0].Cell;
                var cellContent = GetCellValue(cell);
                Clipboard.SetText(cellContent);
                return;
            }

            // 憭摮嚗?銵?蝜?
            int currentRow = -1;
            int lastColumnIndex = -1;

            foreach (var item in selectedCells)
            {
                if (currentRow != item.RowIndex)
                {
                    // ?啁?銝銵?
                    if (currentRow >= 0)
                    {
                        sb.AppendLine();
                    }
                    currentRow = item.RowIndex;
                    lastColumnIndex = item.ColumnIndex;
                }
                else
                {
                    // ??銵?瘛餃???蝚?
                    // 憛怠?頝喲???
                    while (lastColumnIndex < item.ColumnIndex - 1)
                    {
                        sb.Append("\t");
                        lastColumnIndex++;
                    }
                    sb.Append("\t");
                    lastColumnIndex = item.ColumnIndex;
                }

                var cellValue = GetCellValue(item.Cell);
                sb.Append(cellValue);
            }

            Clipboard.SetText(sb.ToString());
        }

        private string GetCellValue(DataGridCellInfo cellInfo)
        {
            if (cellInfo.Column == null || cellInfo.Item == null)
                return "";

            // ?脣?蝬??惇?批?
            var binding = (cellInfo.Column as DataGridBoundColumn)?.Binding as Binding;
            if (binding != null && cellInfo.Item is System.Data.DataRowView rowView)
            {
                var columnName = binding.Path.Path;
                if (rowView.Row.Table.Columns.Contains(columnName))
                {
                    var value = rowView[columnName];
                    return value?.ToString() ?? "";
                }
            }

            // ??寞?嚗?閰衣?亙????脣?
            if (cellInfo.Item is System.Data.DataRowView drv)
            {
                try
                {
                    var columnHeader = cellInfo.Column.Header?.ToString();
                    if (!string.IsNullOrEmpty(columnHeader) && drv.Row.Table.Columns.Contains(columnHeader))
                    {
                        return drv[columnHeader]?.ToString() ?? "";
                    }
                }
                catch
                {
                    // 敹賜?航炊
                }
            }

            return "";
        }
        private void CopyResults_Click(object sender, RoutedEventArgs e)
        {
            if (ResultsGrid.ItemsSource is DataView dv && dv.Table != null)
            {
                var sb = new StringBuilder();
                var dt = dv.Table;

                // Headers
                sb.AppendLine(string.Join("\t", dt.Columns.Cast<DataColumn>().Select(c => c.ColumnName)));

                // Rows
                foreach (DataRow row in dt.Rows)
                    sb.AppendLine(string.Join("\t", row.ItemArray.Select(v => v?.ToString() ?? "")));

                Clipboard.SetText(sb.ToString());
                MessageBox.Show("Results copied to clipboard!", "Copied", MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }
       

        

        


        #endregion
    }
}


==================================================
FILE_NAME: Statistics_README.md
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\Statistics_README.md
==================================================
# Statistical Analysis Methods - BioSAK GraphGen

This document explains the statistical methods implemented in the BioSAK GraphGen statistical analysis module.

---

## Table of Contents
1. [T-Test](#t-test)
2. [One-Way ANOVA](#one-way-anova)
3. [Two-Way ANOVA](#two-way-anova)
4. [Post-hoc Tests](#post-hoc-tests)
5. [Decision Logic Summary](#decision-logic-summary)

---

## T-Test

### Overview
The t-test compares means between two groups to determine if they are statistically different.

### Available Options

#### 1. Comparison Mode
- **All Pairs**: Automatically computes t-tests for all possible pairwise combinations of selected groups
- **Select Two**: Manually select exactly two groups to compare

#### 2. Test Type Selection

**Paired vs Independent:**
- **Paired t-test**: Use when samples are related (e.g., before/after measurements on the same subjects)
  - Requires equal sample sizes in both groups
  - Calculates differences between paired observations
  - Formula: t = (mean of differences) / (SE of differences)
  
- **Independent t-test**: Use when samples are from different, unrelated groups

**Variance Equality (for Independent t-test only):**

When "Auto-detect variance equality" is checked:
1. **F-test** is performed to test H?: ???= ???2. If F-test p > 0.05: **Student's t-test** (assumes equal variances)
   - Uses pooled variance estimate
   - df = n??+ n??- 2
3. If F-test p ??0.05: **Welch's t-test** (does not assume equal variances)
   - Uses Welch-Satterthwaite degrees of freedom approximation
   - More robust for unequal variances and sample sizes

**Default Behavior:**
- If F-test cannot be computed (e.g., zero variance): defaults to **Welch's t-test**

#### 3. Tail Selection
- **Two-tailed**: Tests H?: 弮??= 弮??vs H?? 弮????弮??- **One-tailed (>)**: Tests H?: 弮????弮??vs H?? 弮??> 弮??- **One-tailed (<)**: Tests H?: 弮????弮??vs H?? 弮??< 弮??
For one-tailed tests, the p-value is halved in the direction of the alternative hypothesis.

---

## One-Way ANOVA

### Overview
One-Way ANOVA tests whether there are statistically significant differences among three or more groups.

### Variance Homogeneity Testing

**Levene's Test** is automatically performed:
- Tests H?: All group variances are equal
- Uses absolute deviations from group medians (more robust than using means)

### ANOVA Type Selection

Based on Levene's test result:

| Levene's p-value | ANOVA Type | Assumption |
|------------------|------------|------------|
| > 0.05 | Standard One-Way ANOVA | Equal variances |
| ??0.05 | Welch's ANOVA | Unequal variances |

**Welch's ANOVA:**
- Does not assume equal variances
- Uses weighted means and adjusted degrees of freedom
- More robust for heteroscedastic data

**Default Behavior:**
- If Levene's test cannot be computed: defaults to **Standard ANOVA** (assumes equal variances)

### Post-hoc Tests

Post-hoc tests are performed only if:
1. Post-hoc option is checked
2. ANOVA p-value < 0.05

**Method Selection (automatic based on Levene's test):**

| Levene's p-value | Post-hoc Method |
|------------------|-----------------|
| > 0.05 | Tukey's HSD |
| ??0.05 | Games-Howell |

**Tukey's HSD (Honestly Significant Difference):**
- Assumes equal variances
- Controls family-wise error rate
- Uses studentized range distribution

**Games-Howell:**
- Does not assume equal variances
- Uses Welch-Satterthwaite degrees of freedom
- Appropriate for unequal sample sizes and variances

---

## Two-Way ANOVA

### Overview
Two-Way ANOVA examines the effects of two independent variables (factors) and their interaction.

- **Factor A**: Series (groups)
- **Factor B**: X values (conditions)
- **Interaction (A ? B)**: Whether the effect of one factor depends on the level of the other

### Options

#### 1. Include Interaction Term
- **Checked (default)**: Tests main effects A, B, and interaction A?B
- **Unchecked**: Tests only main effects A and B

#### 2. Sum of Squares Type

| Type | Name | Description | When to Use |
|------|------|-------------|-------------|
| Type I | Sequential | Effects tested in order; each adjusted for previous | Balanced designs with ordered factors |
| Type II | Hierarchical | Each main effect adjusted for other main effects only | No interaction expected |
| Type III | Marginal (default) | Each effect adjusted for all other effects | Unbalanced designs, general use |

**Automatic Selection:**
- For unbalanced designs, Type III is always used regardless of selection

### Post-hoc Analysis

**Based on Interaction Significance:**

| Interaction p-value | Analysis Type | Description |
|---------------------|---------------|-------------|
| < 0.05 | Simple Main Effects | Tests effect of each factor at each level of the other factor |
| ??0.05 | Main Effects Tests | Pairwise comparisons for significant main effects |

**Simple Main Effects:**
When interaction is significant, the effect of one factor depends on the other. Therefore:
- Effect of Factor A is tested separately at each level of Factor B
- Effect of Factor B is tested separately at each level of Factor A

**Main Effects Tests:**
When interaction is not significant:
- If Factor A is significant: Pairwise comparisons between series
- If Factor B is significant: Pairwise comparisons between X values

---

## Post-hoc Tests

### Tukey's HSD
```
q = |Mean??- Mean? / SE

where SE = ??MSE ? (1/n??+ 1/n?? / 2)
```
- Uses studentized range distribution
- Controls Type I error across all comparisons

### Games-Howell
```
t = |Mean??- Mean? / SE

where SE = ??s??n??+ s??n??
df = Welch-Satterthwaite approximation
```
- Does not assume equal variances
- Adjusts degrees of freedom for each comparison

---

## Decision Logic Summary

### T-Test Decision Tree
```
Is comparison paired?
?? YES ??Paired t-test
?? NO ??Independent t-test
         ?? Can F-test be computed?
         ??  ?? YES ??F-test p > 0.05?
         ??  ??       ?? YES ??Student's t-test
         ??  ??       ?? NO ??Welch's t-test
         ??  ?? NO ??Welch's t-test (default)
         ?? Apply tail correction if one-tailed
```

### One-Way ANOVA Decision Tree
```
Perform Levene's test for variance homogeneity
?? Can Levene's test be computed?
??  ?? YES ??Levene's p > 0.05?
??  ??       ?? YES ??Standard ANOVA, Tukey's HSD
??  ??       ?? NO ??Welch's ANOVA, Games-Howell
??  ?? NO ??Standard ANOVA (default)
?? ANOVA p < 0.05?
    ?? YES ??Perform selected post-hoc test
    ?? NO ??No post-hoc (no significant differences)
```

### Two-Way ANOVA Decision Tree
```
Check design balance
?? Balanced ??Use selected SS Type
?? Unbalanced ??Force Type III

Include interaction?
?? YES ??Test A, B, and A?B
??       ?? Interaction p < 0.05?
??           ?? YES ??Simple Main Effects
??           ?? NO ??Main Effects Tests
?? NO ??Test A and B only
         ?? Main Effects Tests for significant factors
```

---

## Statistical Formulas

### F-test for Variance Equality
```
F = s??/ s?? (larger / smaller)
df??= n??- 1, df??= n??- 1
```

### Levene's Test
```
1. Calculate |X廘Ｔ掉 - Median(X漹?| for each observation
2. Perform ANOVA on absolute deviations
```

### Welch-Satterthwaite Degrees of Freedom
```
df = (s??n??+ s??n??簡 / [(s??n??簡/(n??1) + (s??n??簡/(n??1)]
```

### Welch's ANOVA
```
F = 峉w廘?X?廘?- X?廘丟等)簡 / (k-1) / [1 + 2(k-2)弇/(k簡-1)]

where:
  w廘?= n廘?/ s廘Ⅹ?  X?廘丟等 = 峉w廘?X?廘?/ 峉w廘?  弇 = 3峉[(1 - w廘?峉w廘?簡/(n廘?1)] / (k簡-1)
```

---

## Significance Levels

| p-value | Significance | Symbol |
|---------|--------------|--------|
| p < 0.001 | Highly significant | *** |
| p < 0.01 | Very significant | ** |
| p < 0.05 | Significant | * |
| p ??0.05 | Not significant | ns |

---

## References

1. Welch, B. L. (1947). The generalization of "Student's" problem when several different population variances are involved. Biometrika, 34(1/2), 28-35.

2. Games, P. A., & Howell, J. F. (1976). Pairwise multiple comparison procedures with unequal n's and/or variances: a Monte Carlo study. Journal of Educational Statistics, 1(2), 113-125.

3. Levene, H. (1960). Robust tests for equality of variances. In Contributions to Probability and Statistics (pp. 278-292).

4. Brown, M. B., & Forsythe, A. B. (1974). The small sample behavior of some statistics which test the equality of several means. Technometrics, 16(1), 129-132.

---

*BioSAK GraphGen Statistical Module - Version 1.0*


==================================================
FILE_NAME: SymbolPickerDialog.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\SymbolPickerDialog.xaml
==================================================
<Window x:Class="BioSAK.SymbolPickerDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Insert Symbol" 
        Height="450" Width="500"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Insert Special Symbol" FontSize="18" FontWeight="Bold" Margin="0,0,0,15"/>

        <!-- Category Tabs -->
        <TabControl Grid.Row="1" x:Name="CategoryTabs" Margin="0,0,0,10">
            <TabItem Header="Greek Letters">
                <WrapPanel x:Name="GreekPanel" Margin="10"/>
            </TabItem>
            <TabItem Header="Greek (Uppercase)">
                <WrapPanel x:Name="GreekUpperPanel" Margin="10"/>
            </TabItem>
            <TabItem Header="Math Symbols">
                <WrapPanel x:Name="MathPanel" Margin="10"/>
            </TabItem>
            <TabItem Header="Subscript/Superscript">
                <WrapPanel x:Name="SubSupPanel" Margin="10"/>
            </TabItem>
            <TabItem Header="Arrows">
                <WrapPanel x:Name="ArrowPanel" Margin="10"/>
            </TabItem>
            <TabItem Header="Other">
                <WrapPanel x:Name="OtherPanel" Margin="10"/>
            </TabItem>
        </TabControl>

        <!-- Recently Used -->
        <GroupBox Grid.Row="2" Header="Recently Used" Padding="10">
            <WrapPanel x:Name="RecentPanel"/>
        </GroupBox>

        <!-- Preview -->
        <Border Grid.Row="3" Background="White" BorderBrush="#DDD" BorderThickness="1" 
                Padding="10" Margin="0,10,0,0">
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="Selected: " VerticalAlignment="Center"/>
                <TextBlock x:Name="PreviewSymbol" FontSize="24" FontWeight="Bold" 
                           VerticalAlignment="Center" Margin="10,0"/>
                <TextBlock x:Name="SymbolName" Foreground="#888" VerticalAlignment="Center"/>
            </StackPanel>
        </Border>

        <!-- Buttons -->
        <StackPanel Grid.Row="4" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
            <Button Content="Cancel" Width="80" Padding="5,8" Margin="0,0,10,0"
                    Background="#EEE" BorderThickness="0" Cursor="Hand" Click="Cancel_Click"/>
            <Button Content="Insert" Width="80" Padding="5,8"
                    Background="#4FC3F7" Foreground="White" BorderThickness="0" 
                    Cursor="Hand" Click="Insert_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: SymbolPickerDialog.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\SymbolPickerDialog.xaml.cs
==================================================
using System.Collections.Generic;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;

namespace BioSAK
{
    public partial class SymbolPickerDialog : Window
    {
        public string SelectedSymbol { get; private set; } = "";

        private static List<string> recentSymbols = new List<string>();

        // Greek lowercase letters
        private readonly (string symbol, string name)[] greekLower = new[]
        {
            ("α", "alpha"), ("β", "beta"), ("γ", "gamma"), ("δ", "delta"),
            ("ε", "epsilon"), ("ζ", "zeta"), ("η", "eta"), ("θ", "theta"),
            ("ι", "iota"), ("κ", "kappa"), ("λ", "lambda"), ("μ", "mu"),
            ("ν", "nu"), ("ξ", "xi"), ("ο", "omicron"), ("π", "pi"),
            ("ρ", "rho"), ("σ", "sigma"), ("τ", "tau"), ("υ", "upsilon"),
            ("φ", "phi"), ("χ", "chi"), ("ψ", "psi"), ("ω", "omega")
        };

        // Greek uppercase letters
        private readonly (string symbol, string name)[] greekUpper = new[]
        {
            ("Α", "Alpha"), ("Β", "Beta"), ("Γ", "Gamma"), ("Δ", "Delta"),
            ("Ε", "Epsilon"), ("Ζ", "Zeta"), ("Η", "Eta"), ("Θ", "Theta"),
            ("Ι", "Iota"), ("Κ", "Kappa"), ("Λ", "Lambda"), ("Μ", "Mu"),
            ("Ν", "Nu"), ("Ξ", "Xi"), ("Ο", "Omicron"), ("Π", "Pi"),
            ("Ρ", "Rho"), ("Σ", "Sigma"), ("Τ", "Tau"), ("Υ", "Upsilon"),
            ("Φ", "Phi"), ("Χ", "Chi"), ("Ψ", "Psi"), ("Ω", "Omega")
        };

        // Math symbols
        private readonly (string symbol, string name)[] mathSymbols = new[]
        {
            ("±", "plus-minus"), ("×", "multiply"), ("÷", "divide"), ("≠", "not equal"),
            ("≈", "approximately"), ("≤", "less or equal"), ("≥", "greater or equal"), ("∞", "infinity"),
            ("√", "square root"), ("∑", "sum"), ("∏", "product"), ("∫", "integral"),
            ("∂", "partial"), ("∇", "nabla"), ("∈", "element of"), ("∉", "not element"),
            ("⊂", "subset"), ("⊃", "superset"), ("∪", "union"), ("∩", "intersection"),
            ("∅", "empty set"), ("∀", "for all"), ("∃", "exists"), ("¬", "not"),
            ("∧", "and"), ("∨", "or"), ("⊕", "xor"), ("°", "degree")
        };

        // Subscript and superscript
        private readonly (string symbol, string name)[] subSupSymbols = new[]
        {
            ("⁰", "superscript 0"), ("¹", "superscript 1"), ("²", "superscript 2"), ("³", "superscript 3"),
            ("⁴", "superscript 4"), ("⁵", "superscript 5"), ("⁶", "superscript 6"), ("⁷", "superscript 7"),
            ("⁸", "superscript 8"), ("⁹", "superscript 9"), ("⁺", "superscript +"), ("⁻", "superscript -"),
            ("₀", "subscript 0"), ("₁", "subscript 1"), ("₂", "subscript 2"), ("₃", "subscript 3"),
            ("₄", "subscript 4"), ("₅", "subscript 5"), ("₆", "subscript 6"), ("₇", "subscript 7"),
            ("₈", "subscript 8"), ("₉", "subscript 9"), ("₊", "subscript +"), ("₋", "subscript -"),
            ("ⁿ", "superscript n"), ("ˣ", "superscript x")
        };

        // Arrows
        private readonly (string symbol, string name)[] arrowSymbols = new[]
        {
            ("→", "right arrow"), ("←", "left arrow"), ("↑", "up arrow"), ("↓", "down arrow"),
            ("↔", "left right"), ("↕", "up down"), ("⇒", "double right"), ("⇐", "double left"),
            ("⇔", "double left right"), ("↗", "upper right"), ("↘", "lower right"), ("↙", "lower left"),
            ("↖", "upper left"), ("⟶", "long right"), ("⟵", "long left"), ("⟷", "long both")
        };

        // Other symbols
        private readonly (string symbol, string name)[] otherSymbols = new[]
        {
            ("•", "bullet"), ("◦", "white bullet"), ("‣", "triangular bullet"), ("★", "star"),
            ("☆", "white star"), ("✓", "check"), ("✗", "cross"), ("♠", "spade"),
            ("♣", "club"), ("♥", "heart"), ("♦", "diamond"), ("©", "copyright"),
            ("®", "registered"), ("™", "trademark"), ("§", "section"), ("¶", "paragraph"),
            ("†", "dagger"), ("‡", "double dagger"), ("‰", "per mille"), ("′", "prime"),
            ("″", "double prime"), ("‴", "triple prime"), ("Å", "angstrom"), ("℃", "celsius"),
            ("℉", "fahrenheit"), ("№", "numero")
        };

        public SymbolPickerDialog()
        {
            InitializeComponent();

            this.Loaded += (s, e) =>
            {
                PopulateSymbols(GreekPanel, greekLower);
                PopulateSymbols(GreekUpperPanel, greekUpper);
                PopulateSymbols(MathPanel, mathSymbols);
                PopulateSymbols(SubSupPanel, subSupSymbols);
                PopulateSymbols(ArrowPanel, arrowSymbols);
                PopulateSymbols(OtherPanel, otherSymbols);
                PopulateRecentSymbols();
            };
        }

        private void PopulateSymbols(WrapPanel panel, (string symbol, string name)[] symbols)
        {
            foreach (var (symbol, name) in symbols)
            {
                var btn = CreateSymbolButton(symbol, name);
                panel.Children.Add(btn);
            }
        }

        private void PopulateRecentSymbols()
        {
            RecentPanel.Children.Clear();
            foreach (var symbol in recentSymbols)
            {
                var btn = CreateSymbolButton(symbol, "Recent");
                RecentPanel.Children.Add(btn);
            }
        }

        private Button CreateSymbolButton(string symbol, string name)
        {
            var btn = new Button
            {
                Content = symbol,
                Width = 40,
                Height = 40,
                Margin = new Thickness(3),
                FontSize = 18,
                Background = Brushes.White,
                BorderBrush = new SolidColorBrush(Color.FromRgb(200, 200, 200)),
                BorderThickness = new Thickness(1),
                Cursor = Cursors.Hand,
                Tag = name,
                ToolTip = name
            };

            btn.Click += (s, e) =>
            {
                SelectedSymbol = symbol;
                PreviewSymbol.Text = symbol;
                SymbolName.Text = name;
            };

            btn.MouseDoubleClick += (s, e) =>
            {
                SelectedSymbol = symbol;
                AddToRecent(symbol);
                DialogResult = true;
                Close();
            };

            return btn;
        }

        private void AddToRecent(string symbol)
        {
            if (recentSymbols.Contains(symbol))
            {
                recentSymbols.Remove(symbol);
            }
            recentSymbols.Insert(0, symbol);
            if (recentSymbols.Count > 20)
            {
                recentSymbols.RemoveAt(recentSymbols.Count - 1);
            }
        }

        private void Insert_Click(object sender, RoutedEventArgs e)
        {
            if (!string.IsNullOrEmpty(SelectedSymbol))
            {
                AddToRecent(SelectedSymbol);
                DialogResult = true;
                Close();
            }
            else
            {
                MessageBox.Show("Please select a symbol first.", "No Selection",
                    MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}


==================================================
FILE_NAME: TextAnnotationDialog.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\TextAnnotationDialog.xaml
==================================================
<Window x:Class="BioSAK.TextAnnotationDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Text Annotation" 
        Height="400" Width="450"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#F5F5F5">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Text Annotation" FontSize="18" FontWeight="Bold" Margin="0,0,0,15"/>

        <!-- Text Input -->
        <GroupBox Grid.Row="1" Header="Text Content" Padding="10" Margin="0,0,0,10">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <TextBox Grid.Row="0" x:Name="TextInput" Height="60" TextWrapping="Wrap" 
                         AcceptsReturn="True" VerticalScrollBarVisibility="Auto"
                         FontSize="12" Padding="5"/>
                <Button Grid.Row="1" Content="Insert Symbol..." HorizontalAlignment="Left" 
                        Margin="0,5,0,0" Padding="10,3" Click="InsertSymbol_Click"/>
            </Grid>
        </GroupBox>

        <!-- Format Options -->
        <GroupBox Grid.Row="2" Header="Format" Padding="10" Margin="0,0,0,10">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="80"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="80"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- Font Family -->
                <TextBlock Grid.Row="0" Grid.Column="0" Text="Font:" VerticalAlignment="Center"/>
                <ComboBox Grid.Row="0" Grid.Column="1" x:Name="FontFamilyCombo" Margin="0,3">
                    <ComboBoxItem Content="Segoe UI" IsSelected="True"/>
                    <ComboBoxItem Content="Arial"/>
                    <ComboBoxItem Content="Times New Roman"/>
                    <ComboBoxItem Content="Calibri"/>
                    <ComboBoxItem Content="Consolas"/>
                    <ComboBoxItem Content="Georgia"/>
                </ComboBox>

                <!-- Font Size -->
                <TextBlock Grid.Row="0" Grid.Column="2" Text="Size:" VerticalAlignment="Center" Margin="10,0,0,0"/>
                <ComboBox Grid.Row="0" Grid.Column="3" x:Name="FontSizeCombo" Margin="0,3">
                    <ComboBoxItem Content="8"/>
                    <ComboBoxItem Content="10"/>
                    <ComboBoxItem Content="12" IsSelected="True"/>
                    <ComboBoxItem Content="14"/>
                    <ComboBoxItem Content="16"/>
                    <ComboBoxItem Content="18"/>
                    <ComboBoxItem Content="20"/>
                    <ComboBoxItem Content="24"/>
                    <ComboBoxItem Content="28"/>
                    <ComboBoxItem Content="32"/>
                </ComboBox>

                <!-- Style -->
                <TextBlock Grid.Row="1" Grid.Column="0" Text="Style:" VerticalAlignment="Center"/>
                <StackPanel Grid.Row="1" Grid.Column="1" Orientation="Horizontal" Margin="0,5">
                    <CheckBox x:Name="BoldCheck" Content="Bold" Margin="0,0,15,0"/>
                    <CheckBox x:Name="ItalicCheck" Content="Italic"/>
                </StackPanel>

                <!-- Color -->
                <TextBlock Grid.Row="1" Grid.Column="2" Text="Color:" VerticalAlignment="Center" Margin="10,0,0,0"/>
                <StackPanel Grid.Row="1" Grid.Column="3" Orientation="Horizontal" Margin="0,5">
                    <Border x:Name="ColorPreview" Width="25" Height="20" Background="Black" 
                            BorderBrush="#CCC" BorderThickness="1" CornerRadius="3"/>
                    <Button Content="..." Width="25" Margin="5,0,0,0" Click="ChooseColor_Click"/>
                </StackPanel>

                <!-- Border -->
                <TextBlock Grid.Row="2" Grid.Column="0" Text="Border:" VerticalAlignment="Center"/>
                <CheckBox Grid.Row="2" Grid.Column="1" x:Name="BorderCheck" Content="Show Border" Margin="0,5"/>
            </Grid>
        </GroupBox>

        <!-- Preview -->
        <GroupBox Grid.Row="3" Header="Preview" Padding="10">
            <Border BorderBrush="#DDD" BorderThickness="1" Background="White">
                <TextBlock x:Name="PreviewText" Text="Preview Text" Padding="10"
                           HorizontalAlignment="Center" VerticalAlignment="Center"/>
            </Border>
        </GroupBox>

        <!-- Buttons -->
        <StackPanel Grid.Row="4" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
            <Button Content="Cancel" Width="80" Padding="5,8" Margin="0,0,10,0"
                    Background="#EEE" BorderThickness="0" Cursor="Hand" Click="Cancel_Click"/>
            <Button Content="OK" Width="80" Padding="5,8"
                    Background="#4FC3F7" Foreground="White" BorderThickness="0" 
                    Cursor="Hand" Click="OK_Click"/>
        </StackPanel>
    </Grid>
</Window>


==================================================
FILE_NAME: TextAnnotationDialog.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\graphs\TextAnnotationDialog.xaml.cs
==================================================
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace BioSAK
{
    public partial class TextAnnotationDialog : Window
    {
        public string AnnotationText { get; private set; } = "";
        public double SelectedFontSize { get; private set; } = 12;
        public FontFamily SelectedFontFamily { get; private set; } = new FontFamily("Segoe UI");
        public bool IsBold { get; private set; } = false;
        public bool IsItalic { get; private set; } = false;
        public bool ShowBorder { get; private set; } = false;
        public Color TextColor { get; private set; } = Colors.Black;

        public TextAnnotationDialog()
        {
            InitializeComponent();
            SetupEventHandlers();
            UpdatePreview();
        }

        public TextAnnotationDialog(string existingText, TextFormatInfo format)
        {
            InitializeComponent();

            // Set existing values
            TextInput.Text = existingText;
            TextColor = format.TextColor;
            ColorPreview.Background = new SolidColorBrush(format.TextColor);
            BoldCheck.IsChecked = format.IsBold;
            ItalicCheck.IsChecked = format.IsItalic;
            BorderCheck.IsChecked = format.ShowBorder;

            // Find and select font family
            foreach (ComboBoxItem item in FontFamilyCombo.Items)
            {
                if (item.Content.ToString() == format.FontFamily.Source)
                {
                    FontFamilyCombo.SelectedItem = item;
                    break;
                }
            }

            // Find and select font size
            foreach (ComboBoxItem item in FontSizeCombo.Items)
            {
                if (item.Content.ToString() == format.FontSize.ToString())
                {
                    FontSizeCombo.SelectedItem = item;
                    break;
                }
            }

            SetupEventHandlers();
            UpdatePreview();
        }

        private void SetupEventHandlers()
        {
            TextInput.TextChanged += (s, e) => UpdatePreview();
            FontFamilyCombo.SelectionChanged += (s, e) => UpdatePreview();
            FontSizeCombo.SelectionChanged += (s, e) => UpdatePreview();
            BoldCheck.Checked += (s, e) => UpdatePreview();
            BoldCheck.Unchecked += (s, e) => UpdatePreview();
            ItalicCheck.Checked += (s, e) => UpdatePreview();
            ItalicCheck.Unchecked += (s, e) => UpdatePreview();
        }

        private void UpdatePreview()
        {
            if (PreviewText == null) return;

            string text = string.IsNullOrEmpty(TextInput.Text) ? "Preview Text" : TextInput.Text;
            PreviewText.Text = text;

            if (FontFamilyCombo.SelectedItem is ComboBoxItem fontItem)
            {
                PreviewText.FontFamily = new FontFamily(fontItem.Content.ToString() ?? "Segoe UI");
            }

            if (FontSizeCombo.SelectedItem is ComboBoxItem sizeItem)
            {
                if (double.TryParse(sizeItem.Content.ToString(), out double size))
                {
                    PreviewText.FontSize = size;
                }
            }

            PreviewText.FontWeight = BoldCheck.IsChecked == true ? FontWeights.Bold : FontWeights.Normal;
            PreviewText.FontStyle = ItalicCheck.IsChecked == true ? FontStyles.Italic : FontStyles.Normal;
            PreviewText.Foreground = new SolidColorBrush(TextColor);
        }

        private void InsertSymbol_Click(object sender, RoutedEventArgs e)
        {
            var symbolPicker = new SymbolPickerDialog();
            symbolPicker.Owner = this;
            if (symbolPicker.ShowDialog() == true && !string.IsNullOrEmpty(symbolPicker.SelectedSymbol))
            {
                int caretIndex = TextInput.CaretIndex;
                TextInput.Text = TextInput.Text.Insert(caretIndex, symbolPicker.SelectedSymbol);
                TextInput.CaretIndex = caretIndex + symbolPicker.SelectedSymbol.Length;
                TextInput.Focus();
            }
        }

        private void ChooseColor_Click(object sender, RoutedEventArgs e)
        {
            var colorDialog = new ColorPickerDialog(TextColor);
            colorDialog.Owner = this;
            if (colorDialog.ShowDialog() == true)
            {
                TextColor = colorDialog.SelectedColor;
                ColorPreview.Background = new SolidColorBrush(TextColor);
                UpdatePreview();
            }
        }

        private void OK_Click(object sender, RoutedEventArgs e)
        {
            AnnotationText = TextInput.Text;

            if (FontFamilyCombo.SelectedItem is ComboBoxItem fontItem)
            {
                SelectedFontFamily = new FontFamily(fontItem.Content.ToString() ?? "Segoe UI");
            }

            if (FontSizeCombo.SelectedItem is ComboBoxItem sizeItem)
            {
                if (double.TryParse(sizeItem.Content.ToString(), out double size))
                {
                    SelectedFontSize = size;
                }
            }

            IsBold = BoldCheck.IsChecked == true;
            IsItalic = ItalicCheck.IsChecked == true;
            ShowBorder = BorderCheck.IsChecked == true;

            DialogResult = true;
            Close();
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}


==================================================
FILE_NAME: AboutWindow.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\AboutWindow.xaml
==================================================
<Window x:Class="BioSAK.AboutWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="About BioSAK" 
        Height="500" Width="450"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#FAFAFA">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Header with Logo -->
        <Border Grid.Row="0" Background="#2196F3" Padding="30">
            <StackPanel HorizontalAlignment="Center">
                <Image Source="/Fig/ICON.png" Width="80" Height="80" 
                       RenderOptions.BitmapScalingMode="HighQuality"
                       HorizontalAlignment="Center"/>
                <TextBlock Text="BioXAK" FontSize="28" FontWeight="Bold" 
                           Foreground="White" HorizontalAlignment="Center" Margin="0,15,0,5"/>
                <TextBlock FontSize="14" 
                           Foreground="#E3F2FD" HorizontalAlignment="Center"><Run Text="Biology X Analysis Kit"/></TextBlock>
                <TextBlock x:Name="VersionText" Text="Version 0.6" FontSize="12" 
                           Foreground="#BBDEFB" HorizontalAlignment="Center" Margin="0,5,0,0"/>
            </StackPanel>
        </Border>

        <!-- Content -->
        <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto" Padding="25">
            <StackPanel>
                <!-- Description -->
                <TextBlock Text="About" FontSize="16" FontWeight="SemiBold" Foreground="#333" Margin="0,0,0,10"/>
                <TextBlock TextWrapping="Wrap" Foreground="#666" FontSize="13" LineHeight="22"><Run Text="Bio"/><Run Language="zh-tw" Text="X"/><Run Text="AK is a comprehensive bioinformatics toolkit designed for life science researchers, providing an all-in-one solution from data visualization to statistical analysis."/></TextBlock>

                <!-- Features -->
                <TextBlock Text="Key Features" FontSize="16" FontWeight="SemiBold" Foreground="#333" Margin="0,25,0,10"/>
                <StackPanel Margin="5,0,0,0">
                    <TextBlock Text="📊  GraphGen - Scientific Chart Generator" Foreground="#555" Margin="0,3"/>
                    <TextBlock Text="📈  Statistical Analysis (T-Test, ANOVA)" Foreground="#555" Margin="0,3"/>
                    <TextBlock Text="🧬  sgRNA Designer for CRISPR" Foreground="#555" Margin="0,3"/>
                    <TextBlock Text="🔬  Restriction Enzyme Analysis" Foreground="#555" Margin="0,3"/>
                    <TextBlock Text="⚖️  Molecular Weight Calculator" Foreground="#555" Margin="0,3"/>
                    <TextBlock Text="📈  Flow Cytometry Tools" Foreground="#555" Margin="0,3"/>
                </StackPanel>

                <!-- Contact -->
                <TextBlock Text="Contact" FontSize="16" FontWeight="SemiBold" Foreground="#333" Margin="0,25,0,10"/>
                <StackPanel Margin="5,0,0,0">
                    <StackPanel Orientation="Horizontal" Margin="0,5">
                        <TextBlock Text="📧  Email:" Foreground="#555" Width="70"/>
                        <TextBlock x:Name="EmailLink" Text="bowtobyd@gmail.com" Foreground="#2196F3" 
                                   Cursor="Hand" TextDecorations="Underline"
                                   MouseLeftButtonUp="EmailLink_Click"
                                   ToolTip="Click to copy email address"/>
                    </StackPanel>
                </StackPanel>

                <!-- Copyright -->
                <TextBlock Text="© 2024 BioXAK. All rights reserved." 
                           Foreground="#999" FontSize="11" 
                           HorizontalAlignment="Center" Margin="0,30,0,0"/>
            </StackPanel>
        </ScrollViewer>

        <!-- Close Button -->
        <Border Grid.Row="2" Padding="20" Background="#F5F5F5" BorderBrush="#E0E0E0" BorderThickness="0,1,0,0">
            <Button Content="Close" Width="100" Height="35" 
                    Background="#2196F3" Foreground="White" 
                    BorderThickness="0" Cursor="Hand"
                    FontSize="14" FontWeight="SemiBold"
                    Click="Close_Click">
                <Button.Template>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" 
                                CornerRadius="5" Padding="15,8">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#1976D2"/>
                            </Trigger>
                            <Trigger Property="IsPressed" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#1565C0"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Button.Template>
            </Button>
        </Border>
    </Grid>
</Window>


==================================================
FILE_NAME: AboutWindow.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\AboutWindow.xaml.cs
==================================================
using System;
using System.Reflection;
using System.Windows;
using System.Windows.Input;

namespace BioSAK
{
    public partial class AboutWindow : Window
    {
        public AboutWindow()
        {
            InitializeComponent();

            // Set version from assembly
            try
            {
                var version = Assembly.GetExecutingAssembly().GetName().Version;
                if (version != null)
                {
                    VersionText.Text = $"Version {version.Major}.{version.Minor}.{version.Build}";
                }
            }
            catch
            {
                VersionText.Text = "Version 1.0.0";
            }
        }

        private void EmailLink_Click(object sender, MouseButtonEventArgs e)
        {
            try
            {
                // Copy email to clipboard
                Clipboard.SetText("bowtobyd@gmail.com");
                MessageBox.Show("Email address copied to clipboard!", "Copied",
                    MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Could not copy email: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void Close_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }
    }
}


==================================================
FILE_NAME: ConcCal.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\ConcCal.xaml
==================================================
<Page x:Class="BioSAK.ConcCal"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      xmlns:local="clr-namespace:BioSAK"
      mc:Ignorable="d" 
      d:DesignHeight="700" d:DesignWidth="980"
      Title="Molecular Weight Calculator"
      Background="#F5F5F5">

    <Page.Resources>
        <!-- Element Button Style -->
        <Style x:Key="ElementButtonStyle" TargetType="Button">
            <Setter Property="Width" Value="48"/>
            <Setter Property="Height" Value="48"/>
            <Setter Property="Margin" Value="1"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" 
                                Background="{TemplateBinding Background}"
                                CornerRadius="4">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Effect">
                                    <Setter.Value>
                                        <DropShadowEffect ShadowDepth="2" BlurRadius="8" Opacity="0.4"/>
                                    </Setter.Value>
                                </Setter>
                                <Setter TargetName="border" Property="RenderTransform">
                                    <Setter.Value>
                                        <ScaleTransform ScaleX="1.1" ScaleY="1.1"/>
                                    </Setter.Value>
                                </Setter>
                                <Setter TargetName="border" Property="RenderTransformOrigin" Value="0.5,0.5"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <!-- Empty Cell Style -->
        <Style x:Key="EmptyCellStyle" TargetType="Border">
            <Setter Property="Width" Value="48"/>
            <Setter Property="Height" Value="48"/>
            <Setter Property="Margin" Value="1"/>
            <Setter Property="Background" Value="Transparent"/>
        </Style>

        <!-- Category Colors -->
        <SolidColorBrush x:Key="AlkaliColor" Color="#FF6B6B"/>
        <SolidColorBrush x:Key="AlkalineColor" Color="#FFA502"/>
        <SolidColorBrush x:Key="TransitionColor" Color="#FFD93D"/>
        <SolidColorBrush x:Key="PostTransitionColor" Color="#6BCB77"/>
        <SolidColorBrush x:Key="MetalloidColor" Color="#4D96FF"/>
        <SolidColorBrush x:Key="NonmetalColor" Color="#A66CFF"/>
        <SolidColorBrush x:Key="HalogenColor" Color="#00D4FF"/>
        <SolidColorBrush x:Key="NobleColor" Color="#FF6B9D"/>
        <SolidColorBrush x:Key="LanthanideColor" Color="#81D4FA"/>
        <SolidColorBrush x:Key="ActinideColor" Color="#FFAB91"/>
    </Page.Resources>

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Title -->
        <TextBlock Grid.Row="0" Text="⚖️ Molecular Weight Calculator" 
                   FontSize="24" FontWeight="Bold" Foreground="#333"
                   Margin="0,0,0,15"/>

        <!-- Input Section -->
        <Border Grid.Row="1" Background="White" CornerRadius="10" Padding="20" Margin="0,0,0,15">
            <Border.Effect>
                <DropShadowEffect ShadowDepth="1" BlurRadius="10" Opacity="0.1"/>
            </Border.Effect>
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- Formula Input -->
                <StackPanel Grid.Row="0" Grid.ColumnSpan="2" Margin="0,0,0,15">
                    <TextBlock Text="Chemical Formula" FontWeight="SemiBold" Foreground="#555" Margin="0,0,0,5"/>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>
                        <TextBox x:Name="FormulaInput" Grid.Column="0"
                                 FontSize="20" FontFamily="Consolas"
                                 Padding="10" BorderThickness="1" BorderBrush="#DDD"
                                 VerticalContentAlignment="Center"
                                 KeyDown="FormulaInput_KeyDown"/>
                        <Button Grid.Column="1" Content="Calculate" 
                                Padding="20,10" Margin="10,0,0,0"
                                Background="#4FC3F7" Foreground="White" FontWeight="SemiBold"
                                BorderThickness="0" Cursor="Hand"
                                Click="Calculate_Click"/>
                        <Button Grid.Column="2" Content="Clear" 
                                Padding="20,10" Margin="10,0,0,0"
                                Background="#EF5350" Foreground="White" FontWeight="SemiBold"
                                BorderThickness="0" Cursor="Hand"
                                Click="Clear_Click"/>
                    </Grid>
                </StackPanel>

                <!-- Element Breakdown -->
                <StackPanel Grid.Row="1" Grid.Column="0" Margin="0,0,10,0">
                    <TextBlock Text="Element Breakdown" FontWeight="SemiBold" Foreground="#4FC3F7" Margin="0,0,0,5"/>
                    <Border Background="#F8F9FA" CornerRadius="5" Padding="10" MinHeight="80">
                        <TextBlock x:Name="ElementBreakdown" Text="-" 
                                   FontFamily="Consolas" TextWrapping="Wrap"/>
                    </Border>
                </StackPanel>

                <!-- Total Weight -->
                <StackPanel Grid.Row="1" Grid.Column="1" Margin="10,0,0,0">
                    <TextBlock Text="Molecular Weight" FontWeight="SemiBold" Foreground="#4FC3F7" Margin="0,0,0,5"/>
                    <Border Background="#F8F9FA" CornerRadius="5" Padding="10" MinHeight="80">
                        <TextBlock x:Name="TotalWeight" Text="-" 
                                   FontSize="24" FontWeight="Bold" Foreground="#4CAF50"
                                   VerticalAlignment="Center"/>
                    </Border>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Legend -->
        <WrapPanel Grid.Row="2" Margin="0,0,0,10" HorizontalAlignment="Center">
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource AlkaliColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Alkali" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource AlkalineColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Alkaline Earth" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource TransitionColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Transition" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource PostTransitionColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Post-transition" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource MetalloidColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Metalloid" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource NonmetalColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Nonmetal" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource HalogenColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Halogen" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource NobleColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Noble Gas" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource LanthanideColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Lanthanide" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="5,2">
                <Border Width="16" Height="16" Background="{StaticResource ActinideColor}" CornerRadius="2" Margin="0,0,5,0"/>
                <TextBlock Text="Actinide" FontSize="11" VerticalAlignment="Center"/>
            </StackPanel>
        </WrapPanel>

        <!-- Periodic Table -->
        <Border Grid.Row="3" Background="White" CornerRadius="10" Padding="15">
            <Border.Effect>
                <DropShadowEffect ShadowDepth="1" BlurRadius="10" Opacity="0.1"/>
            </Border.Effect>
            <ScrollViewer HorizontalScrollBarVisibility="Auto" VerticalScrollBarVisibility="Auto">
                <StackPanel x:Name="PeriodicTablePanel" HorizontalAlignment="Center"/>
            </ScrollViewer>
        </Border>
    </Grid>
</Page>

==================================================
FILE_NAME: ConcCal.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\ConcCal.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;

namespace BioSAK
{
    public partial class ConcCal : Page
    {
        // Element data structure
        private class Element
        {
            public int Number { get; set; }
            public string Symbol { get; set; } = string.Empty;
            public double Weight { get; set; }
            public string Category { get; set; } = string.Empty;
        }

        // All elements dictionary
        private readonly Dictionary<string, Element> elements = new Dictionary<string, Element>
        {
            {"H", new Element { Number = 1, Symbol = "H", Weight = 1.008, Category = "nonmetal" }},
            {"He", new Element { Number = 2, Symbol = "He", Weight = 4.003, Category = "noble" }},
            {"Li", new Element { Number = 3, Symbol = "Li", Weight = 6.941, Category = "alkali" }},
            {"Be", new Element { Number = 4, Symbol = "Be", Weight = 9.012, Category = "alkaline" }},
            {"B", new Element { Number = 5, Symbol = "B", Weight = 10.81, Category = "metalloid" }},
            {"C", new Element { Number = 6, Symbol = "C", Weight = 12.01, Category = "nonmetal" }},
            {"N", new Element { Number = 7, Symbol = "N", Weight = 14.01, Category = "nonmetal" }},
            {"O", new Element { Number = 8, Symbol = "O", Weight = 16.00, Category = "nonmetal" }},
            {"F", new Element { Number = 9, Symbol = "F", Weight = 19.00, Category = "halogen" }},
            {"Ne", new Element { Number = 10, Symbol = "Ne", Weight = 20.18, Category = "noble" }},
            {"Na", new Element { Number = 11, Symbol = "Na", Weight = 22.99, Category = "alkali" }},
            {"Mg", new Element { Number = 12, Symbol = "Mg", Weight = 24.31, Category = "alkaline" }},
            {"Al", new Element { Number = 13, Symbol = "Al", Weight = 26.98, Category = "post-transition" }},
            {"Si", new Element { Number = 14, Symbol = "Si", Weight = 28.09, Category = "metalloid" }},
            {"P", new Element { Number = 15, Symbol = "P", Weight = 30.97, Category = "nonmetal" }},
            {"S", new Element { Number = 16, Symbol = "S", Weight = 32.07, Category = "nonmetal" }},
            {"Cl", new Element { Number = 17, Symbol = "Cl", Weight = 35.45, Category = "halogen" }},
            {"Ar", new Element { Number = 18, Symbol = "Ar", Weight = 39.95, Category = "noble" }},
            {"K", new Element { Number = 19, Symbol = "K", Weight = 39.10, Category = "alkali" }},
            {"Ca", new Element { Number = 20, Symbol = "Ca", Weight = 40.08, Category = "alkaline" }},
            {"Sc", new Element { Number = 21, Symbol = "Sc", Weight = 44.96, Category = "transition" }},
            {"Ti", new Element { Number = 22, Symbol = "Ti", Weight = 47.87, Category = "transition" }},
            {"V", new Element { Number = 23, Symbol = "V", Weight = 50.94, Category = "transition" }},
            {"Cr", new Element { Number = 24, Symbol = "Cr", Weight = 52.00, Category = "transition" }},
            {"Mn", new Element { Number = 25, Symbol = "Mn", Weight = 54.94, Category = "transition" }},
            {"Fe", new Element { Number = 26, Symbol = "Fe", Weight = 55.85, Category = "transition" }},
            {"Co", new Element { Number = 27, Symbol = "Co", Weight = 58.93, Category = "transition" }},
            {"Ni", new Element { Number = 28, Symbol = "Ni", Weight = 58.69, Category = "transition" }},
            {"Cu", new Element { Number = 29, Symbol = "Cu", Weight = 63.55, Category = "transition" }},
            {"Zn", new Element { Number = 30, Symbol = "Zn", Weight = 65.38, Category = "transition" }},
            {"Ga", new Element { Number = 31, Symbol = "Ga", Weight = 69.72, Category = "post-transition" }},
            {"Ge", new Element { Number = 32, Symbol = "Ge", Weight = 72.63, Category = "metalloid" }},
            {"As", new Element { Number = 33, Symbol = "As", Weight = 74.92, Category = "metalloid" }},
            {"Se", new Element { Number = 34, Symbol = "Se", Weight = 78.97, Category = "nonmetal" }},
            {"Br", new Element { Number = 35, Symbol = "Br", Weight = 79.90, Category = "halogen" }},
            {"Kr", new Element { Number = 36, Symbol = "Kr", Weight = 83.80, Category = "noble" }},
            {"Rb", new Element { Number = 37, Symbol = "Rb", Weight = 85.47, Category = "alkali" }},
            {"Sr", new Element { Number = 38, Symbol = "Sr", Weight = 87.62, Category = "alkaline" }},
            {"Y", new Element { Number = 39, Symbol = "Y", Weight = 88.91, Category = "transition" }},
            {"Zr", new Element { Number = 40, Symbol = "Zr", Weight = 91.22, Category = "transition" }},
            {"Nb", new Element { Number = 41, Symbol = "Nb", Weight = 92.91, Category = "transition" }},
            {"Mo", new Element { Number = 42, Symbol = "Mo", Weight = 95.95, Category = "transition" }},
            {"Tc", new Element { Number = 43, Symbol = "Tc", Weight = 98.00, Category = "transition" }},
            {"Ru", new Element { Number = 44, Symbol = "Ru", Weight = 101.1, Category = "transition" }},
            {"Rh", new Element { Number = 45, Symbol = "Rh", Weight = 102.9, Category = "transition" }},
            {"Pd", new Element { Number = 46, Symbol = "Pd", Weight = 106.4, Category = "transition" }},
            {"Ag", new Element { Number = 47, Symbol = "Ag", Weight = 107.9, Category = "transition" }},
            {"Cd", new Element { Number = 48, Symbol = "Cd", Weight = 112.4, Category = "transition" }},
            {"In", new Element { Number = 49, Symbol = "In", Weight = 114.8, Category = "post-transition" }},
            {"Sn", new Element { Number = 50, Symbol = "Sn", Weight = 118.7, Category = "post-transition" }},
            {"Sb", new Element { Number = 51, Symbol = "Sb", Weight = 121.8, Category = "metalloid" }},
            {"Te", new Element { Number = 52, Symbol = "Te", Weight = 127.6, Category = "metalloid" }},
            {"I", new Element { Number = 53, Symbol = "I", Weight = 126.9, Category = "halogen" }},
            {"Xe", new Element { Number = 54, Symbol = "Xe", Weight = 131.3, Category = "noble" }},
            {"Cs", new Element { Number = 55, Symbol = "Cs", Weight = 132.9, Category = "alkali" }},
            {"Ba", new Element { Number = 56, Symbol = "Ba", Weight = 137.3, Category = "alkaline" }},
            {"La", new Element { Number = 57, Symbol = "La", Weight = 138.9, Category = "lanthanide" }},
            {"Ce", new Element { Number = 58, Symbol = "Ce", Weight = 140.1, Category = "lanthanide" }},
            {"Pr", new Element { Number = 59, Symbol = "Pr", Weight = 140.9, Category = "lanthanide" }},
            {"Nd", new Element { Number = 60, Symbol = "Nd", Weight = 144.2, Category = "lanthanide" }},
            {"Pm", new Element { Number = 61, Symbol = "Pm", Weight = 145.0, Category = "lanthanide" }},
            {"Sm", new Element { Number = 62, Symbol = "Sm", Weight = 150.4, Category = "lanthanide" }},
            {"Eu", new Element { Number = 63, Symbol = "Eu", Weight = 152.0, Category = "lanthanide" }},
            {"Gd", new Element { Number = 64, Symbol = "Gd", Weight = 157.3, Category = "lanthanide" }},
            {"Tb", new Element { Number = 65, Symbol = "Tb", Weight = 158.9, Category = "lanthanide" }},
            {"Dy", new Element { Number = 66, Symbol = "Dy", Weight = 162.5, Category = "lanthanide" }},
            {"Ho", new Element { Number = 67, Symbol = "Ho", Weight = 164.9, Category = "lanthanide" }},
            {"Er", new Element { Number = 68, Symbol = "Er", Weight = 167.3, Category = "lanthanide" }},
            {"Tm", new Element { Number = 69, Symbol = "Tm", Weight = 168.9, Category = "lanthanide" }},
            {"Yb", new Element { Number = 70, Symbol = "Yb", Weight = 173.0, Category = "lanthanide" }},
            {"Lu", new Element { Number = 71, Symbol = "Lu", Weight = 175.0, Category = "lanthanide" }},
            {"Hf", new Element { Number = 72, Symbol = "Hf", Weight = 178.5, Category = "transition" }},
            {"Ta", new Element { Number = 73, Symbol = "Ta", Weight = 180.9, Category = "transition" }},
            {"W", new Element { Number = 74, Symbol = "W", Weight = 183.8, Category = "transition" }},
            {"Re", new Element { Number = 75, Symbol = "Re", Weight = 186.2, Category = "transition" }},
            {"Os", new Element { Number = 76, Symbol = "Os", Weight = 190.2, Category = "transition" }},
            {"Ir", new Element { Number = 77, Symbol = "Ir", Weight = 192.2, Category = "transition" }},
            {"Pt", new Element { Number = 78, Symbol = "Pt", Weight = 195.1, Category = "transition" }},
            {"Au", new Element { Number = 79, Symbol = "Au", Weight = 197.0, Category = "transition" }},
            {"Hg", new Element { Number = 80, Symbol = "Hg", Weight = 200.6, Category = "transition" }},
            {"Tl", new Element { Number = 81, Symbol = "Tl", Weight = 204.4, Category = "post-transition" }},
            {"Pb", new Element { Number = 82, Symbol = "Pb", Weight = 207.2, Category = "post-transition" }},
            {"Bi", new Element { Number = 83, Symbol = "Bi", Weight = 209.0, Category = "post-transition" }},
            {"Po", new Element { Number = 84, Symbol = "Po", Weight = 209.0, Category = "metalloid" }},
            {"At", new Element { Number = 85, Symbol = "At", Weight = 210.0, Category = "halogen" }},
            {"Rn", new Element { Number = 86, Symbol = "Rn", Weight = 222.0, Category = "noble" }},
            {"Fr", new Element { Number = 87, Symbol = "Fr", Weight = 223.0, Category = "alkali" }},
            {"Ra", new Element { Number = 88, Symbol = "Ra", Weight = 226.0, Category = "alkaline" }},
            {"Ac", new Element { Number = 89, Symbol = "Ac", Weight = 227.0, Category = "actinide" }},
            {"Th", new Element { Number = 90, Symbol = "Th", Weight = 232.0, Category = "actinide" }},
            {"Pa", new Element { Number = 91, Symbol = "Pa", Weight = 231.0, Category = "actinide" }},
            {"U", new Element { Number = 92, Symbol = "U", Weight = 238.0, Category = "actinide" }},
            {"Np", new Element { Number = 93, Symbol = "Np", Weight = 237.0, Category = "actinide" }},
            {"Pu", new Element { Number = 94, Symbol = "Pu", Weight = 244.0, Category = "actinide" }},
            {"Am", new Element { Number = 95, Symbol = "Am", Weight = 243.0, Category = "actinide" }},
            {"Cm", new Element { Number = 96, Symbol = "Cm", Weight = 247.0, Category = "actinide" }},
            {"Bk", new Element { Number = 97, Symbol = "Bk", Weight = 247.0, Category = "actinide" }},
            {"Cf", new Element { Number = 98, Symbol = "Cf", Weight = 251.0, Category = "actinide" }},
            {"Es", new Element { Number = 99, Symbol = "Es", Weight = 252.0, Category = "actinide" }},
            {"Fm", new Element { Number = 100, Symbol = "Fm", Weight = 257.0, Category = "actinide" }},
            {"Md", new Element { Number = 101, Symbol = "Md", Weight = 258.0, Category = "actinide" }},
            {"No", new Element { Number = 102, Symbol = "No", Weight = 259.0, Category = "actinide" }},
            {"Lr", new Element { Number = 103, Symbol = "Lr", Weight = 262.0, Category = "actinide" }},
            {"Rf", new Element { Number = 104, Symbol = "Rf", Weight = 267.0, Category = "transition" }},
            {"Db", new Element { Number = 105, Symbol = "Db", Weight = 270.0, Category = "transition" }},
            {"Sg", new Element { Number = 106, Symbol = "Sg", Weight = 271.0, Category = "transition" }},
            {"Bh", new Element { Number = 107, Symbol = "Bh", Weight = 270.0, Category = "transition" }},
            {"Hs", new Element { Number = 108, Symbol = "Hs", Weight = 277.0, Category = "transition" }},
            {"Mt", new Element { Number = 109, Symbol = "Mt", Weight = 276.0, Category = "transition" }},
            {"Ds", new Element { Number = 110, Symbol = "Ds", Weight = 281.0, Category = "transition" }},
            {"Rg", new Element { Number = 111, Symbol = "Rg", Weight = 282.0, Category = "transition" }},
            {"Cn", new Element { Number = 112, Symbol = "Cn", Weight = 285.0, Category = "transition" }},
            {"Nh", new Element { Number = 113, Symbol = "Nh", Weight = 286.0, Category = "post-transition" }},
            {"Fl", new Element { Number = 114, Symbol = "Fl", Weight = 289.0, Category = "post-transition" }},
            {"Mc", new Element { Number = 115, Symbol = "Mc", Weight = 290.0, Category = "post-transition" }},
            {"Lv", new Element { Number = 116, Symbol = "Lv", Weight = 293.0, Category = "post-transition" }},
            {"Ts", new Element { Number = 117, Symbol = "Ts", Weight = 294.0, Category = "halogen" }},
            {"Og", new Element { Number = 118, Symbol = "Og", Weight = 294.0, Category = "noble" }}
        };

        // Periodic table layout
        private readonly string[][] tableLayout = new string[][]
        {
            new[] {"H", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "He"},
            new[] {"Li", "Be", "", "", "", "", "", "", "", "", "", "", "B", "C", "N", "O", "F", "Ne"},
            new[] {"Na", "Mg", "", "", "", "", "", "", "", "", "", "", "Al", "Si", "P", "S", "Cl", "Ar"},
            new[] {"K", "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr"},
            new[] {"Rb", "Sr", "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te", "I", "Xe"},
            new[] {"Cs", "Ba", "La", "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rn"},
            new[] {"Fr", "Ra", "Ac", "Rf", "Db", "Sg", "Bh", "Hs", "Mt", "Ds", "Rg", "Cn", "Nh", "Fl", "Mc", "Lv", "Ts", "Og"},
            new[] {"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""},
            new[] {"", "", "*", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb", "Lu", ""},
            new[] {"", "", "*", "Th", "Pa", "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No", "Lr", ""}
        };

        // Category colors
        private readonly Dictionary<string, Color> categoryColors = new Dictionary<string, Color>
        {
            {"alkali", Color.FromRgb(255, 107, 107)},
            {"alkaline", Color.FromRgb(255, 165, 2)},
            {"transition", Color.FromRgb(255, 217, 61)},
            {"post-transition", Color.FromRgb(107, 203, 119)},
            {"metalloid", Color.FromRgb(77, 150, 255)},
            {"nonmetal", Color.FromRgb(166, 108, 255)},
            {"halogen", Color.FromRgb(0, 212, 255)},
            {"noble", Color.FromRgb(255, 107, 157)},
            {"lanthanide", Color.FromRgb(129, 212, 250)},
            {"actinide", Color.FromRgb(255, 171, 145)}
        };

        public ConcCal()
        {
            InitializeComponent();
            BuildPeriodicTable();
        }

        private void BuildPeriodicTable()
        {
            for (int row = 0; row < tableLayout.Length; row++)
            {
                var rowPanel = new StackPanel { Orientation = Orientation.Horizontal };

                for (int col = 0; col < tableLayout[row].Length; col++)
                {
                    string cell = tableLayout[row][col];

                    if (string.IsNullOrEmpty(cell))
                    {
                        // Empty cell
                        var empty = new Border
                        {
                            Width = 48,
                            Height = 48,
                            Margin = new Thickness(1),
                            Background = Brushes.Transparent
                        };
                        rowPanel.Children.Add(empty);
                    }
                    else if (cell == "*")
                    {
                        // Label for lanthanides/actinides
                        var label = new Border
                        {
                            Width = 48,
                            Height = 48,
                            Margin = new Thickness(1),
                            Background = Brushes.Transparent
                        };
                        var text = new TextBlock
                        {
                            Text = row == 8 ? "57-71" : "89-103",
                            FontSize = 10,
                            Foreground = new SolidColorBrush(Color.FromRgb(144, 164, 174)),
                            HorizontalAlignment = HorizontalAlignment.Center,
                            VerticalAlignment = VerticalAlignment.Center
                        };
                        label.Child = text;
                        rowPanel.Children.Add(label);
                    }
                    else if (elements.ContainsKey(cell))
                    {
                        // Element button
                        var el = elements[cell];
                        var btn = CreateElementButton(el);
                        rowPanel.Children.Add(btn);
                    }
                }

                PeriodicTablePanel.Children.Add(rowPanel);
            }
        }

        private Button CreateElementButton(Element el)
        {
            var color = categoryColors.ContainsKey(el.Category)
                ? categoryColors[el.Category]
                : Color.FromRgb(55, 71, 79);

            var foreground = (el.Category == "transition")
                ? Brushes.Black
                : Brushes.White;

            var btn = new Button
            {
                Width = 48,
                Height = 48,
                Margin = new Thickness(1),
                Background = new SolidColorBrush(color),
                BorderThickness = new Thickness(0),
                Cursor = Cursors.Hand,
                Tag = el.Symbol
            };

            var content = new StackPanel
            {
                VerticalAlignment = VerticalAlignment.Center,
                HorizontalAlignment = HorizontalAlignment.Center
            };

            content.Children.Add(new TextBlock
            {
                Text = el.Number.ToString(),
                FontSize = 8,
                Foreground = foreground,
                Opacity = 0.8,
                HorizontalAlignment = HorizontalAlignment.Center
            });

            content.Children.Add(new TextBlock
            {
                Text = el.Symbol,
                FontSize = 14,
                FontWeight = FontWeights.Bold,
                Foreground = foreground,
                HorizontalAlignment = HorizontalAlignment.Center
            });

            content.Children.Add(new TextBlock
            {
                Text = el.Weight.ToString("F2"),
                FontSize = 7,
                Foreground = foreground,
                Opacity = 0.7,
                HorizontalAlignment = HorizontalAlignment.Center
            });

            btn.Content = content;
            btn.Click += ElementButton_Click;

            // Apply style for hover effect
            btn.Style = CreateElementButtonStyle(color);

            return btn;
        }

        private Style CreateElementButtonStyle(Color baseColor)
        {
            var style = new Style(typeof(Button));

            var template = new ControlTemplate(typeof(Button));
            var border = new FrameworkElementFactory(typeof(Border));
            border.Name = "border";
            border.SetValue(Border.BackgroundProperty, new SolidColorBrush(baseColor));
            border.SetValue(Border.CornerRadiusProperty, new CornerRadius(4));

            var contentPresenter = new FrameworkElementFactory(typeof(ContentPresenter));
            contentPresenter.SetValue(ContentPresenter.HorizontalAlignmentProperty, HorizontalAlignment.Center);
            contentPresenter.SetValue(ContentPresenter.VerticalAlignmentProperty, VerticalAlignment.Center);
            border.AppendChild(contentPresenter);

            template.VisualTree = border;

            // Mouse over trigger
            var mouseOverTrigger = new Trigger { Property = UIElement.IsMouseOverProperty, Value = true };
            mouseOverTrigger.Setters.Add(new Setter(UIElement.RenderTransformProperty, new ScaleTransform(1.1, 1.1)));
            mouseOverTrigger.Setters.Add(new Setter(UIElement.RenderTransformOriginProperty, new Point(0.5, 0.5)));
            template.Triggers.Add(mouseOverTrigger);

            style.Setters.Add(new Setter(Control.TemplateProperty, template));

            return style;
        }

        private void ElementButton_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button btn && btn.Tag is string symbol)
            {
                FormulaInput.Text += symbol;
                FormulaInput.Focus();
                FormulaInput.CaretIndex = FormulaInput.Text.Length;
            }
        }

        private void FormulaInput_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Enter)
            {
                Calculate();
            }
        }

        private void Calculate_Click(object sender, RoutedEventArgs e)
        {
            Calculate();
        }

        private void Clear_Click(object sender, RoutedEventArgs e)
        {
            FormulaInput.Text = "";
            ElementBreakdown.Text = "-";
            TotalWeight.Text = "-";
        }

        private void Calculate()
        {
            string formula = FormulaInput.Text.Trim();

            if (string.IsNullOrEmpty(formula))
            {
                ElementBreakdown.Text = "-";
                TotalWeight.Text = "-";
                return;
            }

            var parsed = ParseFormula(formula);

            if (parsed == null)
            {
                ElementBreakdown.Text = "Invalid formula";
                ElementBreakdown.Foreground = Brushes.Red;
                TotalWeight.Text = "-";
                return;
            }

            ElementBreakdown.Foreground = Brushes.Black;

            var breakdownLines = new List<string>();
            double totalWeight = 0;

            foreach (var kvp in parsed.OrderBy(x => elements[x.Key].Number))
            {
                var el = elements[kvp.Key];
                double weight = el.Weight * kvp.Value;
                totalWeight += weight;
                breakdownLines.Add($"{kvp.Key}: {kvp.Value} × {el.Weight:F3} = {weight:F3}");
            }

            ElementBreakdown.Text = string.Join("\n", breakdownLines);
            TotalWeight.Text = $"{totalWeight:F4} g/mol";
        }

        private Dictionary<string, int>? ParseFormula(string formula)
        {
            var result = new Dictionary<string, int>();

            // Match element symbols (uppercase followed by optional lowercase) and optional numbers
            var regex = new Regex(@"([A-Z][a-z]?)(\d*)");
            var matches = regex.Matches(formula);

            foreach (Match match in matches)
            {
                string symbol = match.Groups[1].Value;
                string countStr = match.Groups[2].Value;
                int count = string.IsNullOrEmpty(countStr) ? 1 : int.Parse(countStr);

                if (!elements.ContainsKey(symbol))
                {
                    return null; // Unknown element
                }

                if (result.ContainsKey(symbol))
                    result[symbol] += count;
                else
                    result[symbol] = count;
            }

            return result.Count > 0 ? result : null;
        }
    }
}


==================================================
FILE_NAME: FlowCytometryAnalyzer.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\FlowCytometryAnalyzer.xaml
==================================================
<Page x:Class="BioSAK.FlowCytometryAnalyzer"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      mc:Ignorable="d"
      Title="Flow Cytometry Analyzer"
      d:DesignHeight="720" d:DesignWidth="1400"
      Background="#F0F0F0" 
      Loaded="Window_Loaded" 
      KeyDown="Window_KeyDown">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Top Toolbar -->
        <ToolBarTray Grid.Row="0" Background="#F5F5F5">
            <ToolBar Band="0" BandIndex="0" Background="#F5F5F5">
                <Button x:Name="btnLoadFile" Content="📂 Load FCS" Click="BtnLoadFile_Click" Padding="8,4"/>
                <Button x:Name="btnLoadDemo" Content="🧪 Demo Data" Click="BtnLoadDemo_Click" Padding="8,4"/>
                <Separator/>
                <TextBlock Text="File:" VerticalAlignment="Center" Margin="5,0"/>
                <ComboBox x:Name="cboFiles" Width="180" SelectionChanged="CboFiles_SelectionChanged"/>
                <Separator/>
                <CheckBox x:Name="chkOverlay" Content="Overlay" VerticalAlignment="Center" Margin="5,0"
                          Checked="ChkOverlay_Changed" Unchecked="ChkOverlay_Changed"/>
                <ComboBox x:Name="cboOverlay" Width="150" SelectionChanged="CboOverlay_SelectionChanged" 
                          Visibility="Collapsed"/>
                <Separator/>
                <Button x:Name="btnAddAnalysis" Content="➕ Add Panel" Click="BtnAddAnalysis_Click" 
                        Padding="8,4" Background="#DFF0D8"/>
                <Button x:Name="btnRemoveAnalysis" Content="➖ Remove Panel" Click="BtnRemoveAnalysis_Click" 
                        Padding="8,4" Background="#F2DEDE"/>
            </ToolBar>
        </ToolBarTray>

        <!-- Main Content -->
        <Grid Grid.Row="1" Margin="5">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="280" MinWidth="200"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>

            <!-- Left Control Panel -->
            <Border Grid.Column="0" Background="White" BorderBrush="#CCCCCC" BorderThickness="1" Margin="0,0,5,0">
                <ScrollViewer VerticalScrollBarVisibility="Auto" Padding="10">
                    <StackPanel>
                        <!-- File Info -->
                        <TextBlock x:Name="txtFileInfo" Text="No file loaded" Foreground="#666666" 
                                   Margin="0,0,0,10" TextWrapping="Wrap"/>

                        <!-- View Type -->
                        <GroupBox Header="View Type" Margin="0,0,0,10">
                            <StackPanel Margin="5">
                                <RadioButton x:Name="rbScatter" Content="2D Scatter Plot" GroupName="ViewType"
                                             IsChecked="True" Checked="ViewType_Changed" Margin="0,0,0,5"/>
                                <RadioButton x:Name="rbHistogram" Content="Histogram" GroupName="ViewType"
                                             Checked="ViewType_Changed"/>
                            </StackPanel>
                        </GroupBox>

                        <!-- Scatter Plot Controls -->
                        <StackPanel x:Name="pnlScatterControls">
                            <GroupBox Header="Axis Settings" Margin="0,0,0,10">
                                <StackPanel Margin="5">
                                    <TextBlock Text="X Axis Parameter:" Margin="0,0,0,3"/>
                                    <ComboBox x:Name="cboXParam" Margin="0,0,0,8" SelectionChanged="Param_Changed"/>

                                    <TextBlock Text="Y Axis Parameter:" Margin="0,0,0,3"/>
                                    <ComboBox x:Name="cboYParam" Margin="0,0,0,8" SelectionChanged="Param_Changed"/>

                                    <Grid Margin="0,0,0,5">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="8"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <StackPanel Grid.Column="0">
                                            <TextBlock Text="X Scale:" Margin="0,0,0,3"/>
                                            <ComboBox x:Name="cboXScale" SelectionChanged="Scale_Changed">
                                                <ComboBoxItem Content="Linear"/>
                                                <ComboBoxItem Content="Log" IsSelected="True"/>
                                            </ComboBox>
                                        </StackPanel>
                                        <StackPanel Grid.Column="2">
                                            <TextBlock Text="Y Scale:" Margin="0,0,0,3"/>
                                            <ComboBox x:Name="cboYScale" SelectionChanged="Scale_Changed">
                                                <ComboBoxItem Content="Linear"/>
                                                <ComboBoxItem Content="Log" IsSelected="True"/>
                                            </ComboBox>
                                        </StackPanel>
                                    </Grid>
                                </StackPanel>
                            </GroupBox>

                            <GroupBox Header="Axis Range (empty = auto)" Margin="0,0,0,10">
                                <StackPanel Margin="5">
                                    <TextBlock Text="X Range:" Margin="0,0,0,3"/>
                                    <Grid Margin="0,0,0,8">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="20"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <TextBox x:Name="txtXMin" TextChanged="AxisRange_Changed" Tag="xmin"/>
                                        <TextBlock Text="~" Grid.Column="1" HorizontalAlignment="Center" VerticalAlignment="Center"/>
                                        <TextBox x:Name="txtXMax" Grid.Column="2" TextChanged="AxisRange_Changed" Tag="xmax"/>
                                    </Grid>

                                    <TextBlock Text="Y Range:" Margin="0,0,0,3"/>
                                    <Grid Margin="0,0,0,8">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="20"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <TextBox x:Name="txtYMin" TextChanged="AxisRange_Changed" Tag="ymin"/>
                                        <TextBlock Text="~" Grid.Column="1" HorizontalAlignment="Center" VerticalAlignment="Center"/>
                                        <TextBox x:Name="txtYMax" Grid.Column="2" TextChanged="AxisRange_Changed" Tag="ymax"/>
                                    </Grid>
                                    <Button Content="Reset Range" Click="BtnResetRange_Click" Padding="8,4"/>
                                </StackPanel>
                            </GroupBox>

                            <GroupBox Header="Plot Type &amp; Colors" Margin="0,0,0,10">
                                <StackPanel Margin="5">
                                    <StackPanel Orientation="Horizontal" Margin="0,0,0,8">
                                        <RadioButton x:Name="rbDotPlot" Content="Dot Plot" GroupName="PlotType"
                                                     IsChecked="True" Checked="PlotType_Changed" Margin="0,0,15,0"/>
                                        <RadioButton x:Name="rbContourPlot" Content="Contour Plot" GroupName="PlotType"
                                                     Checked="PlotType_Changed"/>
                                    </StackPanel>

                                    <TextBlock Text="Dot Colormap:" Margin="0,0,0,3"/>
                                    <ComboBox x:Name="cboDotColormap" Margin="0,0,0,8" SelectionChanged="Colormap_Changed">
                                        <ComboBoxItem Content="Blue"/>
                                        <ComboBoxItem Content="Turbo" IsSelected="True"/>
                                        <ComboBoxItem Content="Viridis"/>
                                        <ComboBoxItem Content="Plasma"/>
                                        <ComboBoxItem Content="Inferno"/>
                                        <ComboBoxItem Content="Grayscale"/>
                                    </ComboBox>

                                    <TextBlock Text="Contour Colormap:" Margin="0,0,0,3"/>
                                    <ComboBox x:Name="cboContourColormap" Margin="0,0,0,5" SelectionChanged="Colormap_Changed">
                                        <ComboBoxItem Content="YlOrRd" IsSelected="True"/>
                                        <ComboBoxItem Content="RdYlBu"/>
                                        <ComboBoxItem Content="Spectral"/>
                                        <ComboBoxItem Content="Hot"/>
                                        <ComboBoxItem Content="Cool"/>
                                        <ComboBoxItem Content="Grayscale"/>
                                    </ComboBox>
                                </StackPanel>
                            </GroupBox>

                            <GroupBox Header="Gating" Margin="0,0,0,10">
                                <StackPanel Margin="5">
                                    <TextBlock Text="Mode:" Margin="0,0,0,3"/>
                                    <StackPanel Orientation="Horizontal" Margin="0,0,0,8">
                                        <RadioButton x:Name="rbModeView" Content="View" GroupName="GatingMode"
                                                     IsChecked="True" Checked="GatingMode_Changed" Margin="0,0,10,0"/>
                                        <RadioButton x:Name="rbModePolygon" Content="Polygon" GroupName="GatingMode"
                                                     Checked="GatingMode_Changed" Margin="0,0,10,0"/>
                                        <RadioButton x:Name="rbModeQuadrant" Content="Quadrant" GroupName="GatingMode"
                                                     Checked="GatingMode_Changed"/>
                                    </StackPanel>

                                    <Border x:Name="pnlPolygonTip" Background="#FFF3CD" BorderBrush="#FFEEBA" 
                                            BorderThickness="1" Padding="8" Margin="0,0,0,8" Visibility="Collapsed">
                                        <TextBlock Text="💡 Click to add vertices, double-click to complete polygon (min 3 points)" 
                                                   Foreground="#856404" FontSize="11" TextWrapping="Wrap"/>
                                    </Border>

                                    <!-- Parent Gate Selection -->
                                    <TextBlock Text="Parent Gate (filter events):" Margin="0,0,0,3"/>
                                    <ComboBox x:Name="cboParentGate" Margin="0,0,0,8" SelectionChanged="ParentGate_Changed">
                                        <ComboBoxItem Content="All Events" IsSelected="True"/>
                                    </ComboBox>

                                    <Border x:Name="pnlGateInfo" Background="#D4EDDA" BorderBrush="#C3E6CB"
                                            BorderThickness="1" Padding="8" Margin="0,0,0,8" Visibility="Collapsed">
                                        <TextBlock x:Name="txtGateInfo" Foreground="#155724" FontSize="11" TextWrapping="Wrap"/>
                                    </Border>

                                    <TextBlock Text="Gate List:" Margin="0,0,0,5"/>
                                    <ListBox x:Name="lstGates" MaxHeight="100" Margin="0,0,0,8">
                                        <ListBox.ItemTemplate>
                                            <DataTemplate>
                                                <Grid Margin="2">
                                                    <Grid.ColumnDefinitions>
                                                        <ColumnDefinition Width="*"/>
                                                        <ColumnDefinition Width="Auto"/>
                                                    </Grid.ColumnDefinitions>
                                                    <TextBlock Text="{Binding DisplayName}" VerticalAlignment="Center" FontSize="11"/>
                                                    <Button Grid.Column="1" Content="✕" Padding="4,2"
                                                            Background="#F2DEDE" Foreground="#A94442"
                                                            Click="BtnRemoveGate_Click" Tag="{Binding}"/>
                                                </Grid>
                                            </DataTemplate>
                                        </ListBox.ItemTemplate>
                                    </ListBox>

                                    <!-- Gate Inheritance Section -->
                                    <Border Background="#E7F3FF" BorderBrush="#B8DAFF" BorderThickness="1" 
                                            Padding="8" Margin="0,0,0,8">
                                        <StackPanel>
                                            <TextBlock Text="🔄 Gate Inheritance" FontWeight="SemiBold" 
                                                       Foreground="#004085" Margin="0,0,0,5"/>
                                            <TextBlock Text="Apply gate regions to current sample:" 
                                                       Foreground="#004085" FontSize="11" Margin="0,0,0,5"/>
                                            <CheckBox x:Name="chkAutoApplyGates" Content="Auto-apply on file switch"
                                                      Margin="0,0,0,5" Checked="ChkAutoApplyGates_Changed" 
                                                      Unchecked="ChkAutoApplyGates_Changed"/>
                                            <Button x:Name="btnApplyGates" Content="📋 Apply All Gates to Current Sample" 
                                                    Click="BtnApplyGates_Click" Padding="6,4" Background="#CCE5FF"/>
                                        </StackPanel>
                                    </Border>
                                </StackPanel>
                            </GroupBox>
                        </StackPanel>

                        <!-- Histogram Controls -->
                        <StackPanel x:Name="pnlHistogramControls" Visibility="Collapsed">
                            <GroupBox Header="Histogram Settings" Margin="0,0,0,10">
                                <StackPanel Margin="5">
                                    <TextBlock Text="Parameter:" Margin="0,0,0,3"/>
                                    <ComboBox x:Name="cboHistParam" Margin="0,0,0,8" SelectionChanged="HistParam_Changed"/>

                                    <TextBlock Text="Scale:" Margin="0,0,0,3"/>
                                    <ComboBox x:Name="cboHistScale" Margin="0,0,0,8" SelectionChanged="HistScale_Changed">
                                        <ComboBoxItem Content="Linear"/>
                                        <ComboBoxItem Content="Log" IsSelected="True"/>
                                    </ComboBox>

                                    <TextBlock Text="Color:" Margin="0,0,0,3"/>
                                    <ComboBox x:Name="cboHistColor" Margin="0,0,0,8" SelectionChanged="Colormap_Changed">
                                        <ComboBoxItem Content="Blue" IsSelected="True"/>
                                        <ComboBoxItem Content="Red"/>
                                        <ComboBoxItem Content="Green"/>
                                        <ComboBoxItem Content="Orange"/>
                                        <ComboBoxItem Content="Purple"/>
                                        <ComboBoxItem Content="Gray"/>
                                    </ComboBox>
                                </StackPanel>
                            </GroupBox>

                            <!-- Histogram Gating -->
                            <GroupBox Header="Histogram Gating" Margin="0,0,0,10">
                                <StackPanel Margin="5">
                                    <TextBlock Text="Mode:" Margin="0,0,0,3"/>
                                    <StackPanel Orientation="Horizontal" Margin="0,0,0,8">
                                        <RadioButton x:Name="rbHistModeView" Content="View" GroupName="HistGatingMode"
                                                     IsChecked="True" Checked="HistGatingMode_Changed" Margin="0,0,10,0"/>
                                        <RadioButton x:Name="rbHistModeThreshold" Content="Threshold" GroupName="HistGatingMode"
                                                     Checked="HistGatingMode_Changed" Margin="0,0,10,0"/>
                                        <RadioButton x:Name="rbHistModeRange" Content="Range Gate" GroupName="HistGatingMode"
                                                     Checked="HistGatingMode_Changed"/>
                                    </StackPanel>

                                    <Border x:Name="pnlHistGateTip" Background="#FFF3CD" BorderBrush="#FFEEBA" 
                                            BorderThickness="1" Padding="8" Margin="0,0,0,8" Visibility="Collapsed">
                                        <TextBlock x:Name="txtHistGateTip" Text="💡 Click to show above/below percentages" 
                                                   Foreground="#856404" FontSize="11" TextWrapping="Wrap"/>
                                    </Border>

                                    <!-- Parent Gate Selection for Histogram -->
                                    <TextBlock Text="Parent Gate (filter events):" Margin="0,0,0,3"/>
                                    <ComboBox x:Name="cboHistParentGate" Margin="0,0,0,8" SelectionChanged="HistParentGate_Changed">
                                        <ComboBoxItem Content="All Events" IsSelected="True"/>
                                    </ComboBox>

                                    <Border x:Name="pnlHistGateInfo" Background="#D4EDDA" BorderBrush="#C3E6CB"
                                            BorderThickness="1" Padding="8" Margin="0,0,0,8" Visibility="Collapsed">
                                        <TextBlock x:Name="txtHistGateInfo" Foreground="#155724" FontSize="11" TextWrapping="Wrap"/>
                                    </Border>
                                </StackPanel>
                            </GroupBox>
                        </StackPanel>

                        <Button x:Name="btnClearAll" Content="🗑️ Clear All Gates" Click="BtnClearAll_Click" 
                                Padding="8,6" Background="#F2DEDE" Margin="0,5,0,0"/>
                    </StackPanel>
                </ScrollViewer>
            </Border>

            <!-- Splitter -->
            <GridSplitter Grid.Column="1" Width="5" HorizontalAlignment="Center" 
                          VerticalAlignment="Stretch" Background="#E0E0E0"/>

            <!-- Right: Multi-Analysis Panels -->
            <TabControl x:Name="tabAnalysis" Grid.Column="2">
                <TabItem x:Name="tabItem1" Header="Panel 1">
                    <Grid Background="White">
                        <Grid.RowDefinitions>
                            <RowDefinition Height="*"/>
                            <RowDefinition Height="Auto"/>
                        </Grid.RowDefinitions>

                        <Canvas x:Name="plotCanvas" Background="White" ClipToBounds="True"
                                MouseLeftButtonDown="PlotCanvas_MouseLeftButtonDown"
                                MouseLeftButtonUp="PlotCanvas_MouseLeftButtonUp"
                                MouseMove="PlotCanvas_MouseMove"/>

                        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="5">
                            <Button x:Name="btnPrevSample" Content="◀ Prev (Ctrl+P)" Click="BtnPrevSample_Click" 
                                    Padding="10,5" Background="#E8E8E8" Margin="0,0,8,0" ToolTip="Previous sample"/>
                            <Button x:Name="btnNextSample" Content="Next ▶ (Ctrl+N)" Click="BtnNextSample_Click" 
                                    Padding="10,5" Background="#E8E8E8" Margin="0,0,8,0" ToolTip="Next sample"/>
                            <Separator Margin="8,0"/>
                            <Button x:Name="btnExportDot" Content="📷 Export Dot Plot" Click="BtnExportDot_Click" 
                                    Padding="10,5" Background="#DFF0D8" Margin="0,0,8,0"/>
                            <Button x:Name="btnExportContour" Content="📷 Export Contour Plot" Click="BtnExportContour_Click" 
                                    Padding="10,5" Background="#DFF0D8" Margin="0,0,8,0"/>
                            <Button x:Name="btnExportHistogram" Content="📷 Export Histogram" Click="BtnExportHistogram_Click" 
                                    Padding="10,5" Background="#DFF0D8" Visibility="Collapsed"/>
                            <Button x:Name="btnCopyPlot" Content="📋 Copy (Ctrl+C)" Click="BtnCopyPlot_Click" 
                                    Padding="10,5" Background="#D9EDF7" Margin="0,0,8,0" ToolTip="Copy plot to clipboard"/>
                            <Separator Margin="8,0"/>
                            <Button x:Name="btnRecordStats" Content="📊 Record (Ctrl+M)" Click="BtnRecordStats_Click" 
                                    Padding="10,5" Background="#FCF8E3" ToolTip="Record current gating statistics to table"/>
                        </StackPanel>
                    </Grid>
                </TabItem>
            </TabControl>
        </Grid>

        <!-- Statistics Record Panel (auto-expands on record) -->
        <Border x:Name="pnlStats" Grid.Row="2" Margin="5,5,5,0" Background="White" 
                BorderBrush="#CCCCCC" BorderThickness="1" Visibility="Collapsed">
            <Grid Height="180">
                <Grid.RowDefinitions>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <DataGrid x:Name="dgStats" Grid.Row="0" AutoGenerateColumns="False" 
                          CanUserAddRows="False" IsReadOnly="True"
                          GridLinesVisibility="All" AlternatingRowBackground="#F9F9F9"
                          HeadersVisibility="Column" FontSize="11">
                    <DataGrid.Columns>
                        <DataGridTextColumn Header="Sample" Binding="{Binding SampleName}" Width="120"/>
                        <DataGridTextColumn Header="View" Binding="{Binding ViewType}" Width="70"/>
                        <DataGridTextColumn Header="Parameter(s)" Binding="{Binding Parameters}" Width="140"/>
                        <DataGridTextColumn Header="Gate/Region" Binding="{Binding GateRegion}" Width="100"/>
                        <DataGridTextColumn Header="Count" Binding="{Binding Count}" Width="70"/>
                        <DataGridTextColumn Header="%" Binding="{Binding Percentage}" Width="60"/>
                        <DataGridTextColumn Header="Parent" Binding="{Binding ParentGate}" Width="80"/>
                        <DataGridTextColumn Header="Details" Binding="{Binding Details}" Width="*"/>
                    </DataGrid.Columns>
                </DataGrid>

                <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="5">
                    <Button x:Name="btnClearStats" Content="🗑️ Clear All" Click="BtnClearStats_Click" 
                            Padding="8,4" Background="#F2DEDE" Margin="0,0,8,0"/>
                    <Button x:Name="btnExportStats" Content="📋 Export to CSV" Click="BtnExportStats_Click" 
                            Padding="8,4" Background="#DFF0D8" Margin="0,0,8,0"/>
                    <Button x:Name="btnCopyStats" Content="📄 Copy to Clipboard" Click="BtnCopyStats_Click" 
                            Padding="8,4" Background="#D9EDF7" Margin="0,0,8,0"/>
                    <Button x:Name="btnHideStats" Content="✕ Hide" Click="BtnHideStats_Click" 
                            Padding="8,4" Background="#E8E8E8"/>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Status Bar -->
        <StatusBar Grid.Row="3">
            <StatusBarItem>
                <TextBlock x:Name="txtStatus" Text="Ready. Load an FCS file or demo data to begin."/>
            </StatusBarItem>
        </StatusBar>
    </Grid>
</Page>


==================================================
FILE_NAME: FlowCytometryAnalyzer.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\FlowCytometryAnalyzer.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using System.Windows.Threading;
using Microsoft.Win32;

namespace BioSAK
{
    public partial class FlowCytometryAnalyzer : Page
    {
        // Data structures
        private List<FcsFile> fcsFiles = new List<FcsFile>();
        private FcsFile? selectedFile;
        private FcsFile? overlayFile;

        // Gate templates (polygon/range definitions - independent of files)
        private ObservableCollection<GateTemplate> gateTemplates = new ObservableCollection<GateTemplate>();

        // Per-file gate results (event indices for each gate in each file)
        private Dictionary<string, Dictionary<string, HashSet<int>>> fileGateResults = new Dictionary<string, Dictionary<string, HashSet<int>>>();

        // Statistics records
        private ObservableCollection<StatsRecord> statsRecords = new ObservableCollection<StatsRecord>();

        private List<Point> currentPolygonPoints = new List<Point>();
        private Point? quadrantPosition = null;

        // Histogram range gate in progress
        private double? histRangeStart = null;
        private double? histRangeEnd = null;

        // Histogram threshold for showing above/below percentages
        private double? histThreshold = null;

        // Cached histogram range for coordinate conversion
        private double histXMin = 0.1;
        private double histXMax = 262144;

        // View state
        private string currentView = "scatter";
        private string gatingMode = "view";
        private string histGatingMode = "view";
        private string plotType = "dot";
        private bool xLogScale = true;
        private bool yLogScale = true;
        private bool histLogScale = true;
        private bool autoApplyGates = false;

        // Colormap selections
        private string dotColormap = "Turbo";
        private string contourColormap = "YlOrRd";
        private string histColor = "Blue";

        // Axis range
        private double? customXMin = null;
        private double? customXMax = null;
        private double? customYMin = null;
        private double? customYMax = null;

        // Parent gate for filtering
        private int parentGateIndex = -1;
        private int histParentGateIndex = -1;

        // Plot dimensions - updated dynamically
        private double plotWidth = 500;
        private double plotHeight = 500;
        private readonly Thickness plotMargin = new Thickness(60, 30, 30, 50);

        // Double-click detection
        private DispatcherTimer clickTimer;
        private Point pendingClickPoint;
        private bool isWaitingForDoubleClick = false;

        // Multi-analysis support
        private int analysisTabCount = 1;
        private Dictionary<TabItem, Canvas> tabCanvases = new Dictionary<TabItem, Canvas>();

        // Preserve histogram settings across file switches
        private string lastHistParamName = "";

        // Initialization flag
        private bool isInitialized = false;

        public FlowCytometryAnalyzer()
        {
            InitializeComponent();
            lstGates.ItemsSource = gateTemplates;
            dgStats.ItemsSource = statsRecords;

            clickTimer = new DispatcherTimer();
            clickTimer.Interval = TimeSpan.FromMilliseconds(250);
            clickTimer.Tick += ClickTimer_Tick;

            // Register first tab's canvas
            tabCanvases[tabItem1] = plotCanvas;
            tabAnalysis.SelectionChanged += TabAnalysis_SelectionChanged;

            isInitialized = true;
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            UpdatePlotSize();
            plotCanvas.SizeChanged += (s, args) => { UpdatePlotSize(); DrawPlot(); };
            this.Focus();
        }

        private void UpdatePlotSize()
        {
            var canvas = GetCurrentCanvas();
            if (canvas == null) return;
            plotWidth = Math.Max(400, canvas.ActualWidth);
            plotHeight = Math.Max(300, canvas.ActualHeight);
        }

        private Canvas? GetCurrentCanvas()
        {
            if (tabAnalysis.SelectedItem is TabItem selectedTab && tabCanvases.ContainsKey(selectedTab))
            {
                return tabCanvases[selectedTab];
            }
            return plotCanvas;
        }

        private void TabAnalysis_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!isInitialized) return;
            UpdatePlotSize();
            DrawPlot();
        }

        #region Gate Inheritance System

        private Dictionary<string, HashSet<int>> GetCurrentFileGateResults()
        {
            if (selectedFile == null) return new Dictionary<string, HashSet<int>>();

            if (!fileGateResults.ContainsKey(selectedFile.Filename))
            {
                fileGateResults[selectedFile.Filename] = new Dictionary<string, HashSet<int>>();
            }
            return fileGateResults[selectedFile.Filename];
        }

        private void ApplyGateToCurrentFile(GateTemplate gate)
        {
            if (selectedFile == null) return;

            var results = GetCurrentFileGateResults();
            var eventIndices = new HashSet<int>();

            // Get parent gate events if specified
            HashSet<int>? parentEvents = null;
            if (!string.IsNullOrEmpty(gate.ParentGateName) && results.ContainsKey(gate.ParentGateName))
            {
                parentEvents = results[gate.ParentGateName];
            }

            if (gate.GateType == GateType.Polygon)
            {
                // Polygon gate - need both X and Y parameters
                int xIndex = FindParameterIndex(selectedFile, gate.XParamName);
                int yIndex = FindParameterIndex(selectedFile, gate.YParamName);

                if (xIndex < 0 || yIndex < 0) return;

                for (int i = 0; i < selectedFile.Events.Count; i++)
                {
                    if (parentEvents != null && !parentEvents.Contains(i))
                        continue;

                    var ev = selectedFile.Events[i];
                    if (ev[xIndex] > 0 && ev[yIndex] > 0)
                    {
                        var point = new Point(ev[xIndex], ev[yIndex]);
                        if (PointInPolygon(point, gate.Points))
                        {
                            eventIndices.Add(i);
                        }
                    }
                }
            }
            else if (gate.GateType == GateType.Range)
            {
                // Range gate - single parameter
                int paramIndex = FindParameterIndex(selectedFile, gate.XParamName);
                if (paramIndex < 0) return;

                for (int i = 0; i < selectedFile.Events.Count; i++)
                {
                    if (parentEvents != null && !parentEvents.Contains(i))
                        continue;

                    var ev = selectedFile.Events[i];
                    double value = ev[paramIndex];
                    if (value >= gate.RangeMin && value <= gate.RangeMax)
                    {
                        eventIndices.Add(i);
                    }
                }
            }

            results[gate.Name] = eventIndices;
        }

        private void ApplyAllGatesToCurrentFile()
        {
            if (selectedFile == null) return;

            fileGateResults[selectedFile.Filename] = new Dictionary<string, HashSet<int>>();

            foreach (var gate in gateTemplates)
            {
                ApplyGateToCurrentFile(gate);
            }

            UpdateGateDisplayNames();
            // Note: DrawPlot() is NOT called here to prevent recursion
            // Callers should call DrawPlot() after this method if needed
        }

        private void ApplyAllGatesToFile(FcsFile file)
        {
            if (file == null) return;

            fileGateResults[file.Filename] = new Dictionary<string, HashSet<int>>();

            foreach (var gate in gateTemplates)
            {
                ApplyGateToFile(file, gate);
            }
        }

        private void ApplyGateToFile(FcsFile file, GateTemplate gate)
        {
            if (file == null) return;

            if (!fileGateResults.ContainsKey(file.Filename))
            {
                fileGateResults[file.Filename] = new Dictionary<string, HashSet<int>>();
            }

            var results = fileGateResults[file.Filename];
            var eventIndices = new HashSet<int>();

            // Get parent gate events if specified
            HashSet<int>? parentEvents = null;
            if (!string.IsNullOrEmpty(gate.ParentGateName) && results.ContainsKey(gate.ParentGateName))
            {
                parentEvents = results[gate.ParentGateName];
            }

            if (gate.GateType == GateType.Polygon)
            {
                int xIndex = FindParameterIndex(file, gate.XParamName);
                int yIndex = FindParameterIndex(file, gate.YParamName);

                if (xIndex < 0 || yIndex < 0) return;

                for (int i = 0; i < file.Events.Count; i++)
                {
                    if (parentEvents != null && !parentEvents.Contains(i))
                        continue;

                    var ev = file.Events[i];
                    if (ev[xIndex] > 0 && ev[yIndex] > 0)
                    {
                        var point = new Point(ev[xIndex], ev[yIndex]);
                        if (PointInPolygon(point, gate.Points))
                        {
                            eventIndices.Add(i);
                        }
                    }
                }
            }
            else if (gate.GateType == GateType.Range)
            {
                int paramIndex = FindParameterIndex(file, gate.XParamName);
                if (paramIndex < 0) return;

                for (int i = 0; i < file.Events.Count; i++)
                {
                    if (parentEvents != null && !parentEvents.Contains(i))
                        continue;

                    var ev = file.Events[i];
                    double value = ev[paramIndex];
                    if (value >= gate.RangeMin && value <= gate.RangeMax)
                    {
                        eventIndices.Add(i);
                    }
                }
            }

            results[gate.Name] = eventIndices;
        }

        private int FindParameterIndex(FcsFile file, string paramName)
        {
            for (int i = 0; i < file.Parameters.Count; i++)
            {
                if (file.Parameters[i].Name.Equals(paramName, StringComparison.OrdinalIgnoreCase) ||
                    file.Parameters[i].Label.Equals(paramName, StringComparison.OrdinalIgnoreCase))
                {
                    return i;
                }
            }
            return -1;
        }

        private List<int> GetDisplayEventIndices()
        {
            if (selectedFile == null) return new List<int>();
            return GetDisplayEventIndicesForFile(selectedFile);
        }

        private List<int> GetDisplayEventIndicesForFile(FcsFile file)
        {
            if (file == null) return new List<int>();

            int gateIndex = currentView == "histogram" ? histParentGateIndex : parentGateIndex;

            if (gateIndex < 0 || gateIndex >= gateTemplates.Count)
            {
                // No parent gate selected - return all events
                return Enumerable.Range(0, file.Events.Count).ToList();
            }
            else
            {
                var gateName = gateTemplates[gateIndex].Name;

                // Ensure gates are applied to this file
                if (!fileGateResults.ContainsKey(file.Filename))
                {
                    ApplyAllGatesToFile(file);
                }

                var results = fileGateResults.ContainsKey(file.Filename)
                    ? fileGateResults[file.Filename]
                    : new Dictionary<string, HashSet<int>>();

                // If gate not yet applied to this file, apply it now
                if (!results.ContainsKey(gateName))
                {
                    ApplyAllGatesToFile(file);
                    results = fileGateResults.ContainsKey(file.Filename)
                        ? fileGateResults[file.Filename]
                        : new Dictionary<string, HashSet<int>>();
                }

                if (results.ContainsKey(gateName))
                {
                    // Return the gated events (could be empty if no events match)
                    return results[gateName].ToList();
                }

                // Still no results - return empty (gate doesn't match any events)
                return new List<int>();
            }
        }

        private int GetGateEventCount(string gateName)
        {
            var results = GetCurrentFileGateResults();
            return results.ContainsKey(gateName) ? results[gateName].Count : 0;
        }

        private void UpdateGateDisplayNames()
        {
            if (selectedFile == null) return;

            var results = GetCurrentFileGateResults();
            int totalEvents = selectedFile.Events.Count;

            foreach (var gate in gateTemplates)
            {
                int count = results.ContainsKey(gate.Name) ? results[gate.Name].Count : 0;
                double percent = totalEvents > 0 ? (count * 100.0 / totalEvents) : 0;

                if (gate.GateType == GateType.Range)
                {
                    gate.DisplayName = $"{gate.Name}: {count:N0} ({percent:F2}%) [Range: {gate.XParamName}]";
                }
                else
                {
                    gate.DisplayName = $"{gate.Name}: {count:N0} ({percent:F2}%) [{gate.XParamName}/{gate.YParamName}]";
                }
            }

            lstGates.Items.Refresh();
        }

        private void CreatePolygonGateAndApply(string gateName, List<Point> polygonPoints, string parentGateName = "")
        {
            if (selectedFile == null || cboXParam.SelectedIndex < 0 || cboYParam.SelectedIndex < 0) return;

            int xIndex = cboXParam.SelectedIndex;
            int yIndex = cboYParam.SelectedIndex;

            var gate = new GateTemplate
            {
                Name = gateName,
                GateType = GateType.Polygon,
                Points = new List<Point>(polygonPoints),
                XParamIndex = xIndex,
                YParamIndex = yIndex,
                XParamName = selectedFile.Parameters[xIndex].Label,
                YParamName = selectedFile.Parameters[yIndex].Label,
                ParentGateName = parentGateName
            };

            gateTemplates.Add(gate);
            ApplyGateToCurrentFile(gate);
            UpdateGateDisplayNames();
            UpdateParentGateComboBoxes();

            int count = GetGateEventCount(gateName);
            double percent = selectedFile.Events.Count > 0 ? (count * 100.0 / selectedFile.Events.Count) : 0;
            txtStatus.Text = $"Gate '{gateName}' created: {count:N0} events ({percent:F2}%)";
        }

        private void CreateRangeGateAndApply(string gateName, double minValue, double maxValue, string parentGateName = "")
        {
            if (selectedFile == null || cboHistParam.SelectedIndex < 0) return;

            int paramIndex = cboHistParam.SelectedIndex;

            var gate = new GateTemplate
            {
                Name = gateName,
                GateType = GateType.Range,
                XParamIndex = paramIndex,
                XParamName = selectedFile.Parameters[paramIndex].Label,
                YParamName = "",
                RangeMin = minValue,
                RangeMax = maxValue,
                ParentGateName = parentGateName
            };

            gateTemplates.Add(gate);
            ApplyGateToCurrentFile(gate);
            UpdateGateDisplayNames();
            UpdateParentGateComboBoxes();

            int count = GetGateEventCount(gateName);
            double percent = selectedFile.Events.Count > 0 ? (count * 100.0 / selectedFile.Events.Count) : 0;
            txtStatus.Text = $"Range gate '{gateName}' created: {count:N0} events ({percent:F2}%)";
        }

        private void UpdateParentGateComboBoxes()
        {
            // Update scatter plot parent gate combo
            int previousSelection = cboParentGate.SelectedIndex;
            cboParentGate.Items.Clear();
            cboParentGate.Items.Add(new ComboBoxItem { Content = "All Events" });

            foreach (var gate in gateTemplates)
            {
                cboParentGate.Items.Add(new ComboBoxItem { Content = gate.Name });
            }

            if (previousSelection >= 0 && previousSelection < cboParentGate.Items.Count)
                cboParentGate.SelectedIndex = previousSelection;
            else
                cboParentGate.SelectedIndex = 0;

            // Update histogram parent gate combo
            int histPrevSelection = cboHistParentGate.SelectedIndex;
            cboHistParentGate.Items.Clear();
            cboHistParentGate.Items.Add(new ComboBoxItem { Content = "All Events" });

            foreach (var gate in gateTemplates)
            {
                cboHistParentGate.Items.Add(new ComboBoxItem { Content = gate.Name });
            }

            if (histPrevSelection >= 0 && histPrevSelection < cboHistParentGate.Items.Count)
                cboHistParentGate.SelectedIndex = histPrevSelection;
            else
                cboHistParentGate.SelectedIndex = 0;
        }

        private void BtnApplyGates_Click(object sender, RoutedEventArgs e)
        {
            if (selectedFile == null)
            {
                MessageBox.Show("Please load a file first.", "Info", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            if (gateTemplates.Count == 0)
            {
                MessageBox.Show("No gates defined. Create gates first.", "Info", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            ApplyAllGatesToCurrentFile();
            DrawPlot();
            txtStatus.Text = $"Applied {gateTemplates.Count} gate(s) to {selectedFile.Filename}";
        }

        private void ChkAutoApplyGates_Changed(object sender, RoutedEventArgs e)
        {
            autoApplyGates = chkAutoApplyGates.IsChecked == true;
        }

        #endregion

        #region Multi-Analysis Tab Support

        private void BtnAddAnalysis_Click(object sender, RoutedEventArgs e)
        {
            analysisTabCount++;
            var newTab = new TabItem { Header = $"Panel {analysisTabCount}" };

            var grid = new Grid { Background = Brushes.White };
            grid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(1, GridUnitType.Star) });
            grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });

            var canvas = new Canvas { Background = Brushes.White, ClipToBounds = true };
            canvas.MouseLeftButtonDown += PlotCanvas_MouseLeftButtonDown;
            canvas.MouseLeftButtonUp += PlotCanvas_MouseLeftButtonUp;
            canvas.MouseMove += PlotCanvas_MouseMove;
            canvas.SizeChanged += (s, args) => {
                if (tabAnalysis.SelectedItem == newTab)
                {
                    UpdatePlotSize();
                    DrawPlot();
                }
            };
            Grid.SetRow(canvas, 0);
            grid.Children.Add(canvas);

            var buttonPanel = new StackPanel { Orientation = Orientation.Horizontal, Margin = new Thickness(5) };
            Grid.SetRow(buttonPanel, 1);

            var btnExport = new Button { Content = "📷 Export Plot", Padding = new Thickness(10, 5, 10, 5), Background = new SolidColorBrush(Color.FromRgb(223, 240, 216)) };
            btnExport.Click += (s, args) => ExportCurrentTab();
            buttonPanel.Children.Add(btnExport);

            var btnCopy = new Button { Content = "📋 Copy to Clipboard (Ctrl+C)", Padding = new Thickness(10, 5, 10, 5), Background = new SolidColorBrush(Color.FromRgb(217, 237, 247)), Margin = new Thickness(8, 0, 0, 0) };
            btnCopy.Click += (s, args) => CopyPlotToClipboard();
            buttonPanel.Children.Add(btnCopy);

            grid.Children.Add(buttonPanel);
            newTab.Content = grid;

            // Register this tab's canvas
            tabCanvases[newTab] = canvas;

            tabAnalysis.Items.Add(newTab);
            tabAnalysis.SelectedItem = newTab;

            txtStatus.Text = $"Added Panel {analysisTabCount}";
        }

        private void BtnRemoveAnalysis_Click(object sender, RoutedEventArgs e)
        {
            if (tabAnalysis.Items.Count > 1)
            {
                var currentTab = tabAnalysis.SelectedItem as TabItem;
                if (currentTab != null)
                {
                    // Remove from dictionary
                    tabCanvases.Remove(currentTab);

                    tabAnalysis.Items.Remove(currentTab);
                    if (tabAnalysis.SelectedIndex < 0)
                        tabAnalysis.SelectedIndex = tabAnalysis.Items.Count - 1;
                    txtStatus.Text = "Panel removed";
                }
            }
            else
            {
                MessageBox.Show("At least one panel must remain.", "Info", MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        private void ExportCurrentTab()
        {
            if (currentView == "scatter")
                ExportPlot(plotType);
            else
                ExportHistogram();
        }

        #endregion

        #region File Operations

        private void BtnLoadFile_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new OpenFileDialog
            {
                Filter = "FCS Files (*.fcs)|*.fcs|All Files (*.*)|*.*",
                Multiselect = true
            };

            if (dialog.ShowDialog() == true)
            {
                foreach (var filename in dialog.FileNames)
                {
                    try
                    {
                        var fcs = ParseFcsFile(filename);
                        fcsFiles.Add(fcs);
                        cboFiles.Items.Add(fcs.Filename);
                        cboOverlay.Items.Add(fcs.Filename);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Failed to load {filename}: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                }

                if (selectedFile == null && fcsFiles.Count > 0)
                {
                    cboFiles.SelectedIndex = 0;
                }

                txtStatus.Text = $"Loaded {fcsFiles.Count} file(s)";
            }
        }

        private void BtnLoadDemo_Click(object sender, RoutedEventArgs e)
        {
            fcsFiles.Clear();
            cboFiles.Items.Clear();
            cboOverlay.Items.Clear();

            var demo1 = GenerateDemoData("Demo_Sample.fcs");
            var demo2 = GenerateDemoData2("Demo_Treatment.fcs");

            fcsFiles.Add(demo1);
            fcsFiles.Add(demo2);

            cboFiles.Items.Add(demo1.Filename);
            cboFiles.Items.Add(demo2.Filename);
            cboOverlay.Items.Add(demo1.Filename);
            cboOverlay.Items.Add(demo2.Filename);

            cboFiles.SelectedIndex = 0;
            cboOverlay.SelectedIndex = 1;

            txtStatus.Text = "Demo data loaded (2 samples for testing gate inheritance)";
        }

        private FcsFile ParseFcsFile(string filepath)
        {
            using (var fs = new FileStream(filepath, FileMode.Open, FileAccess.Read))
            using (var reader = new BinaryReader(fs))
            {
                var header = Encoding.ASCII.GetString(reader.ReadBytes(58));
                var textStart = int.Parse(header.Substring(10, 8).Trim());
                var textEnd = int.Parse(header.Substring(18, 8).Trim());
                var dataStart = int.Parse(header.Substring(26, 8).Trim());
                var dataEnd = int.Parse(header.Substring(34, 8).Trim());

                fs.Seek(textStart, SeekOrigin.Begin);
                var textSegment = Encoding.UTF8.GetString(reader.ReadBytes(textEnd - textStart + 1));
                var delimiter = textSegment[0];
                var parts = textSegment.Substring(1).Split(delimiter);

                var metadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                for (int i = 0; i < parts.Length - 1; i += 2)
                {
                    if (!string.IsNullOrEmpty(parts[i]))
                        metadata[parts[i]] = parts[i + 1];
                }

                int numParams = int.Parse(metadata.GetValueOrDefault("$PAR") ?? "0");
                int numEvents = int.Parse(metadata.GetValueOrDefault("$TOT") ?? "0");
                var byteOrder = metadata.GetValueOrDefault("$BYTEORD") ?? "1,2,3,4";
                bool isLittleEndian = byteOrder.StartsWith("1");

                var parameters = new List<FcsParameter>();
                for (int i = 1; i <= numParams; i++)
                {
                    var name = metadata.GetValueOrDefault($"$P{i}N") ?? $"P{i}";
                    var label = metadata.GetValueOrDefault($"$P{i}S") ?? name;
                    parameters.Add(new FcsParameter { Name = name, Label = label });
                }

                fs.Seek(dataStart, SeekOrigin.Begin);
                var events = new List<float[]>();
                int bytesPerEvent = numParams * 4;
                int dataLength = dataEnd - dataStart + 1;
                int actualEvents = Math.Min(numEvents, dataLength / bytesPerEvent);

                for (int ev = 0; ev < actualEvents; ev++)
                {
                    var eventData = new float[numParams];
                    for (int p = 0; p < numParams; p++)
                    {
                        var bytes = reader.ReadBytes(4);
                        if (!isLittleEndian) Array.Reverse(bytes);
                        var value = BitConverter.ToSingle(bytes, 0);
                        eventData[p] = float.IsNaN(value) || float.IsInfinity(value) ? 0 : value;
                    }
                    events.Add(eventData);
                }

                return new FcsFile
                {
                    Filename = System.IO.Path.GetFileName(filepath),
                    Parameters = parameters,
                    Events = events
                };
            }
        }

        private FcsFile GenerateDemoData(string filename)
        {
            var parameters = new List<FcsParameter>
            {
                new FcsParameter { Name = "FSC-A", Label = "FSC-A" },
                new FcsParameter { Name = "SSC-A", Label = "SSC-A" },
                new FcsParameter { Name = "FITC-A", Label = "CD4 FITC" },
                new FcsParameter { Name = "PE-A", Label = "CD8 PE" },
                new FcsParameter { Name = "APC-A", Label = "CD3 APC" },
                new FcsParameter { Name = "Pacific Blue-A", Label = "CD45 Pacific Blue" }
            };

            var events = new List<float[]>();
            var rand = new Random(42);

            for (int i = 0; i < 6000; i++)
            {
                events.Add(new float[]
                {
                    (float)(50000 + rand.NextDouble() * 30000 + (rand.NextDouble() - 0.5) * 20000),
                    (float)(30000 + rand.NextDouble() * 25000 + (rand.NextDouble() - 0.5) * 15000),
                    (float)(rand.NextDouble() < 0.4 ? 5000 + rand.NextDouble() * 50000 : 100 + rand.NextDouble() * 2000),
                    (float)(rand.NextDouble() < 0.3 ? 8000 + rand.NextDouble() * 60000 : 100 + rand.NextDouble() * 2000),
                    (float)(20000 + rand.NextDouble() * 100000),
                    (float)(50000 + rand.NextDouble() * 80000)
                });
            }

            for (int i = 0; i < 2000; i++)
            {
                events.Add(new float[]
                {
                    (float)(80000 + rand.NextDouble() * 40000),
                    (float)(60000 + rand.NextDouble() * 40000),
                    (float)(200 + rand.NextDouble() * 3000),
                    (float)(150 + rand.NextDouble() * 2000),
                    (float)(1000 + rand.NextDouble() * 5000),
                    (float)(80000 + rand.NextDouble() * 60000)
                });
            }

            for (int i = 0; i < 2000; i++)
            {
                events.Add(new float[]
                {
                    (float)(100000 + rand.NextDouble() * 60000),
                    (float)(120000 + rand.NextDouble() * 80000),
                    (float)(100 + rand.NextDouble() * 1000),
                    (float)(100 + rand.NextDouble() * 1000),
                    (float)(500 + rand.NextDouble() * 3000),
                    (float)(30000 + rand.NextDouble() * 40000)
                });
            }

            return new FcsFile { Filename = filename, Parameters = parameters, Events = events };
        }

        private FcsFile GenerateDemoData2(string filename)
        {
            var parameters = new List<FcsParameter>
            {
                new FcsParameter { Name = "FSC-A", Label = "FSC-A" },
                new FcsParameter { Name = "SSC-A", Label = "SSC-A" },
                new FcsParameter { Name = "FITC-A", Label = "CD4 FITC" },
                new FcsParameter { Name = "PE-A", Label = "CD8 PE" },
                new FcsParameter { Name = "APC-A", Label = "CD3 APC" },
                new FcsParameter { Name = "Pacific Blue-A", Label = "CD45 Pacific Blue" }
            };

            var events = new List<float[]>();
            var rand = new Random(123);

            for (int i = 0; i < 5600; i++)
            {
                events.Add(new float[]
                {
                    (float)(55000 + rand.NextDouble() * 25000),
                    (float)(35000 + rand.NextDouble() * 20000),
                    (float)(rand.NextDouble() < 0.6 ? 15000 + rand.NextDouble() * 80000 : 100 + rand.NextDouble() * 1500),
                    (float)(rand.NextDouble() < 0.2 ? 5000 + rand.NextDouble() * 40000 : 100 + rand.NextDouble() * 1500),
                    (float)(30000 + rand.NextDouble() * 120000),
                    (float)(60000 + rand.NextDouble() * 70000)
                });
            }

            for (int i = 0; i < 2400; i++)
            {
                events.Add(new float[]
                {
                    (float)(90000 + rand.NextDouble() * 50000),
                    (float)(80000 + rand.NextDouble() * 60000),
                    (float)(150 + rand.NextDouble() * 2000),
                    (float)(100 + rand.NextDouble() * 1500),
                    (float)(800 + rand.NextDouble() * 4000),
                    (float)(40000 + rand.NextDouble() * 50000)
                });
            }

            return new FcsFile { Filename = filename, Parameters = parameters, Events = events };
        }

        #endregion

        #region Event Handlers

        private void CboFiles_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (cboFiles.SelectedIndex >= 0 && cboFiles.SelectedIndex < fcsFiles.Count)
            {
                // Save current histogram parameter name before switching
                if (selectedFile != null && cboHistParam.SelectedIndex >= 0)
                {
                    lastHistParamName = selectedFile.Parameters[cboHistParam.SelectedIndex].Label;
                }

                // Note: histThreshold is preserved across file switches (not cleared here)

                selectedFile = fcsFiles[cboFiles.SelectedIndex];

                // Apply gates FIRST before updating comboboxes
                // This ensures gate results exist before any DrawPlot is triggered
                if (gateTemplates.Count > 0)
                {
                    ApplyAllGatesToCurrentFile();
                }

                UpdateParameterComboBoxes();

                // Restore histogram parameter selection by name
                RestoreHistogramParameter();

                txtFileInfo.Text = $"Events: {selectedFile.Events.Count:N0} | Parameters: {selectedFile.Parameters.Count}";

                if (gateTemplates.Count > 0)
                {
                    if (autoApplyGates)
                        txtStatus.Text = $"Switched to {selectedFile.Filename} - Gates auto-applied";
                    else
                        txtStatus.Text = $"Switched to {selectedFile.Filename} - Gates applied";
                }
                else
                {
                    txtStatus.Text = $"Switched to {selectedFile.Filename}";
                }

                DrawPlot();
            }
        }

        private void RestoreHistogramParameter()
        {
            if (string.IsNullOrEmpty(lastHistParamName) || selectedFile == null) return;

            // Find parameter by name
            for (int i = 0; i < selectedFile.Parameters.Count; i++)
            {
                if (selectedFile.Parameters[i].Label.Equals(lastHistParamName, StringComparison.OrdinalIgnoreCase) ||
                    selectedFile.Parameters[i].Name.Equals(lastHistParamName, StringComparison.OrdinalIgnoreCase))
                {
                    cboHistParam.SelectedIndex = i;
                    return;
                }
            }
        }

        private void CboOverlay_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (cboOverlay.SelectedIndex >= 0 && cboOverlay.SelectedIndex < fcsFiles.Count)
            {
                overlayFile = fcsFiles[cboOverlay.SelectedIndex];
                DrawPlot();
            }
        }

        private void ChkOverlay_Changed(object sender, RoutedEventArgs e)
        {
            if (!isInitialized) return;
            cboOverlay.Visibility = chkOverlay.IsChecked == true ? Visibility.Visible : Visibility.Collapsed;
            DrawPlot();
        }

        private void UpdateParameterComboBoxes()
        {
            if (selectedFile == null) return;

            cboXParam.Items.Clear();
            cboYParam.Items.Clear();
            cboHistParam.Items.Clear();

            foreach (var param in selectedFile.Parameters)
            {
                var label = string.IsNullOrEmpty(param.Label) ? param.Name : param.Label;
                cboXParam.Items.Add(label);
                cboYParam.Items.Add(label);
                cboHistParam.Items.Add(label);
            }

            if (selectedFile.Parameters.Count > 0)
            {
                cboXParam.SelectedIndex = 0;
                cboYParam.SelectedIndex = Math.Min(1, selectedFile.Parameters.Count - 1);
                cboHistParam.SelectedIndex = 0;
            }
        }

        private void Param_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (!isInitialized) return;
            DrawPlot();
        }

        private void Scale_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (!isInitialized || cboXScale == null || cboYScale == null) return;
            xLogScale = cboXScale.SelectedIndex == 1;
            yLogScale = cboYScale.SelectedIndex == 1;
            DrawPlot();
        }

        private void HistParam_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (!isInitialized) return;
            histRangeStart = null;
            histRangeEnd = null;
            // Note: histThreshold is preserved when changing parameters
            DrawPlot();
        }

        private void HistScale_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (!isInitialized || cboHistScale == null) return;
            histLogScale = cboHistScale.SelectedIndex == 1;
            histRangeStart = null;
            histRangeEnd = null;
            // Note: histThreshold is preserved when changing scale
            DrawPlot();
        }

        private void Colormap_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (!isInitialized) return;

            if (cboDotColormap?.SelectedItem is ComboBoxItem dotItem)
                dotColormap = dotItem.Content?.ToString() ?? "Turbo";
            if (cboContourColormap?.SelectedItem is ComboBoxItem contourItem)
                contourColormap = contourItem.Content?.ToString() ?? "YlOrRd";
            if (cboHistColor?.SelectedItem is ComboBoxItem histItem)
                histColor = histItem.Content?.ToString() ?? "Blue";

            DrawPlot();
        }

        private void ViewType_Changed(object sender, RoutedEventArgs e)
        {
            if (!isInitialized || pnlScatterControls == null || pnlHistogramControls == null) return;

            currentView = rbScatter.IsChecked == true ? "scatter" : "histogram";
            pnlScatterControls.Visibility = currentView == "scatter" ? Visibility.Visible : Visibility.Collapsed;
            pnlHistogramControls.Visibility = currentView == "histogram" ? Visibility.Visible : Visibility.Collapsed;
            btnExportDot.Visibility = currentView == "scatter" ? Visibility.Visible : Visibility.Collapsed;
            btnExportContour.Visibility = currentView == "scatter" ? Visibility.Visible : Visibility.Collapsed;
            btnExportHistogram.Visibility = currentView == "histogram" ? Visibility.Visible : Visibility.Collapsed;
            DrawPlot();
        }

        private void PlotType_Changed(object sender, RoutedEventArgs e)
        {
            if (!isInitialized || rbDotPlot == null || rbContourPlot == null) return;
            plotType = rbDotPlot.IsChecked == true ? "dot" : "contour";
            DrawPlot();
        }

        private void GatingMode_Changed(object sender, RoutedEventArgs e)
        {
            if (!isInitialized || rbModeView == null || rbModePolygon == null || rbModeQuadrant == null) return;

            if (rbModeView.IsChecked == true)
            {
                gatingMode = "view";
                pnlPolygonTip.Visibility = Visibility.Collapsed;
            }
            else if (rbModePolygon.IsChecked == true)
            {
                gatingMode = "polygon";
                pnlPolygonTip.Visibility = Visibility.Visible;
            }
            else if (rbModeQuadrant.IsChecked == true)
            {
                gatingMode = "quadrant";
                pnlPolygonTip.Visibility = Visibility.Collapsed;
            }

            var canvas = GetCurrentCanvas();
            if (canvas != null) canvas.Cursor = gatingMode == "view" ? Cursors.Arrow : Cursors.Cross;
        }

        private void HistGatingMode_Changed(object sender, RoutedEventArgs e)
        {
            if (!isInitialized) return;

            var canvas = GetCurrentCanvas();

            if (rbHistModeView.IsChecked == true)
            {
                histGatingMode = "view";
                pnlHistGateTip.Visibility = Visibility.Collapsed;
                if (canvas != null) canvas.Cursor = Cursors.Arrow;
                // Note: histThreshold is preserved but not displayed in View mode
                DrawPlot();
            }
            else if (rbHistModeThreshold.IsChecked == true)
            {
                histGatingMode = "threshold";
                pnlHistGateTip.Visibility = Visibility.Visible;
                txtHistGateTip.Text = "💡 Click to show above/below cell percentages";
                if (canvas != null) canvas.Cursor = Cursors.Cross;
                // histThreshold is preserved and displayed
                DrawPlot();
            }
            else if (rbHistModeRange.IsChecked == true)
            {
                histGatingMode = "range";
                pnlHistGateTip.Visibility = Visibility.Visible;
                txtHistGateTip.Text = "💡 Click to set left boundary, click again to set right boundary and create gate";
                if (canvas != null) canvas.Cursor = Cursors.Cross;
                histRangeStart = null;
                histRangeEnd = null;
                // Note: histThreshold is preserved but not displayed in Range mode
                DrawPlot();
            }
        }

        private void ParentGate_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (!isInitialized) return;
            parentGateIndex = cboParentGate.SelectedIndex - 1;

            if (parentGateIndex >= 0 && parentGateIndex < gateTemplates.Count)
            {
                var gate = gateTemplates[parentGateIndex];
                int count = GetGateEventCount(gate.Name);
                pnlGateInfo.Visibility = Visibility.Visible;

                if (gate.GateType == GateType.Range)
                {
                    txtGateInfo.Text = $"Showing {count:N0} events from {gate.Name}\n(Range gate on {gate.XParamName})";
                }
                else
                {
                    txtGateInfo.Text = $"Showing {count:N0} events from {gate.Name}\n(Created on {gate.XParamName} vs {gate.YParamName})";
                }
            }
            else
            {
                pnlGateInfo.Visibility = Visibility.Collapsed;
            }

            DrawPlot();
        }

        private void HistParentGate_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (!isInitialized) return;
            histParentGateIndex = cboHistParentGate.SelectedIndex - 1;

            if (histParentGateIndex >= 0 && histParentGateIndex < gateTemplates.Count)
            {
                var gate = gateTemplates[histParentGateIndex];
                int count = GetGateEventCount(gate.Name);
                pnlHistGateInfo.Visibility = Visibility.Visible;

                if (gate.GateType == GateType.Range)
                {
                    txtHistGateInfo.Text = $"Showing {count:N0} events from {gate.Name}\n(Range gate on {gate.XParamName})";
                }
                else
                {
                    txtHistGateInfo.Text = $"Showing {count:N0} events from {gate.Name}\n(Created on {gate.XParamName} vs {gate.YParamName})";
                }
            }
            else
            {
                pnlHistGateInfo.Visibility = Visibility.Collapsed;
            }

            DrawPlot();
        }

        private void AxisRange_Changed(object sender, TextChangedEventArgs e)
        {
            if (!isInitialized) return;
            if (sender is TextBox tb)
            {
                double? value = null;
                if (double.TryParse(tb.Text, out double parsed))
                    value = parsed;

                switch (tb.Tag?.ToString())
                {
                    case "xmin": customXMin = value; break;
                    case "xmax": customXMax = value; break;
                    case "ymin": customYMin = value; break;
                    case "ymax": customYMax = value; break;
                }
                DrawPlot();
            }
        }

        private void BtnResetRange_Click(object sender, RoutedEventArgs e)
        {
            txtXMin.Text = "";
            txtXMax.Text = "";
            txtYMin.Text = "";
            txtYMax.Text = "";
            customXMin = customXMax = customYMin = customYMax = null;
            DrawPlot();
        }

        private void BtnRemoveGate_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button btn && btn.Tag is GateTemplate gate)
            {
                foreach (var fileResults in fileGateResults.Values)
                {
                    fileResults.Remove(gate.Name);
                }

                gateTemplates.Remove(gate);
                UpdateParentGateComboBoxes();

                if (parentGateIndex >= gateTemplates.Count)
                {
                    parentGateIndex = -1;
                    cboParentGate.SelectedIndex = 0;
                }
                if (histParentGateIndex >= gateTemplates.Count)
                {
                    histParentGateIndex = -1;
                    cboHistParentGate.SelectedIndex = 0;
                }

                DrawPlot();
                txtStatus.Text = $"Gate '{gate.Name}' removed";
            }
        }

        private void BtnClearAll_Click(object sender, RoutedEventArgs e)
        {
            gateTemplates.Clear();
            fileGateResults.Clear();
            currentPolygonPoints.Clear();
            quadrantPosition = null;
            histRangeStart = null;
            histRangeEnd = null;
            histThreshold = null;
            parentGateIndex = -1;
            histParentGateIndex = -1;
            UpdateParentGateComboBoxes();
            DrawPlot();
            txtStatus.Text = "All gates cleared";
        }

        #endregion

        #region Mouse Handling

        private void ClickTimer_Tick(object? sender, EventArgs e)
        {
            clickTimer.Stop();
            isWaitingForDoubleClick = false;

            if (gatingMode == "polygon")
            {
                currentPolygonPoints.Add(pendingClickPoint);
                DrawPlot();
            }
        }

        private void PlotCanvas_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (selectedFile == null) return;

            var canvas = sender as Canvas ?? GetCurrentCanvas();
            if (canvas == null) return;

            var pos = e.GetPosition(canvas);

            // Update plot size from actual canvas
            double actualWidth = canvas.ActualWidth;
            double actualHeight = canvas.ActualHeight;
            if (actualWidth > 0) plotWidth = actualWidth;
            if (actualHeight > 0) plotHeight = actualHeight;

            if (currentView == "histogram")
            {
                HandleHistogramClick(pos);
                return;
            }

            // Scatter plot handling
            if (pos.X < plotMargin.Left || pos.X > plotWidth - plotMargin.Right ||
                pos.Y < plotMargin.Top || pos.Y > plotHeight - plotMargin.Bottom)
                return;

            var dataPoint = ScreenToData(pos);

            if (gatingMode == "quadrant")
            {
                quadrantPosition = dataPoint;
                DrawPlot();
            }
            else if (gatingMode == "polygon")
            {
                if (isWaitingForDoubleClick)
                {
                    clickTimer.Stop();
                    isWaitingForDoubleClick = false;

                    if (currentPolygonPoints.Count >= 3)
                    {
                        string gateName = $"P{gateTemplates.Count + 1}";
                        string parentName = parentGateIndex >= 0 && parentGateIndex < gateTemplates.Count
                            ? gateTemplates[parentGateIndex].Name : "";
                        CreatePolygonGateAndApply(gateName, currentPolygonPoints, parentName);
                        currentPolygonPoints.Clear();
                        DrawPlot();
                    }
                    else
                    {
                        txtStatus.Text = "Need at least 3 points to create a polygon gate";
                    }
                }
                else
                {
                    isWaitingForDoubleClick = true;
                    pendingClickPoint = dataPoint;
                    clickTimer.Start();
                }
            }
        }

        private void HandleHistogramClick(Point pos)
        {
            if (pos.X < plotMargin.Left || pos.X > plotWidth - plotMargin.Right)
                return;

            double dataValue = HistScreenToDataX(pos.X);

            if (histGatingMode == "range")
            {
                if (!histRangeStart.HasValue)
                {
                    // First click - set start
                    histRangeStart = dataValue;
                    txtStatus.Text = $"Range start set at {dataValue:F1}. Click again to set end.";
                    DrawPlot();
                }
                else
                {
                    // Second click - set end and create gate
                    histRangeEnd = dataValue;

                    double minVal = Math.Min(histRangeStart.Value, histRangeEnd.Value);
                    double maxVal = Math.Max(histRangeStart.Value, histRangeEnd.Value);

                    string gateName = $"R{gateTemplates.Count + 1}";
                    string parentName = histParentGateIndex >= 0 && histParentGateIndex < gateTemplates.Count
                        ? gateTemplates[histParentGateIndex].Name : "";

                    CreateRangeGateAndApply(gateName, minVal, maxVal, parentName);

                    histRangeStart = null;
                    histRangeEnd = null;
                    DrawPlot();
                }
            }
            else if (histGatingMode == "threshold")
            {
                // Threshold mode - show above/below percentages
                histThreshold = dataValue;
                DrawPlot();
            }
        }

        private void PlotCanvas_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            // Not used
        }

        private void PlotCanvas_MouseMove(object sender, MouseEventArgs e) { }

        private Point ScreenToData(Point screen)
        {
            return new Point(ScreenToDataX(screen.X), ScreenToDataY(screen.Y));
        }

        private double ScreenToDataX(double screenX)
        {
            if (selectedFile == null) return 0;
            int xIndex = cboXParam.SelectedIndex;
            if (xIndex < 0) return 0;

            var displayIndices = GetDisplayEventIndices();
            var xValues = displayIndices.Select(i => selectedFile.Events[i][xIndex]).Where(v => v > 0).ToList();
            double dataMax = xValues.Count > 0 ? xValues.Max() : 262144;

            double xMin = customXMin ?? (xLogScale ? 0.1 : 0);
            double xMax = customXMax ?? dataMax * 2;

            double plotLeft = plotMargin.Left;
            double plotRight = plotWidth - plotMargin.Right;
            double t = (screenX - plotLeft) / (plotRight - plotLeft);

            if (xLogScale)
            {
                double logMin = Math.Log10(Math.Max(0.1, xMin));
                double logMax = Math.Log10(xMax);
                return Math.Pow(10, logMin + t * (logMax - logMin));
            }
            return xMin + t * (xMax - xMin);
        }

        private double ScreenToDataY(double screenY)
        {
            if (selectedFile == null) return 0;
            int yIndex = cboYParam.SelectedIndex;
            if (yIndex < 0) return 0;

            var displayIndices = GetDisplayEventIndices();
            var yValues = displayIndices.Select(i => selectedFile.Events[i][yIndex]).Where(v => v > 0).ToList();
            double dataMax = yValues.Count > 0 ? yValues.Max() : 262144;

            double yMin = customYMin ?? (yLogScale ? 0.1 : 0);
            double yMax = customYMax ?? dataMax * 2;

            double plotTop = plotMargin.Top;
            double plotBottom = plotHeight - plotMargin.Bottom;
            double t = 1 - (screenY - plotTop) / (plotBottom - plotTop);

            if (yLogScale)
            {
                double logMin = Math.Log10(Math.Max(0.1, yMin));
                double logMax = Math.Log10(yMax);
                return Math.Pow(10, logMin + t * (logMax - logMin));
            }
            return yMin + t * (yMax - yMin);
        }

        private double HistScreenToDataX(double screenX)
        {
            double plotLeft = plotMargin.Left;
            double plotRight = plotWidth - plotMargin.Right;
            double t = (screenX - plotLeft) / (plotRight - plotLeft);
            t = Math.Max(0, Math.Min(1, t));

            if (histLogScale)
            {
                double logMin = Math.Log10(Math.Max(0.1, histXMin));
                double logMax = Math.Log10(histXMax);
                return Math.Pow(10, logMin + t * (logMax - logMin));
            }
            return histXMin + t * (histXMax - histXMin);
        }

        #endregion

        #region Drawing

        private void DrawPlot()
        {
            var canvas = GetCurrentCanvas();
            if (selectedFile == null || canvas == null) return;

            if (canvas.ActualWidth > 0) plotWidth = canvas.ActualWidth;
            if (canvas.ActualHeight > 0) plotHeight = canvas.ActualHeight;

            canvas.Children.Clear();

            if (currentView == "scatter")
                DrawScatterPlot(canvas, false, plotType);
            else
                DrawHistogram(canvas, false);
        }

        private void DrawScatterPlot(Canvas canvas, bool isExport, string exportPlotType)
        {
            if (selectedFile == null || cboXParam.SelectedIndex < 0 || cboYParam.SelectedIndex < 0) return;

            int xIndex = cboXParam.SelectedIndex;
            int yIndex = cboYParam.SelectedIndex;

            var displayIndices = GetDisplayEventIndices();

            // Show message if no events to display
            if (displayIndices.Count == 0)
            {
                canvas.Children.Add(new Rectangle { Width = plotWidth, Height = plotHeight, Fill = Brushes.White });
                var noDataMsg = new TextBlock
                {
                    Text = "No events to display\n(Gate may not contain events in this sample)",
                    Foreground = Brushes.Gray,
                    FontSize = 14,
                    TextAlignment = TextAlignment.Center
                };
                noDataMsg.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(noDataMsg, (plotWidth - noDataMsg.DesiredSize.Width) / 2);
                Canvas.SetTop(noDataMsg, plotHeight / 2 - 20);
                canvas.Children.Add(noDataMsg);
                txtStatus.Text = "No events match the selected gate";
                return;
            }

            // Downsample for display if too many events (saves memory and improves performance)
            const int MaxDisplayEvents = 50000;
            if (displayIndices.Count > MaxDisplayEvents && !isExport)
            {
                var rand = new Random(42); // Fixed seed for consistent display
                displayIndices = displayIndices.OrderBy(x => rand.Next()).Take(MaxDisplayEvents).ToList();
            }

            var xValues = displayIndices.Select(i => selectedFile.Events[i][xIndex]).Where(v => v > 0).ToList();
            var yValues = displayIndices.Select(i => selectedFile.Events[i][yIndex]).Where(v => v > 0).ToList();

            double xMin = customXMin ?? (xLogScale ? 0.1 : 0);
            double xMax = customXMax ?? (xValues.Count > 0 ? xValues.Max() * 2 : 262144);
            double yMin = customYMin ?? (yLogScale ? 0.1 : 0);
            double yMax = customYMax ?? (yValues.Count > 0 ? yValues.Max() * 2 : 262144);

            var plotData = displayIndices.Select(i => selectedFile.Events[i]).ToList();

            canvas.Children.Add(new Rectangle { Width = plotWidth, Height = plotHeight, Fill = Brushes.White });

            string usePlotType = isExport ? exportPlotType : plotType;
            if (usePlotType == "contour")
                DrawContourPlot(canvas, plotData, xIndex, yIndex, xMin, xMax, yMin, yMax);
            else
                DrawDotPlot(canvas, plotData, xIndex, yIndex, xMin, xMax, yMin, yMax);

            foreach (var gate in gateTemplates)
            {
                if (gate.GateType != GateType.Polygon) continue;

                int gateXIndex = FindParameterIndex(selectedFile, gate.XParamName);
                int gateYIndex = FindParameterIndex(selectedFile, gate.YParamName);
                if (gateXIndex == xIndex && gateYIndex == yIndex)
                {
                    DrawPolygonGate(canvas, gate, xMin, xMax, yMin, yMax);
                }
            }

            if (currentPolygonPoints.Count > 0 && !isExport)
                DrawCurrentPolygon(canvas, xMin, xMax, yMin, yMax);

            if (quadrantPosition.HasValue)
                DrawQuadrant(canvas, plotData, xIndex, yIndex, xMin, xMax, yMin, yMax);

            DrawAxes(canvas, xMin, xMax, yMin, yMax);

            int validCount = plotData.Count(ev => ev[xIndex] > 0 && ev[yIndex] > 0);
            int totalEvents = GetDisplayEventIndices().Count;
            if (validCount < totalEvents)
                txtStatus.Text = $"Displaying {validCount:N0} of {totalEvents:N0} events (downsampled)";
            else
                txtStatus.Text = $"Displaying {validCount:N0} events";
        }

        private void DrawDotPlot(Canvas canvas, List<float[]> data, int xIndex, int yIndex, double xMin, double xMax, double yMin, double yMax)
        {
            var densityGrid = new Dictionary<string, int>();
            int gridSize = 3;

            // Display jitter to prevent quantization artifacts (e.g. Width parameter with discrete values)
            var jitterRng = new Random(42);
            double jitterAmount = gridSize * 1.2;

            foreach (var ev in data)
            {
                if (ev[xIndex] <= 0 || ev[yIndex] <= 0) continue;
                double px = DataToScreenX(ev[xIndex], xMin, xMax) + (jitterRng.NextDouble() - 0.5) * jitterAmount;
                double py = DataToScreenY(ev[yIndex], yMin, yMax) + (jitterRng.NextDouble() - 0.5) * jitterAmount;
                int gx = (int)(px / gridSize) * gridSize;
                int gy = (int)(py / gridSize) * gridSize;
                string key = $"{gx},{gy}";
                if (!densityGrid.ContainsKey(key)) densityGrid[key] = 0;
                densityGrid[key]++;
            }

            int maxDensity = densityGrid.Values.Count > 0 ? densityGrid.Values.Max() : 1;

            foreach (var kvp in densityGrid)
            {
                var parts = kvp.Key.Split(',');
                int px = int.Parse(parts[0]);
                int py = int.Parse(parts[1]);
                double t = Math.Log(kvp.Value + 1) / Math.Log(maxDensity + 1);
                var rect = new Rectangle
                {
                    Width = gridSize,
                    Height = gridSize,
                    Fill = new SolidColorBrush(GetDotColor(t)),
                    Opacity = 0.9
                };
                Canvas.SetLeft(rect, px);
                Canvas.SetTop(rect, py);
                canvas.Children.Add(rect);
            }
        }

        private void DrawContourPlot(Canvas canvas, List<float[]> data, int xIndex, int yIndex, double xMin, double xMax, double yMin, double yMax)
        {
            int gridResolution = 50;
            var densityGrid = new double[gridResolution, gridResolution];

            double plotLeft = plotMargin.Left;
            double plotRight = plotWidth - plotMargin.Right;
            double plotTop = plotMargin.Top;
            double plotBottom = plotHeight - plotMargin.Bottom;

            // Display jitter to prevent quantization artifacts
            var jitterRng = new Random(42);
            double cellW = (plotRight - plotLeft) / gridResolution;
            double jitterAmount = cellW * 0.3;

            foreach (var ev in data)
            {
                if (ev[xIndex] <= 0 || ev[yIndex] <= 0) continue;
                double px = DataToScreenX(ev[xIndex], xMin, xMax) + (jitterRng.NextDouble() - 0.5) * jitterAmount;
                double py = DataToScreenY(ev[yIndex], yMin, yMax) + (jitterRng.NextDouble() - 0.5) * jitterAmount;

                int gx = (int)((px - plotLeft) / (plotRight - plotLeft) * (gridResolution - 1));
                int gy = (int)((py - plotTop) / (plotBottom - plotTop) * (gridResolution - 1));
                gx = Math.Max(0, Math.Min(gridResolution - 1, gx));
                gy = Math.Max(0, Math.Min(gridResolution - 1, gy));

                for (int dx = -2; dx <= 2; dx++)
                    for (int dy = -2; dy <= 2; dy++)
                    {
                        int nx = gx + dx, ny = gy + dy;
                        if (nx >= 0 && nx < gridResolution && ny >= 0 && ny < gridResolution)
                        {
                            double dist = Math.Sqrt(dx * dx + dy * dy);
                            densityGrid[nx, ny] += Math.Exp(-dist * dist / 2);
                        }
                    }
            }

            double maxDensity = 0;
            for (int i = 0; i < gridResolution; i++)
                for (int j = 0; j < gridResolution; j++)
                    maxDensity = Math.Max(maxDensity, densityGrid[i, j]);

            if (maxDensity == 0) return;

            double cellWidth = (plotRight - plotLeft) / gridResolution;
            double cellHeight = (plotBottom - plotTop) / gridResolution;

            for (int i = 0; i < gridResolution; i++)
                for (int j = 0; j < gridResolution; j++)
                {
                    double density = densityGrid[i, j];
                    if (density > maxDensity * 0.02)
                    {
                        var rect = new Rectangle
                        {
                            Width = cellWidth + 1,
                            Height = cellHeight + 1,
                            Fill = new SolidColorBrush(GetContourColor(density / maxDensity)),
                            Opacity = 0.8
                        };
                        Canvas.SetLeft(rect, plotLeft + i * cellWidth);
                        Canvas.SetTop(rect, plotTop + j * cellHeight);
                        canvas.Children.Add(rect);
                    }
                }
        }

        private void DrawPolygonGate(Canvas canvas, GateTemplate gate, double xMin, double xMax, double yMin, double yMax)
        {
            var screenPoints = new PointCollection();
            foreach (var pt in gate.Points)
            {
                double sx = DataToScreenX(pt.X, xMin, xMax);
                double sy = DataToScreenY(pt.Y, yMin, yMax);
                screenPoints.Add(new Point(sx, sy));
            }

            canvas.Children.Add(new Polygon
            {
                Points = screenPoints,
                Fill = new SolidColorBrush(Color.FromArgb(40, 0, 128, 0)),
                Stroke = new SolidColorBrush(Color.FromRgb(0, 128, 0)),
                StrokeThickness = 2
            });

            if (screenPoints.Count > 0)
            {
                int count = GetGateEventCount(gate.Name);
                var label = new TextBlock
                {
                    Text = $"{gate.Name}: {count:N0}",
                    Foreground = new SolidColorBrush(Color.FromRgb(0, 100, 0)),
                    FontSize = 11,
                    FontWeight = FontWeights.Bold,
                    Background = new SolidColorBrush(Color.FromArgb(200, 255, 255, 255))
                };
                Canvas.SetLeft(label, screenPoints[0].X + 5);
                Canvas.SetTop(label, screenPoints[0].Y - 18);
                canvas.Children.Add(label);
            }
        }

        private void DrawCurrentPolygon(Canvas canvas, double xMin, double xMax, double yMin, double yMax)
        {
            for (int i = 0; i < currentPolygonPoints.Count - 1; i++)
            {
                var p1 = currentPolygonPoints[i];
                var p2 = currentPolygonPoints[i + 1];
                canvas.Children.Add(new Line
                {
                    X1 = DataToScreenX(p1.X, xMin, xMax),
                    Y1 = DataToScreenY(p1.Y, yMin, yMax),
                    X2 = DataToScreenX(p2.X, xMin, xMax),
                    Y2 = DataToScreenY(p2.Y, yMin, yMax),
                    Stroke = new SolidColorBrush(Color.FromRgb(255, 140, 0)),
                    StrokeThickness = 2,
                    StrokeDashArray = new DoubleCollection { 5, 5 }
                });
            }

            for (int i = 0; i < currentPolygonPoints.Count; i++)
            {
                var pt = currentPolygonPoints[i];
                var ellipse = new Ellipse
                {
                    Width = 10,
                    Height = 10,
                    Fill = new SolidColorBrush(i == 0 ? Colors.Red : Color.FromRgb(255, 140, 0)),
                    Stroke = Brushes.Black,
                    StrokeThickness = 1
                };
                Canvas.SetLeft(ellipse, DataToScreenX(pt.X, xMin, xMax) - 5);
                Canvas.SetTop(ellipse, DataToScreenY(pt.Y, yMin, yMax) - 5);
                canvas.Children.Add(ellipse);
            }
        }

        private void DrawQuadrant(Canvas canvas, List<float[]> data, int xIndex, int yIndex, double xMin, double xMax, double yMin, double yMax)
        {
            if (!quadrantPosition.HasValue) return;

            double qx = DataToScreenX(quadrantPosition.Value.X, xMin, xMax);
            double qy = DataToScreenY(quadrantPosition.Value.Y, yMin, yMax);

            canvas.Children.Add(new Line { X1 = qx, Y1 = plotMargin.Top, X2 = qx, Y2 = plotHeight - plotMargin.Bottom, Stroke = Brushes.Black, StrokeThickness = 1.5 });
            canvas.Children.Add(new Line { X1 = plotMargin.Left, Y1 = qy, X2 = plotWidth - plotMargin.Right, Y2 = qy, Stroke = Brushes.Black, StrokeThickness = 1.5 });

            var validData = data.Where(ev => ev[xIndex] > 0 && ev[yIndex] > 0).ToList();
            int total = validData.Count;
            if (total > 0)
            {
                int q1 = validData.Count(ev => ev[xIndex] >= quadrantPosition.Value.X && ev[yIndex] >= quadrantPosition.Value.Y);
                int q2 = validData.Count(ev => ev[xIndex] < quadrantPosition.Value.X && ev[yIndex] >= quadrantPosition.Value.Y);
                int q3 = validData.Count(ev => ev[xIndex] < quadrantPosition.Value.X && ev[yIndex] < quadrantPosition.Value.Y);
                int q4 = validData.Count(ev => ev[xIndex] >= quadrantPosition.Value.X && ev[yIndex] < quadrantPosition.Value.Y);

                AddQuadrantLabel(canvas, $"Q1: {(q1 * 100.0 / total):F1}%", plotWidth - plotMargin.Right - 10, plotMargin.Top + 10, Colors.Red, HorizontalAlignment.Right);
                AddQuadrantLabel(canvas, $"Q2: {(q2 * 100.0 / total):F1}%", plotMargin.Left + 10, plotMargin.Top + 10, Colors.Blue, HorizontalAlignment.Left);
                AddQuadrantLabel(canvas, $"Q3: {(q3 * 100.0 / total):F1}%", plotMargin.Left + 10, plotHeight - plotMargin.Bottom - 25, Colors.Gray, HorizontalAlignment.Left);
                AddQuadrantLabel(canvas, $"Q4: {(q4 * 100.0 / total):F1}%", plotWidth - plotMargin.Right - 10, plotHeight - plotMargin.Bottom - 25, Color.FromRgb(255, 140, 0), HorizontalAlignment.Right);
            }
        }

        private void AddQuadrantLabel(Canvas canvas, string text, double x, double y, Color color, HorizontalAlignment align)
        {
            var label = new TextBlock
            {
                Text = text,
                Foreground = new SolidColorBrush(color),
                FontSize = 13,
                FontWeight = FontWeights.Bold,
                Background = new SolidColorBrush(Color.FromArgb(200, 255, 255, 255))
            };
            if (align == HorizontalAlignment.Right)
            {
                label.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                x -= label.DesiredSize.Width;
            }
            Canvas.SetLeft(label, x);
            Canvas.SetTop(label, y);
            canvas.Children.Add(label);
        }

        private void DrawAxes(Canvas canvas, double xMin, double xMax, double yMin, double yMax)
        {
            if (selectedFile == null) return;

            double plotLeft = plotMargin.Left;
            double plotRight = plotWidth - plotMargin.Right;
            double plotTop = plotMargin.Top;
            double plotBottom = plotHeight - plotMargin.Bottom;

            canvas.Children.Add(new Line { X1 = plotLeft, Y1 = plotBottom, X2 = plotRight, Y2 = plotBottom, Stroke = Brushes.Black, StrokeThickness = 1 });
            canvas.Children.Add(new Line { X1 = plotLeft, Y1 = plotTop, X2 = plotLeft, Y2 = plotBottom, Stroke = Brushes.Black, StrokeThickness = 1 });

            foreach (var tick in GetAxisTicks(xMin, xMax, xLogScale))
            {
                double x = DataToScreenX(tick, xMin, xMax);
                if (x >= plotLeft && x <= plotRight)
                {
                    canvas.Children.Add(new Line { X1 = x, Y1 = plotBottom, X2 = x, Y2 = plotBottom + 5, Stroke = Brushes.Black, StrokeThickness = 1 });
                    var label = new TextBlock { Text = FormatAxisValue(tick), Foreground = Brushes.Black, FontSize = 10 };
                    label.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                    Canvas.SetLeft(label, x - label.DesiredSize.Width / 2);
                    Canvas.SetTop(label, plotBottom + 7);
                    canvas.Children.Add(label);
                }
            }

            foreach (var tick in GetAxisTicks(yMin, yMax, yLogScale))
            {
                double y = DataToScreenY(tick, yMin, yMax);
                if (y >= plotTop && y <= plotBottom)
                {
                    canvas.Children.Add(new Line { X1 = plotLeft - 5, Y1 = y, X2 = plotLeft, Y2 = y, Stroke = Brushes.Black, StrokeThickness = 1 });
                    var label = new TextBlock { Text = FormatAxisValue(tick), Foreground = Brushes.Black, FontSize = 10 };
                    label.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                    Canvas.SetLeft(label, plotLeft - label.DesiredSize.Width - 8);
                    Canvas.SetTop(label, y - label.DesiredSize.Height / 2);
                    canvas.Children.Add(label);
                }
            }

            if (cboXParam.SelectedIndex >= 0)
            {
                var xLabel = new TextBlock { Text = selectedFile.Parameters[cboXParam.SelectedIndex].Label, Foreground = Brushes.Black, FontSize = 12, FontWeight = FontWeights.SemiBold };
                xLabel.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(xLabel, (plotLeft + plotRight) / 2 - xLabel.DesiredSize.Width / 2);
                Canvas.SetTop(xLabel, plotHeight - 18);
                canvas.Children.Add(xLabel);
            }

            if (cboYParam.SelectedIndex >= 0)
            {
                var yLabel = new TextBlock { Text = selectedFile.Parameters[cboYParam.SelectedIndex].Label, Foreground = Brushes.Black, FontSize = 12, FontWeight = FontWeights.SemiBold, RenderTransform = new RotateTransform(-90) };
                yLabel.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(yLabel, 5);
                Canvas.SetTop(yLabel, (plotTop + plotBottom) / 2 + yLabel.DesiredSize.Width / 2);
                canvas.Children.Add(yLabel);
            }
        }

        private void DrawHistogram(Canvas canvas, bool isExport)
        {
            if (selectedFile == null || cboHistParam.SelectedIndex < 0) return;

            int paramIndex = cboHistParam.SelectedIndex;
            var displayIndices = GetDisplayEventIndices();
            var values = displayIndices.Select(i => selectedFile.Events[i][paramIndex]).Where(v => v > 0).ToList();

            // Show message if no events to display
            if (values.Count == 0)
            {
                canvas.Children.Add(new Rectangle { Width = plotWidth, Height = plotHeight, Fill = Brushes.White });
                var noDataMsg = new TextBlock
                {
                    Text = "No events to display\n(Gate may not contain events in this sample)",
                    Foreground = Brushes.Gray,
                    FontSize = 14,
                    TextAlignment = TextAlignment.Center
                };
                noDataMsg.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(noDataMsg, (plotWidth - noDataMsg.DesiredSize.Width) / 2);
                Canvas.SetTop(noDataMsg, plotHeight / 2 - 20);
                canvas.Children.Add(noDataMsg);
                txtStatus.Text = "No events match the selected gate";
                return;
            }

            double dataMax = values.Max();

            histXMin = histLogScale ? 0.1 : 0;
            histXMax = dataMax * 2;

            canvas.Children.Add(new Rectangle { Width = plotWidth, Height = plotHeight, Fill = Brushes.White });

            int numBins = 256;
            var bins = new int[numBins];
            double[] binEdges = new double[numBins + 1];

            if (histLogScale)
            {
                double logMin = Math.Log10(Math.Max(0.1, histXMin));
                double logMax = Math.Log10(histXMax);
                for (int i = 0; i <= numBins; i++)
                    binEdges[i] = Math.Pow(10, logMin + (logMax - logMin) * i / numBins);
            }
            else
            {
                for (int i = 0; i <= numBins; i++)
                    binEdges[i] = histXMin + (histXMax - histXMin) * i / numBins;
            }

            foreach (var val in values)
                for (int i = 0; i < numBins; i++)
                    if (val >= binEdges[i] && val < binEdges[i + 1]) { bins[i]++; break; }

            int maxBin = bins.Max();
            var mainColor = GetHistogramColor();

            DrawHistogramCurve(canvas, bins, binEdges, maxBin, histXMin, histXMax, Color.FromArgb(150, mainColor.R, mainColor.G, mainColor.B), mainColor);

            int overlayEventCount = 0;
            if (chkOverlay.IsChecked == true && overlayFile != null)
            {
                // Find the same parameter in overlay file by name
                string paramName = selectedFile.Parameters[paramIndex].Label;
                int overlayParamIndex = FindParameterIndex(overlayFile, paramName);

                if (overlayParamIndex >= 0)
                {
                    // Get gated events for overlay file (apply same parent gate)
                    var overlayDisplayIndices = GetDisplayEventIndicesForFile(overlayFile);
                    var overlayValues = overlayDisplayIndices
                        .Select(i => overlayFile.Events[i][overlayParamIndex])
                        .Where(v => v > 0)
                        .ToList();

                    overlayEventCount = overlayValues.Count;

                    var overlayBins = new int[numBins];
                    foreach (var val in overlayValues)
                        for (int i = 0; i < numBins; i++)
                            if (val >= binEdges[i] && val < binEdges[i + 1]) { overlayBins[i]++; break; }

                    if (overlayBins.Length > 0 && overlayBins.Max() > 0)
                    {
                        maxBin = Math.Max(maxBin, overlayBins.Max());
                        canvas.Children.Clear();
                        canvas.Children.Add(new Rectangle { Width = plotWidth, Height = plotHeight, Fill = Brushes.White });
                        DrawHistogramCurve(canvas, bins, binEdges, maxBin, histXMin, histXMax, Color.FromArgb(150, mainColor.R, mainColor.G, mainColor.B), mainColor);
                        var overlayColor = Color.FromRgb(220, 20, 60);
                        DrawHistogramCurve(canvas, overlayBins, binEdges, maxBin, histXMin, histXMax, Color.FromArgb(150, overlayColor.R, overlayColor.G, overlayColor.B), overlayColor);
                    }
                }
            }

            // Draw range gates on histogram
            DrawHistogramRangeGates(canvas, values, paramIndex, histXMin, histXMax);

            // Draw range gate in progress
            if (histRangeStart.HasValue && !isExport)
            {
                DrawHistogramRangeMarker(canvas, histRangeStart.Value, histXMin, histXMax, Colors.Orange, "Start");
            }

            // Draw threshold line with above/below percentages (only in threshold mode)
            if (histThreshold.HasValue && !isExport && histGatingMode == "threshold")
            {
                DrawHistogramThreshold(canvas, values, histThreshold.Value, histXMin, histXMax);
            }

            DrawHistogramAxes(canvas, histXMin, histXMax, maxBin, paramIndex);

            if (overlayEventCount > 0)
                txtStatus.Text = $"Displaying {values.Count:N0} events (overlay: {overlayEventCount:N0})";
            else
                txtStatus.Text = $"Displaying {values.Count:N0} events";
        }

        private void DrawHistogramRangeGates(Canvas canvas, List<float> values, int paramIndex, double xMin, double xMax)
        {
            string currentParamName = selectedFile!.Parameters[paramIndex].Label;

            // Prepare overlay values if active
            List<float>? overlayValues = null;
            if (chkOverlay.IsChecked == true && overlayFile != null)
            {
                int overlayParamIndex = FindParameterIndex(overlayFile, currentParamName);
                if (overlayParamIndex >= 0)
                {
                    var overlayDisplayIndices = GetDisplayEventIndicesForFile(overlayFile);
                    overlayValues = overlayDisplayIndices
                        .Select(i => overlayFile.Events[i][overlayParamIndex])
                        .Where(v => v > 0)
                        .ToList();
                }
            }

            foreach (var gate in gateTemplates)
            {
                if (gate.GateType != GateType.Range) continue;
                if (!gate.XParamName.Equals(currentParamName, StringComparison.OrdinalIgnoreCase)) continue;

                double leftX = HistDataToScreenX(gate.RangeMin, xMin, xMax);
                double rightX = HistDataToScreenX(gate.RangeMax, xMin, xMax);
                double plotTop = plotMargin.Top;
                double plotBottom = plotHeight - plotMargin.Bottom;

                // Draw shaded region
                var rect = new Rectangle
                {
                    Width = rightX - leftX,
                    Height = plotBottom - plotTop,
                    Fill = new SolidColorBrush(Color.FromArgb(50, 0, 128, 0)),
                    Stroke = new SolidColorBrush(Color.FromRgb(0, 128, 0)),
                    StrokeThickness = 2
                };
                Canvas.SetLeft(rect, leftX);
                Canvas.SetTop(rect, plotTop);
                canvas.Children.Add(rect);

                // Main file gate label
                int count = GetGateEventCount(gate.Name);
                double percent = values.Count > 0 ? (count * 100.0 / values.Count) : 0;
                string labelText = $"{gate.Name}: {count:N0} ({percent:F1}%)";

                // Overlay gate count
                if (overlayValues != null && overlayValues.Count > 0)
                {
                    int ovCount = overlayValues.Count(v => v >= gate.RangeMin && v < gate.RangeMax);
                    double ovPercent = ovCount * 100.0 / overlayValues.Count;
                    labelText += $"\n[OV] {ovCount:N0} ({ovPercent:F1}%)";
                }

                var label = new TextBlock
                {
                    Text = labelText,
                    Foreground = new SolidColorBrush(Color.FromRgb(0, 100, 0)),
                    FontSize = 11,
                    FontWeight = FontWeights.Bold,
                    Background = new SolidColorBrush(Color.FromArgb(200, 255, 255, 255))
                };
                Canvas.SetLeft(label, leftX + 5);
                Canvas.SetTop(label, plotTop + 5);
                canvas.Children.Add(label);
            }
        }

        private void DrawHistogramRangeMarker(Canvas canvas, double dataValue, double xMin, double xMax, Color color, string text)
        {
            double screenX = HistDataToScreenX(dataValue, xMin, xMax);
            double plotTop = plotMargin.Top;
            double plotBottom = plotHeight - plotMargin.Bottom;

            canvas.Children.Add(new Line
            {
                X1 = screenX,
                Y1 = plotTop,
                X2 = screenX,
                Y2 = plotBottom,
                Stroke = new SolidColorBrush(color),
                StrokeThickness = 2,
                StrokeDashArray = new DoubleCollection { 4, 2 }
            });

            var label = new TextBlock
            {
                Text = text,
                Foreground = new SolidColorBrush(color),
                FontSize = 10,
                FontWeight = FontWeights.Bold,
                Background = new SolidColorBrush(Color.FromArgb(200, 255, 255, 255))
            };
            Canvas.SetLeft(label, screenX + 3);
            Canvas.SetTop(label, plotTop + 5);
            canvas.Children.Add(label);
        }

        private void DrawHistogramThreshold(Canvas canvas, List<float> values, double threshold, double xMin, double xMax)
        {
            double screenX = HistDataToScreenX(threshold, xMin, xMax);
            double plotTop = plotMargin.Top;
            double plotBottom = plotHeight - plotMargin.Bottom;
            double plotLeft = plotMargin.Left;
            double plotRight = plotWidth - plotMargin.Right;

            // Calculate counts above and below threshold
            int total = values.Count;
            int aboveCount = values.Count(v => v >= threshold);
            int belowCount = total - aboveCount;
            double abovePercent = total > 0 ? (aboveCount * 100.0 / total) : 0;
            double belowPercent = total > 0 ? (belowCount * 100.0 / total) : 0;

            // Calculate overlay stats if active
            int ovTotal = 0, ovAbove = 0, ovBelow = 0;
            double ovAbovePercent = 0, ovBelowPercent = 0;
            bool hasOverlay = chkOverlay.IsChecked == true && overlayFile != null && selectedFile != null;
            if (hasOverlay)
            {
                int paramIndex = cboHistParam.SelectedIndex;
                if (paramIndex >= 0)
                {
                    string paramName = selectedFile!.Parameters[paramIndex].Label;
                    int overlayParamIndex = FindParameterIndex(overlayFile!, paramName);
                    if (overlayParamIndex >= 0)
                    {
                        var overlayDisplayIndices = GetDisplayEventIndicesForFile(overlayFile!);
                        var overlayValues = overlayDisplayIndices
                            .Select(i => overlayFile!.Events[i][overlayParamIndex])
                            .Where(v => v > 0)
                            .ToList();

                        ovTotal = overlayValues.Count;
                        ovAbove = overlayValues.Count(v => v >= threshold);
                        ovBelow = ovTotal - ovAbove;
                        ovAbovePercent = ovTotal > 0 ? (ovAbove * 100.0 / ovTotal) : 0;
                        ovBelowPercent = ovTotal > 0 ? (ovBelow * 100.0 / ovTotal) : 0;
                    }
                }
            }

            // Draw shaded regions
            // Below threshold (left side) - light blue
            var belowRect = new Rectangle
            {
                Width = Math.Max(0, screenX - plotLeft),
                Height = plotBottom - plotTop,
                Fill = new SolidColorBrush(Color.FromArgb(40, 0, 100, 200))
            };
            Canvas.SetLeft(belowRect, plotLeft);
            Canvas.SetTop(belowRect, plotTop);
            canvas.Children.Add(belowRect);

            // Above threshold (right side) - light red
            var aboveRect = new Rectangle
            {
                Width = Math.Max(0, plotRight - screenX),
                Height = plotBottom - plotTop,
                Fill = new SolidColorBrush(Color.FromArgb(40, 200, 50, 50))
            };
            Canvas.SetLeft(aboveRect, screenX);
            Canvas.SetTop(aboveRect, plotTop);
            canvas.Children.Add(aboveRect);

            // Draw threshold line
            canvas.Children.Add(new Line
            {
                X1 = screenX,
                Y1 = plotTop,
                X2 = screenX,
                Y2 = plotBottom,
                Stroke = new SolidColorBrush(Color.FromRgb(128, 0, 128)),
                StrokeThickness = 2.5
            });

            // Draw labels - Below (left side)
            string belowText = $"< {belowCount:N0}\n({belowPercent:F1}%)";
            if (hasOverlay && ovTotal > 0)
                belowText += $"\n[OV] {ovBelow:N0} ({ovBelowPercent:F1}%)";

            var belowLabel = new TextBlock
            {
                Text = belowText,
                Foreground = new SolidColorBrush(Color.FromRgb(0, 80, 160)),
                FontSize = 12,
                FontWeight = FontWeights.Bold,
                Background = new SolidColorBrush(Color.FromArgb(220, 255, 255, 255)),
                TextAlignment = TextAlignment.Center,
                Padding = new Thickness(4, 2, 4, 2)
            };
            Canvas.SetLeft(belowLabel, plotLeft + 10);
            Canvas.SetTop(belowLabel, plotTop + 20);
            canvas.Children.Add(belowLabel);

            // Above label (right side)
            string aboveText = $"≥ {aboveCount:N0}\n({abovePercent:F1}%)";
            if (hasOverlay && ovTotal > 0)
                aboveText += $"\n[OV] {ovAbove:N0} ({ovAbovePercent:F1}%)";

            var aboveLabel = new TextBlock
            {
                Text = aboveText,
                Foreground = new SolidColorBrush(Color.FromRgb(180, 40, 40)),
                FontSize = 12,
                FontWeight = FontWeights.Bold,
                Background = new SolidColorBrush(Color.FromArgb(220, 255, 255, 255)),
                TextAlignment = TextAlignment.Center,
                Padding = new Thickness(4, 2, 4, 2)
            };
            aboveLabel.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            Canvas.SetLeft(aboveLabel, plotRight - aboveLabel.DesiredSize.Width - 10);
            Canvas.SetTop(aboveLabel, plotTop + 20);
            canvas.Children.Add(aboveLabel);

            // Threshold value label
            var thresholdLabel = new TextBlock
            {
                Text = $"Threshold: {FormatAxisValue(threshold)}",
                Foreground = new SolidColorBrush(Color.FromRgb(128, 0, 128)),
                FontSize = 10,
                FontWeight = FontWeights.Bold,
                Background = new SolidColorBrush(Color.FromArgb(220, 255, 255, 255)),
                Padding = new Thickness(3, 1, 3, 1)
            };
            Canvas.SetLeft(thresholdLabel, screenX + 5);
            Canvas.SetTop(thresholdLabel, plotBottom - 20);
            canvas.Children.Add(thresholdLabel);

            // Update status bar
            string statusText = $"Threshold at {FormatAxisValue(threshold)}: Below = {belowCount:N0} ({belowPercent:F1}%), Above = {aboveCount:N0} ({abovePercent:F1}%)";
            if (hasOverlay && ovTotal > 0)
                statusText += $" | Overlay: Below = {ovBelow:N0} ({ovBelowPercent:F1}%), Above = {ovAbove:N0} ({ovAbovePercent:F1}%)";
            txtStatus.Text = statusText;
        }

        private void DrawHistogramCurve(Canvas canvas, int[] bins, double[] binEdges, int maxBin, double xMin, double xMax, Color fillColor, Color strokeColor)
        {
            double plotLeft = plotMargin.Left;
            double plotRight = plotWidth - plotMargin.Right;
            double plotTop = plotMargin.Top;
            double plotBottom = plotHeight - plotMargin.Bottom;

            var points = new List<Point> { new Point(plotLeft, plotBottom) };
            for (int i = 0; i < bins.Length; i++)
            {
                double x = HistDataToScreenX((binEdges[i] + binEdges[i + 1]) / 2, xMin, xMax);
                double y = plotBottom - (bins[i] / (double)maxBin) * (plotBottom - plotTop - 20);
                points.Add(new Point(x, y));
            }
            points.Add(new Point(plotRight, plotBottom));

            var fillGeometry = new PathGeometry();
            var fillFigure = new PathFigure { StartPoint = points[0] };
            fillFigure.Segments.Add(new PolyLineSegment(points.Skip(1), true));
            fillGeometry.Figures.Add(fillFigure);
            canvas.Children.Add(new System.Windows.Shapes.Path { Data = fillGeometry, Fill = new SolidColorBrush(fillColor) });

            var strokeGeometry = new PathGeometry();
            var strokeFigure = new PathFigure { StartPoint = points[1] };
            strokeFigure.Segments.Add(new PolyLineSegment(points.Skip(2).Take(points.Count - 3), true));
            strokeGeometry.Figures.Add(strokeFigure);
            canvas.Children.Add(new System.Windows.Shapes.Path { Data = strokeGeometry, Stroke = new SolidColorBrush(strokeColor), StrokeThickness = 1.5 });
        }

        private void DrawHistogramAxes(Canvas canvas, double xMin, double xMax, int maxBin, int paramIndex)
        {
            if (selectedFile == null) return;
            double plotLeft = plotMargin.Left;
            double plotRight = plotWidth - plotMargin.Right;
            double plotBottom = plotHeight - plotMargin.Bottom;

            canvas.Children.Add(new Line { X1 = plotLeft, Y1 = plotBottom, X2 = plotRight, Y2 = plotBottom, Stroke = Brushes.Black, StrokeThickness = 1 });
            canvas.Children.Add(new Line { X1 = plotLeft, Y1 = plotMargin.Top, X2 = plotLeft, Y2 = plotBottom, Stroke = Brushes.Black, StrokeThickness = 1 });

            foreach (var tick in GetAxisTicks(xMin, xMax, histLogScale))
            {
                double x = HistDataToScreenX(tick, xMin, xMax);
                if (x >= plotLeft && x <= plotRight)
                {
                    var label = new TextBlock { Text = FormatAxisValue(tick), Foreground = Brushes.Black, FontSize = 10 };
                    label.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                    Canvas.SetLeft(label, x - label.DesiredSize.Width / 2);
                    Canvas.SetTop(label, plotBottom + 7);
                    canvas.Children.Add(label);
                }
            }

            var xLabel = new TextBlock { Text = selectedFile.Parameters[paramIndex].Label, Foreground = Brushes.Black, FontSize = 12, FontWeight = FontWeights.SemiBold };
            xLabel.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            Canvas.SetLeft(xLabel, (plotLeft + plotRight) / 2 - xLabel.DesiredSize.Width / 2);
            Canvas.SetTop(xLabel, plotHeight - 18);
            canvas.Children.Add(xLabel);

            var yLabel = new TextBlock { Text = "Count", Foreground = Brushes.Black, FontSize = 12, FontWeight = FontWeights.SemiBold, RenderTransform = new RotateTransform(-90) };
            Canvas.SetLeft(yLabel, 5);
            Canvas.SetTop(yLabel, plotHeight / 2 + 20);
            canvas.Children.Add(yLabel);
        }

        #endregion

        #region Export

        private void BtnExportDot_Click(object sender, RoutedEventArgs e) => ExportPlot("dot");
        private void BtnExportContour_Click(object sender, RoutedEventArgs e) => ExportPlot("contour");
        private void BtnExportHistogram_Click(object sender, RoutedEventArgs e) => ExportHistogram();

        private void ExportPlot(string type)
        {
            if (selectedFile == null) return;
            var canvas = GetCurrentCanvas();
            if (canvas == null) return;

            var dialog = new SaveFileDialog { Filter = "PNG Image (*.png)|*.png", FileName = $"scatter_{type}_{DateTime.Now:yyyyMMdd_HHmmss}.png" };
            if (dialog.ShowDialog() == true)
            {
                var currentChildren = canvas.Children.Cast<UIElement>().ToList();
                canvas.Children.Clear();
                DrawScatterPlot(canvas, true, type);

                var renderBitmap = new RenderTargetBitmap((int)(plotWidth * 2), (int)(plotHeight * 2), 192, 192, PixelFormats.Pbgra32);
                canvas.Measure(new Size(plotWidth, plotHeight));
                canvas.Arrange(new Rect(0, 0, plotWidth, plotHeight));
                renderBitmap.Render(canvas);

                var encoder = new PngBitmapEncoder();
                encoder.Frames.Add(BitmapFrame.Create(renderBitmap));
                using (var fs = new FileStream(dialog.FileName, FileMode.Create)) encoder.Save(fs);

                canvas.Children.Clear();
                foreach (var child in currentChildren) canvas.Children.Add(child);
                txtStatus.Text = $"Exported to {dialog.FileName}";
            }
        }

        private void ExportHistogram()
        {
            if (selectedFile == null) return;
            var canvas = GetCurrentCanvas();
            if (canvas == null) return;

            var dialog = new SaveFileDialog { Filter = "PNG Image (*.png)|*.png", FileName = $"histogram_{DateTime.Now:yyyyMMdd_HHmmss}.png" };
            if (dialog.ShowDialog() == true)
            {
                var currentChildren = canvas.Children.Cast<UIElement>().ToList();
                canvas.Children.Clear();
                DrawHistogram(canvas, true);

                var renderBitmap = new RenderTargetBitmap((int)(plotWidth * 2), (int)(plotHeight * 2), 192, 192, PixelFormats.Pbgra32);
                canvas.Measure(new Size(plotWidth, plotHeight));
                canvas.Arrange(new Rect(0, 0, plotWidth, plotHeight));
                renderBitmap.Render(canvas);

                var encoder = new PngBitmapEncoder();
                encoder.Frames.Add(BitmapFrame.Create(renderBitmap));
                using (var fs = new FileStream(dialog.FileName, FileMode.Create)) encoder.Save(fs);

                canvas.Children.Clear();
                foreach (var child in currentChildren) canvas.Children.Add(child);
                txtStatus.Text = $"Exported to {dialog.FileName}";
            }
        }

        private void BtnCopyPlot_Click(object sender, RoutedEventArgs e) => CopyPlotToClipboard();

        private void CopyPlotToClipboard()
        {
            if (selectedFile == null) return;
            var canvas = GetCurrentCanvas();
            if (canvas == null) return;

            try
            {
                var currentChildren = canvas.Children.Cast<UIElement>().ToList();
                canvas.Children.Clear();

                // Redraw for export quality
                if (currentView == "scatter")
                    DrawScatterPlot(canvas, true, plotType);
                else
                    DrawHistogram(canvas, true);

                var renderBitmap = new RenderTargetBitmap(
                    (int)(plotWidth * 2), (int)(plotHeight * 2), 192, 192, PixelFormats.Pbgra32);
                canvas.Measure(new Size(plotWidth, plotHeight));
                canvas.Arrange(new Rect(0, 0, plotWidth, plotHeight));
                renderBitmap.Render(canvas);

                Clipboard.SetImage(renderBitmap);

                // Restore canvas
                canvas.Children.Clear();
                foreach (var child in currentChildren) canvas.Children.Add(child);

                txtStatus.Text = "Plot copied to clipboard (Ctrl+C)";
            }
            catch (Exception ex)
            {
                txtStatus.Text = $"Copy failed: {ex.Message}";
            }
        }

        #endregion

        #region Statistics Recording

        private void BtnRecordStats_Click(object sender, RoutedEventArgs e)
        {
            if (selectedFile == null)
            {
                MessageBox.Show("Please load a file first.", "Info", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            if (currentView == "histogram")
            {
                RecordHistogramStats();
            }
            else
            {
                RecordScatterStats();
            }

            // Auto-expand the stats panel
            pnlStats.Visibility = Visibility.Visible;
        }

        private void RecordHistogramStats()
        {
            if (selectedFile == null || cboHistParam.SelectedIndex < 0) return;

            int paramIndex = cboHistParam.SelectedIndex;
            string paramName = selectedFile.Parameters[paramIndex].Label;
            var displayIndices = GetDisplayEventIndices();
            var values = displayIndices.Select(i => selectedFile.Events[i][paramIndex]).Where(v => v > 0).ToList();
            int totalEvents = values.Count;

            string parentGate = histParentGateIndex >= 0 && histParentGateIndex < gateTemplates.Count
                ? gateTemplates[histParentGateIndex].Name : "All Events";

            // Record Threshold if active
            if (histThreshold.HasValue && histGatingMode == "threshold")
            {
                int aboveCount = values.Count(v => v >= histThreshold.Value);
                int belowCount = totalEvents - aboveCount;
                double abovePercent = totalEvents > 0 ? (aboveCount * 100.0 / totalEvents) : 0;
                double belowPercent = totalEvents > 0 ? (belowCount * 100.0 / totalEvents) : 0;

                statsRecords.Add(new StatsRecord
                {
                    SampleName = selectedFile.Filename,
                    ViewType = "Histogram",
                    Parameters = paramName,
                    GateRegion = $"< {FormatAxisValue(histThreshold.Value)}",
                    Count = belowCount.ToString("N0"),
                    Percentage = $"{belowPercent:F2}%",
                    ParentGate = parentGate,
                    Details = $"Threshold: {FormatAxisValue(histThreshold.Value)}"
                });

                statsRecords.Add(new StatsRecord
                {
                    SampleName = selectedFile.Filename,
                    ViewType = "Histogram",
                    Parameters = paramName,
                    GateRegion = $"≥ {FormatAxisValue(histThreshold.Value)}",
                    Count = aboveCount.ToString("N0"),
                    Percentage = $"{abovePercent:F2}%",
                    ParentGate = parentGate,
                    Details = $"Threshold: {FormatAxisValue(histThreshold.Value)}"
                });

                txtStatus.Text = $"Recorded threshold stats for {selectedFile.Filename}";
            }
            // Record Range Gates
            else
            {
                bool recorded = false;
                foreach (var gate in gateTemplates)
                {
                    if (gate.GateType != GateType.Range) continue;
                    if (!gate.XParamName.Equals(paramName, StringComparison.OrdinalIgnoreCase)) continue;

                    int count = GetGateEventCount(gate.Name);
                    double percent = totalEvents > 0 ? (count * 100.0 / totalEvents) : 0;

                    statsRecords.Add(new StatsRecord
                    {
                        SampleName = selectedFile.Filename,
                        ViewType = "Histogram",
                        Parameters = paramName,
                        GateRegion = gate.Name,
                        Count = count.ToString("N0"),
                        Percentage = $"{percent:F2}%",
                        ParentGate = string.IsNullOrEmpty(gate.ParentGateName) ? "All Events" : gate.ParentGateName,
                        Details = $"Range: {FormatAxisValue(gate.RangeMin)} ~ {FormatAxisValue(gate.RangeMax)}"
                    });
                    recorded = true;
                }

                if (!recorded)
                {
                    // Just record total events
                    statsRecords.Add(new StatsRecord
                    {
                        SampleName = selectedFile.Filename,
                        ViewType = "Histogram",
                        Parameters = paramName,
                        GateRegion = "Total",
                        Count = totalEvents.ToString("N0"),
                        Percentage = "100%",
                        ParentGate = parentGate,
                        Details = ""
                    });
                }

                txtStatus.Text = $"Recorded histogram stats for {selectedFile.Filename}";
            }
        }

        private void RecordScatterStats()
        {
            if (selectedFile == null || cboXParam.SelectedIndex < 0 || cboYParam.SelectedIndex < 0) return;

            int xIndex = cboXParam.SelectedIndex;
            int yIndex = cboYParam.SelectedIndex;
            string xParam = selectedFile.Parameters[xIndex].Label;
            string yParam = selectedFile.Parameters[yIndex].Label;

            var displayIndices = GetDisplayEventIndices();
            var plotData = displayIndices.Select(i => selectedFile.Events[i]).ToList();
            var validData = plotData.Where(ev => ev[xIndex] > 0 && ev[yIndex] > 0).ToList();
            int totalEvents = validData.Count;

            string parentGate = parentGateIndex >= 0 && parentGateIndex < gateTemplates.Count
                ? gateTemplates[parentGateIndex].Name : "All Events";

            // Record Quadrant if active
            if (quadrantPosition.HasValue)
            {
                int q1 = validData.Count(ev => ev[xIndex] >= quadrantPosition.Value.X && ev[yIndex] >= quadrantPosition.Value.Y);
                int q2 = validData.Count(ev => ev[xIndex] < quadrantPosition.Value.X && ev[yIndex] >= quadrantPosition.Value.Y);
                int q3 = validData.Count(ev => ev[xIndex] < quadrantPosition.Value.X && ev[yIndex] < quadrantPosition.Value.Y);
                int q4 = validData.Count(ev => ev[xIndex] >= quadrantPosition.Value.X && ev[yIndex] < quadrantPosition.Value.Y);

                string qDetails = $"X={FormatAxisValue(quadrantPosition.Value.X)}, Y={FormatAxisValue(quadrantPosition.Value.Y)}";

                statsRecords.Add(new StatsRecord
                {
                    SampleName = selectedFile.Filename,
                    ViewType = "Scatter",
                    Parameters = $"{xParam} / {yParam}",
                    GateRegion = "Q1 (+/+)",
                    Count = q1.ToString("N0"),
                    Percentage = $"{(totalEvents > 0 ? q1 * 100.0 / totalEvents : 0):F2}%",
                    ParentGate = parentGate,
                    Details = qDetails
                });

                statsRecords.Add(new StatsRecord
                {
                    SampleName = selectedFile.Filename,
                    ViewType = "Scatter",
                    Parameters = $"{xParam} / {yParam}",
                    GateRegion = "Q2 (-/+)",
                    Count = q2.ToString("N0"),
                    Percentage = $"{(totalEvents > 0 ? q2 * 100.0 / totalEvents : 0):F2}%",
                    ParentGate = parentGate,
                    Details = qDetails
                });

                statsRecords.Add(new StatsRecord
                {
                    SampleName = selectedFile.Filename,
                    ViewType = "Scatter",
                    Parameters = $"{xParam} / {yParam}",
                    GateRegion = "Q3 (-/-)",
                    Count = q3.ToString("N0"),
                    Percentage = $"{(totalEvents > 0 ? q3 * 100.0 / totalEvents : 0):F2}%",
                    ParentGate = parentGate,
                    Details = qDetails
                });

                statsRecords.Add(new StatsRecord
                {
                    SampleName = selectedFile.Filename,
                    ViewType = "Scatter",
                    Parameters = $"{xParam} / {yParam}",
                    GateRegion = "Q4 (+/-)",
                    Count = q4.ToString("N0"),
                    Percentage = $"{(totalEvents > 0 ? q4 * 100.0 / totalEvents : 0):F2}%",
                    ParentGate = parentGate,
                    Details = qDetails
                });

                txtStatus.Text = $"Recorded quadrant stats for {selectedFile.Filename}";
            }
            else
            {
                // Record Polygon Gates on current parameters
                bool recorded = false;
                foreach (var gate in gateTemplates)
                {
                    if (gate.GateType != GateType.Polygon) continue;

                    int gateXIndex = FindParameterIndex(selectedFile, gate.XParamName);
                    int gateYIndex = FindParameterIndex(selectedFile, gate.YParamName);
                    if (gateXIndex != xIndex || gateYIndex != yIndex) continue;

                    int count = GetGateEventCount(gate.Name);
                    double percent = totalEvents > 0 ? (count * 100.0 / totalEvents) : 0;

                    statsRecords.Add(new StatsRecord
                    {
                        SampleName = selectedFile.Filename,
                        ViewType = "Scatter",
                        Parameters = $"{xParam} / {yParam}",
                        GateRegion = gate.Name,
                        Count = count.ToString("N0"),
                        Percentage = $"{percent:F2}%",
                        ParentGate = string.IsNullOrEmpty(gate.ParentGateName) ? "All Events" : gate.ParentGateName,
                        Details = $"Polygon gate ({gate.Points.Count} vertices)"
                    });
                    recorded = true;
                }

                if (!recorded)
                {
                    // Just record total events
                    statsRecords.Add(new StatsRecord
                    {
                        SampleName = selectedFile.Filename,
                        ViewType = "Scatter",
                        Parameters = $"{xParam} / {yParam}",
                        GateRegion = "Total",
                        Count = totalEvents.ToString("N0"),
                        Percentage = "100%",
                        ParentGate = parentGate,
                        Details = ""
                    });
                }

                txtStatus.Text = $"Recorded scatter stats for {selectedFile.Filename}";
            }
        }

        private void BtnClearStats_Click(object sender, RoutedEventArgs e)
        {
            statsRecords.Clear();
            txtStatus.Text = "Statistics records cleared";
        }

        private void BtnExportStats_Click(object sender, RoutedEventArgs e)
        {
            if (statsRecords.Count == 0)
            {
                MessageBox.Show("No statistics to export.", "Info", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            var dialog = new SaveFileDialog
            {
                Filter = "CSV File (*.csv)|*.csv",
                FileName = $"flow_stats_{DateTime.Now:yyyyMMdd_HHmmss}.csv"
            };

            if (dialog.ShowDialog() == true)
            {
                var sb = new StringBuilder();
                sb.AppendLine("Sample,View,Parameters,Gate/Region,Count,Percentage,Parent Gate,Details");

                foreach (var record in statsRecords)
                {
                    sb.AppendLine($"\"{record.SampleName}\",\"{record.ViewType}\",\"{record.Parameters}\",\"{record.GateRegion}\",\"{record.Count}\",\"{record.Percentage}\",\"{record.ParentGate}\",\"{record.Details}\"");
                }

                File.WriteAllText(dialog.FileName, sb.ToString(), Encoding.UTF8);
                txtStatus.Text = $"Statistics exported to {dialog.FileName}";
            }
        }

        private void BtnCopyStats_Click(object sender, RoutedEventArgs e)
        {
            if (statsRecords.Count == 0)
            {
                MessageBox.Show("No statistics to copy.", "Info", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            var sb = new StringBuilder();
            sb.AppendLine("Sample\tView\tParameters\tGate/Region\tCount\tPercentage\tParent Gate\tDetails");

            foreach (var record in statsRecords)
            {
                sb.AppendLine($"{record.SampleName}\t{record.ViewType}\t{record.Parameters}\t{record.GateRegion}\t{record.Count}\t{record.Percentage}\t{record.ParentGate}\t{record.Details}");
            }

            Clipboard.SetText(sb.ToString());
            txtStatus.Text = $"Copied {statsRecords.Count} records to clipboard";
        }

        private void BtnHideStats_Click(object sender, RoutedEventArgs e)
        {
            pnlStats.Visibility = Visibility.Collapsed;
        }

        private void BtnPrevSample_Click(object sender, RoutedEventArgs e)
        {
            if (fcsFiles.Count == 0) return;

            int currentIndex = cboFiles.SelectedIndex;
            if (currentIndex > 0)
            {
                cboFiles.SelectedIndex = currentIndex - 1;
            }
            else
            {
                // Wrap to last sample
                cboFiles.SelectedIndex = fcsFiles.Count - 1;
            }
        }

        private void BtnNextSample_Click(object sender, RoutedEventArgs e)
        {
            if (fcsFiles.Count == 0) return;

            int currentIndex = cboFiles.SelectedIndex;
            if (currentIndex < fcsFiles.Count - 1)
            {
                cboFiles.SelectedIndex = currentIndex + 1;
            }
            else
            {
                // Wrap to first sample
                cboFiles.SelectedIndex = 0;
            }
        }

        private void Window_KeyDown(object sender, KeyEventArgs e)
        {
            if (Keyboard.Modifiers == ModifierKeys.Control)
            {
                switch (e.Key)
                {
                    case Key.C:
                        CopyPlotToClipboard();
                        e.Handled = true;
                        break;
                    case Key.M:
                        BtnRecordStats_Click(sender, e);
                        e.Handled = true;
                        break;
                    case Key.N:
                        BtnNextSample_Click(sender, e);
                        e.Handled = true;
                        break;
                    case Key.P:
                        BtnPrevSample_Click(sender, e);
                        e.Handled = true;
                        break;
                }
            }
        }

        #endregion

        #region Color Functions

        private Color GetDotColor(double t)
        {
            t = Math.Max(0, Math.Min(1, t));
            switch (dotColormap)
            {
                case "Turbo": return GetTurboColor(t);
                case "Viridis": return GetViridisColor(t);
                case "Plasma": return GetPlasmaColor(t);
                case "Inferno": return GetInfernoColor(t);
                case "Grayscale": byte g = (byte)(255 * (1 - t)); return Color.FromRgb(g, g, g);
                default: return Color.FromRgb((byte)(255 * (1 - t * 0.9)), (byte)(255 * (1 - t * 0.7)), 255);
            }
        }

        private Color GetContourColor(double t)
        {
            t = Math.Max(0, Math.Min(1, t));
            switch (contourColormap)
            {
                case "RdYlBu": return GetRdYlBuColor(t);
                case "Spectral": return GetSpectralColor(t);
                case "Hot": return GetHotColor(t);
                case "Cool": return GetCoolColor(t);
                case "Grayscale": byte g = (byte)(255 * t); return Color.FromRgb(g, g, g);
                default: return GetYlOrRdColor(t);
            }
        }

        private Color GetHistogramColor()
        {
            switch (histColor)
            {
                case "Red": return Color.FromRgb(220, 53, 69);
                case "Green": return Color.FromRgb(40, 167, 69);
                case "Orange": return Color.FromRgb(255, 140, 0);
                case "Purple": return Color.FromRgb(128, 0, 128);
                case "Gray": return Color.FromRgb(108, 117, 125);
                default: return Color.FromRgb(65, 105, 225);
            }
        }

        private Color GetTurboColor(double t)
        {
            double r = Math.Max(0, Math.Min(1, 0.13572138 + t * (4.61539260 + t * (-42.66032258 + t * (132.13108234 + t * (-152.94239396 + t * 59.28637943))))));
            double g = Math.Max(0, Math.Min(1, 0.09140261 + t * (2.19418839 + t * (4.84296658 + t * (-14.18503333 + t * (4.27729857 + t * 2.82956604))))));
            double b = Math.Max(0, Math.Min(1, 0.10667330 + t * (12.64194608 + t * (-60.58204836 + t * (110.36276771 + t * (-89.90310912 + t * 27.34824973))))));
            return Color.FromRgb((byte)(r * 255), (byte)(g * 255), (byte)(b * 255));
        }

        private Color GetViridisColor(double t)
        {
            double r = 0.267004 + t * (0.282327 + t * (-1.441789 + t * (2.814903 - t * 1.292667)));
            double g = 0.004874 + t * (1.242610 + t * (-0.372511 + t * (-0.556710 + t * 0.692985)));
            double b = 0.329415 + t * (0.753434 + t * (-2.291062 + t * (3.215906 - t * 1.487633)));
            return Color.FromRgb((byte)(Math.Max(0, Math.Min(1, r)) * 255), (byte)(Math.Max(0, Math.Min(1, g)) * 255), (byte)(Math.Max(0, Math.Min(1, b)) * 255));
        }

        private Color GetPlasmaColor(double t)
        {
            double r = 0.050383 + t * (2.028287 + t * (-1.312458 + t * 0.289932));
            double g = 0.029803 + t * (-0.578467 + t * (2.870014 - t * 1.422450));
            double b = 0.527975 + t * (0.956655 + t * (-2.667696 + t * 1.250893));
            return Color.FromRgb((byte)(Math.Max(0, Math.Min(1, r)) * 255), (byte)(Math.Max(0, Math.Min(1, g)) * 255), (byte)(Math.Max(0, Math.Min(1, b)) * 255));
        }

        private Color GetInfernoColor(double t)
        {
            double r = 0.001462 + t * (1.201313 + t * (1.246790 - t * 1.493180));
            double g = 0.000466 + t * (-0.148193 + t * (1.853786 - t * 0.987266));
            double b = 0.013866 + t * (1.497654 + t * (-3.245667 + t * 1.732578));
            return Color.FromRgb((byte)(Math.Max(0, Math.Min(1, r)) * 255), (byte)(Math.Max(0, Math.Min(1, g)) * 255), (byte)(Math.Max(0, Math.Min(1, b)) * 255));
        }

        private Color GetYlOrRdColor(double t)
        {
            if (t < 0.5) { double t2 = t * 2; return Color.FromRgb(255, (byte)(255 - t2 * 127), (byte)(200 - t2 * 150)); }
            else { double t2 = (t - 0.5) * 2; return Color.FromRgb((byte)(255 - t2 * 55), (byte)(128 - t2 * 80), (byte)(50 - t2 * 50)); }
        }

        private Color GetRdYlBuColor(double t)
        {
            if (t < 0.5) { double t2 = t * 2; return Color.FromRgb((byte)(165 + t2 * 90), (byte)(0 + t2 * 255), (byte)(38 + t2 * 102)); }
            else { double t2 = (t - 0.5) * 2; return Color.FromRgb((byte)(255 - t2 * 206), (byte)(255 - t2 * 131), (byte)(140 + t2 * 115)); }
        }

        private Color GetSpectralColor(double t)
        {
            if (t < 0.25) return Color.FromRgb((byte)(158 + t * 4 * 55), (byte)(1 + t * 4 * 128), (byte)(66 - t * 4 * 30));
            else if (t < 0.5) return Color.FromRgb(213, (byte)(129 + (t - 0.25) * 4 * 86), (byte)(36 + (t - 0.25) * 4 * 85));
            else if (t < 0.75) return Color.FromRgb((byte)(213 - (t - 0.5) * 4 * 110), (byte)(215 - (t - 0.5) * 4 * 36), (byte)(121 + (t - 0.5) * 4 * 50));
            else return Color.FromRgb((byte)(103 - (t - 0.75) * 4 * 53), (byte)(179 - (t - 0.75) * 4 * 85), (byte)(171 + (t - 0.75) * 4 * 51));
        }

        private Color GetHotColor(double t)
        {
            if (t < 0.33) return Color.FromRgb((byte)(t * 3 * 255), 0, 0);
            else if (t < 0.67) return Color.FromRgb(255, (byte)((t - 0.33) * 3 * 255), 0);
            else return Color.FromRgb(255, 255, (byte)((t - 0.67) * 3 * 255));
        }

        private Color GetCoolColor(double t) => Color.FromRgb((byte)(t * 255), (byte)((1 - t) * 255), 255);

        #endregion

        #region Utility Functions

        private double DataToScreenX(double value, double xMin, double xMax)
        {
            double plotLeft = plotMargin.Left;
            double plotRight = plotWidth - plotMargin.Right;
            if (xLogScale)
            {
                double logMin = Math.Log10(Math.Max(0.1, xMin));
                double logMax = Math.Log10(xMax);
                double logVal = Math.Log10(Math.Max(0.1, value));
                return plotLeft + (logVal - logMin) / (logMax - logMin) * (plotRight - plotLeft);
            }
            return plotLeft + (value - xMin) / (xMax - xMin) * (plotRight - plotLeft);
        }

        private double DataToScreenY(double value, double yMin, double yMax)
        {
            double plotTop = plotMargin.Top;
            double plotBottom = plotHeight - plotMargin.Bottom;
            if (yLogScale)
            {
                double logMin = Math.Log10(Math.Max(0.1, yMin));
                double logMax = Math.Log10(yMax);
                double logVal = Math.Log10(Math.Max(0.1, value));
                return plotBottom - (logVal - logMin) / (logMax - logMin) * (plotBottom - plotTop);
            }
            return plotBottom - (value - yMin) / (yMax - yMin) * (plotBottom - plotTop);
        }

        private double HistDataToScreenX(double value, double xMin, double xMax)
        {
            double plotLeft = plotMargin.Left;
            double plotRight = plotWidth - plotMargin.Right;
            if (histLogScale)
            {
                double logMin = Math.Log10(Math.Max(0.1, xMin));
                double logMax = Math.Log10(xMax);
                double logVal = Math.Log10(Math.Max(0.1, value));
                return plotLeft + (logVal - logMin) / (logMax - logMin) * (plotRight - plotLeft);
            }
            return plotLeft + (value - xMin) / (xMax - xMin) * (plotRight - plotLeft);
        }

        private List<double> GetAxisTicks(double min, double max, bool isLog)
        {
            var ticks = new List<double>();
            if (isLog)
            {
                double logMin = Math.Floor(Math.Log10(Math.Max(0.1, min)));
                double logMax = Math.Ceiling(Math.Log10(max));
                for (double p = logMin; p <= logMax; p++)
                {
                    double val = Math.Pow(10, p);
                    if (val >= min && val <= max) ticks.Add(val);
                }
            }
            else
            {
                double range = max - min;
                double step = Math.Pow(10, Math.Floor(Math.Log10(range / 5)));
                if (range / step > 10) step *= 2;
                if (range / step < 4) step /= 2;
                for (double v = Math.Ceiling(min / step) * step; v <= max; v += step) ticks.Add(v);
            }
            return ticks;
        }

        private string FormatAxisValue(double value)
        {
            if (value >= 1000000) return $"{value / 1000000:F0}M";
            if (value >= 1000) return $"{value / 1000:F0}K";
            if (value < 1 && value > 0) return $"{value:F1}";
            return $"{value:F0}";
        }

        private bool PointInPolygon(Point point, List<Point> polygon)
        {
            if (polygon.Count < 3) return false;
            bool inside = false;
            for (int i = 0, j = polygon.Count - 1; i < polygon.Count; j = i++)
            {
                if (((polygon[i].Y > point.Y) != (polygon[j].Y > point.Y)) &&
                    (point.X < (polygon[j].X - polygon[i].X) * (point.Y - polygon[i].Y) / (polygon[j].Y - polygon[i].Y) + polygon[i].X))
                    inside = !inside;
            }
            return inside;
        }

        #endregion
    }

    #region Data Classes

    public class StatsRecord
    {
        public string SampleName { get; set; } = string.Empty;
        public string ViewType { get; set; } = string.Empty;
        public string Parameters { get; set; } = string.Empty;
        public string GateRegion { get; set; } = string.Empty;
        public string Count { get; set; } = string.Empty;
        public string Percentage { get; set; } = string.Empty;
        public string ParentGate { get; set; } = string.Empty;
        public string Details { get; set; } = string.Empty;
    }

    public class FcsFile
    {
        public string Filename { get; set; } = string.Empty;
        public List<FcsParameter> Parameters { get; set; } = new List<FcsParameter>();
        public List<float[]> Events { get; set; } = new List<float[]>();  // Changed from double[] to float[]
        public int EventCount => Events.Count;
    }

    public class FcsParameter
    {
        public string Name { get; set; } = string.Empty;
        public string Label { get; set; } = string.Empty;
    }

    public enum GateType
    {
        Polygon,
        Range
    }

    public class GateTemplate
    {
        public string Name { get; set; } = string.Empty;
        public GateType GateType { get; set; } = GateType.Polygon;
        public List<Point> Points { get; set; } = new List<Point>();
        public string DisplayName { get; set; } = string.Empty;
        public int XParamIndex { get; set; }
        public int YParamIndex { get; set; }
        public string XParamName { get; set; } = string.Empty;
        public string YParamName { get; set; } = string.Empty;
        public string ParentGateName { get; set; } = string.Empty;

        // For Range gates
        public double RangeMin { get; set; }
        public double RangeMax { get; set; }
    }

    #endregion

    #region Extension Methods

    public static class DictionaryExtensions
    {
        public static string? GetValueOrDefault(this Dictionary<string, string> dict, string key)
        {
            return dict.TryGetValue(key, out string? value) ? value : null;
        }
    }

    #endregion
}


==================================================
FILE_NAME: GeneIdConverterPage.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\GeneIdConverterPage.xaml
==================================================
<Page x:Class="BioSAK.Pages.GeneIdConverterPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      mc:Ignorable="d" 
      d:DesignHeight="800" d:DesignWidth="1000"
      Title="Gene ID Converter"
      Background="#F5F5F5">

    <Page.Resources>
        <Style x:Key="SectionBorderStyle" TargetType="Border">
            <Setter Property="Background" Value="White"/>
            <Setter Property="CornerRadius" Value="8"/>
            <Setter Property="Padding" Value="20"/>
            <Setter Property="Margin" Value="0,0,0,15"/>
            <Setter Property="Effect">
                <Setter.Value>
                    <DropShadowEffect BlurRadius="10" ShadowDepth="2" Opacity="0.1"/>
                </Setter.Value>
            </Setter>
        </Style>

        <Style x:Key="ActionButtonStyle" TargetType="Button">
            <Setter Property="Padding" Value="15,8"/>
            <Setter Property="Background" Value="#2196F3"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="FontSize" Value="13"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" 
                                CornerRadius="4" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#1976D2"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <Style x:Key="ExportButtonStyle" TargetType="Button" BasedOn="{StaticResource ActionButtonStyle}">
            <Setter Property="Background" Value="#4CAF50"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" 
                                CornerRadius="4" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#388E3C"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <Style x:Key="DataGridStyle" TargetType="DataGrid">
            <Setter Property="AutoGenerateColumns" Value="False"/>
            <Setter Property="IsReadOnly" Value="True"/>
            <Setter Property="CanUserAddRows" Value="False"/>
            <Setter Property="CanUserDeleteRows" Value="False"/>
            <Setter Property="GridLinesVisibility" Value="Horizontal"/>
            <Setter Property="HorizontalGridLinesBrush" Value="#E0E0E0"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="BorderBrush" Value="#E0E0E0"/>
            <Setter Property="RowHeight" Value="28"/>
            <Setter Property="ColumnHeaderHeight" Value="32"/>
            <Setter Property="EnableRowVirtualization" Value="True"/>
            <Setter Property="EnableColumnVirtualization" Value="True"/>
            <Setter Property="VirtualizingPanel.IsVirtualizing" Value="True"/>
            <Setter Property="VirtualizingPanel.VirtualizationMode" Value="Recycling"/>
            <Setter Property="ScrollViewer.IsDeferredScrollingEnabled" Value="True"/>
            <!-- 單格選取設定 -->
            <Setter Property="SelectionMode" Value="Extended"/>
            <Setter Property="SelectionUnit" Value="CellOrRowHeader"/>
            <Setter Property="ClipboardCopyMode" Value="IncludeHeader"/>
        </Style>
    </Page.Resources>

    <Grid Margin="20">
        <!-- 進度條覆蓋層 -->
        <Grid x:Name="ProgressOverlay" Visibility="Collapsed" Panel.ZIndex="100">
            <Border Background="#80000000"/>
            <Border Background="White" CornerRadius="8" Padding="30" 
                    HorizontalAlignment="Center" VerticalAlignment="Center" MinWidth="300">
                <StackPanel>
                    <TextBlock x:Name="ProgressTitle" Text="Loading..." FontSize="16" FontWeight="SemiBold" Margin="0,0,0,15"/>
                    <ProgressBar x:Name="ProgressBar" Height="20" Minimum="0" Maximum="100" Value="0"/>
                    <TextBlock x:Name="ProgressText" Text="0%" HorizontalAlignment="Center" Margin="0,10,0,0" Foreground="#666"/>
                </StackPanel>
            </Border>
        </Grid>

        <ScrollViewer VerticalScrollBarVisibility="Auto">
            <StackPanel>
                <!-- 標題 -->
                <TextBlock Text="🧬 Gene ID Converter" FontSize="24" FontWeight="Bold" 
                           Foreground="#1976D2" Margin="0,0,0,20"/>

                <!-- 設定區 -->
                <Border Style="{StaticResource SectionBorderStyle}">
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                        </Grid.RowDefinitions>

                        <!-- 物種選擇 -->
                        <TextBlock Grid.Row="0" Grid.Column="0" Text="Species:" 
                                   FontWeight="SemiBold" VerticalAlignment="Center" Margin="0,0,15,10"/>
                        <ComboBox x:Name="SpeciesComboBox" Grid.Row="0" Grid.Column="1" 
                                  Width="250" Height="32" HorizontalAlignment="Left" Margin="0,0,0,10"
                                  SelectionChanged="SpeciesComboBox_SelectionChanged">
                            <ComboBoxItem Content="Human (Homo sapiens)" Tag="human" IsSelected="True"/>
                            <ComboBoxItem Content="Mouse (Mus musculus)" Tag="mouse"/>
                            <ComboBoxItem Content="Rat (Rattus norvegicus)" Tag="rat"/>
                            <ComboBoxItem Content="Zebrafish (Danio rerio)" Tag="zebrafish"/>
                            <ComboBoxItem Content="Fly (D. melanogaster)" Tag="fly"/>
                            <ComboBoxItem Content="Worm (C. elegans)" Tag="worm"/>
                        </ComboBox>

                        <!-- 輸入類型 -->
                        <TextBlock Grid.Row="1" Grid.Column="0" Text="Input Type:" 
                                   FontWeight="SemiBold" VerticalAlignment="Center" Margin="0,0,15,10"/>
                        <StackPanel Grid.Row="1" Grid.Column="1" Orientation="Horizontal" Margin="0,0,0,10">
                            <RadioButton x:Name="InputTypeAuto" Content="Auto Detect" IsChecked="True" Margin="0,0,20,0"/>
                            <RadioButton x:Name="InputTypeSymbol" Content="Symbol" Margin="0,0,20,0"/>
                            <RadioButton x:Name="InputTypeEnsembl" Content="Ensembl ID" Margin="0,0,20,0"/>
                            <RadioButton x:Name="InputTypeEntrez" Content="Entrez ID" Margin="0,0,20,0"/>
                            <RadioButton x:Name="InputTypeHGNC" Content="HGNC ID" Margin="0,0,0,0"/>
                        </StackPanel>

                        <!-- 提示訊息 -->
                        <TextBlock Grid.Row="2" Grid.Column="1" 
                                   Text="💡 Auto Detect: Symbol, Ensembl (ENSG...), Entrez (numbers), HGNC (HGNC:...)"
                                   Foreground="#666" FontSize="11" Margin="0,0,0,5"/>
                    </Grid>
                </Border>

                <!-- 輸入區 -->
                <Border Style="{StaticResource SectionBorderStyle}">
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <StackPanel Grid.Column="0">
                            <TextBlock Text="📝 Input Gene IDs (one per line, or comma/tab separated)" 
                                       FontWeight="SemiBold" Margin="0,0,0,10"/>
                            <TextBox x:Name="InputGenesTextBox" 
                                     Height="200" 
                                     AcceptsReturn="True" 
                                     TextWrapping="Wrap"
                                     VerticalScrollBarVisibility="Auto"
                                     FontFamily="Consolas"
                                     FontSize="12"
                                     Padding="8"/>
                            <TextBlock x:Name="InputCountText" Text="0 genes" 
                                       Foreground="#666" Margin="0,5,0,0" FontSize="11"/>
                        </StackPanel>

                        <StackPanel Grid.Column="1" VerticalAlignment="Top" Margin="20,25,0,0">
                            <Button Content="🔄 Convert" Style="{StaticResource ActionButtonStyle}" 
                                    Click="Convert_Click" Width="120"/>
                            <Button Content="📋 Paste" Style="{StaticResource ActionButtonStyle}" 
                                    Click="Paste_Click" Width="120" Margin="0,10,0,0" Background="#FF9800"/>
                            <Button Content="🗑️ Clear" Style="{StaticResource ActionButtonStyle}" 
                                    Click="Clear_Click" Width="120" Margin="0,10,0,0" Background="#757575"/>
                            <Button Content="📂 Load File" Style="{StaticResource ActionButtonStyle}" 
                                    Click="LoadFile_Click" Width="120" Margin="0,10,0,0" Background="#9C27B0"/>
                        </StackPanel>
                    </Grid>
                </Border>

                <!-- 結果區 -->
                <Border Style="{StaticResource SectionBorderStyle}">
                    <StackPanel>
                        <Grid Margin="0,0,0,10">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="Auto"/>
                            </Grid.ColumnDefinitions>

                            <StackPanel Grid.Column="0" Orientation="Horizontal">
                                <TextBlock Text="📊 Conversion Results" FontWeight="SemiBold" 
                                           FontSize="14" VerticalAlignment="Center"/>
                                <TextBlock x:Name="ResultSummaryText" Text="" 
                                           Foreground="#666" Margin="15,0,0,0" VerticalAlignment="Center"/>
                            </StackPanel>

                            <StackPanel Grid.Column="1" Orientation="Horizontal">
                                <Button Content="📄 Export CSV" Style="{StaticResource ExportButtonStyle}"
                                        Click="ExportCsv_Click"/>
                                <Button Content="📋 Copy All" Style="{StaticResource ExportButtonStyle}"
                                        Click="CopyAll_Click" Margin="10,0,0,0" Background="#FF5722"/>
                            </StackPanel>
                        </Grid>

                        <!-- 提示：如何複製 -->
                        <TextBlock Text="💡 Select cells and Ctrl+C to copy, or right-click for options"
                                   Foreground="#888" FontSize="11" Margin="0,0,0,8"/>

                        <DataGrid x:Name="ResultsDataGrid" 
                                  Style="{StaticResource DataGridStyle}"
                                  Height="350">
                            <DataGrid.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Copy Cell(s)" Click="CopyCell_Click" InputGestureText="Ctrl+C"/>
                                    <MenuItem Header="Copy Row(s)" Click="CopyRow_Click"/>
                                    <MenuItem Header="Copy Column" Click="CopyColumn_Click"/>
                                    <Separator/>
                                    <MenuItem Header="Copy All" Click="CopyAll_Click"/>
                                </ContextMenu>
                            </DataGrid.ContextMenu>
                            <DataGrid.Columns>
                                <DataGridTextColumn Header="Input" Binding="{Binding Input}" Width="120"/>
                                <DataGridTextColumn Header="Status" Binding="{Binding Status}" Width="80"/>
                                <DataGridTextColumn Header="Symbol" Binding="{Binding Symbol}" Width="100"/>
                                <DataGridTextColumn Header="Ensembl ID" Binding="{Binding EnsemblId}" Width="180"/>
                                <DataGridTextColumn Header="Entrez ID" Binding="{Binding EntrezId}" Width="100"/>
                                <DataGridTextColumn Header="HGNC ID" Binding="{Binding HgncId}" Width="100"/>
                                <DataGridTextColumn Header="Full Name" Binding="{Binding FullName}" Width="250"/>
                                <DataGridTextColumn Header="Biotype" Binding="{Binding Biotype}" Width="120"/>
                            </DataGrid.Columns>
                        </DataGrid>

                        <!-- 未找到的基因 -->
                        <Expander x:Name="NotFoundExpander" Header="⚠️ Not Found" Margin="0,15,0,0" 
                                  Visibility="Collapsed">
                            <Border Background="#FFF3E0" CornerRadius="4" Padding="10" Margin="0,10,0,0">
                                <StackPanel>
                                    <TextBlock x:Name="NotFoundText" TextWrapping="Wrap" Foreground="#E65100"/>
                                    <Button Content="📋 Copy Not Found IDs" 
                                            Click="CopyNotFound_Click"
                                            HorizontalAlignment="Left" Margin="0,8,0,0"
                                            Padding="10,4" FontSize="11" Cursor="Hand"
                                            Background="#FF9800" Foreground="White" BorderThickness="0">
                                        <Button.Template>
                                            <ControlTemplate TargetType="Button">
                                                <Border x:Name="border" Background="{TemplateBinding Background}" 
                                                        CornerRadius="3" Padding="{TemplateBinding Padding}">
                                                    <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                                                </Border>
                                                <ControlTemplate.Triggers>
                                                    <Trigger Property="IsMouseOver" Value="True">
                                                        <Setter TargetName="border" Property="Background" Value="#F57C00"/>
                                                    </Trigger>
                                                </ControlTemplate.Triggers>
                                            </ControlTemplate>
                                        </Button.Template>
                                    </Button>
                                </StackPanel>
                            </Border>
                        </Expander>

                        <!-- 多重匹配的基因 -->
                        <Expander x:Name="MultiMatchExpander" Header="ℹ️ Multiple Matches" Margin="0,10,0,0"
                                  Visibility="Collapsed">
                            <Border Background="#E3F2FD" CornerRadius="4" Padding="10" Margin="0,10,0,0">
                                <TextBlock x:Name="MultiMatchText" TextWrapping="Wrap" Foreground="#1565C0"/>
                            </Border>
                        </Expander>
                    </StackPanel>
                </Border>

                <!-- 資料庫資訊 -->
                <Border Style="{StaticResource SectionBorderStyle}" Background="#FAFAFA">
                    <StackPanel>
                        <TextBlock Text="ℹ️ Database Information" FontWeight="SemiBold" Margin="0,0,0,10"/>
                        <TextBlock x:Name="DatabaseInfoText" TextWrapping="Wrap" Foreground="#666" FontSize="12">
                            <Run Text="Data source: HGNC (Human), NCBI Gene (Other species)"/>
                            <LineBreak/>
                            <Run x:Name="DatabaseVersionText" Text="Version: Loading..."/>
                        </TextBlock>
                        <TextBlock x:Name="LastUpdateText" Text="" Foreground="#666" 
                                   Margin="0,5,0,0" FontSize="11"/>
                        <TextBlock x:Name="AvailableDbText" Text="" Foreground="#888" 
                                   Margin="0,5,0,0" FontSize="11"/>

                        <!-- 更新資料庫區塊 -->
                        <Border Background="#E3F2FD" CornerRadius="4" Padding="12" Margin="0,15,0,0">
                            <StackPanel>
                                <TextBlock Text="🔄 Update Database" FontWeight="SemiBold" Margin="0,0,0,8"/>
                                <TextBlock Text="Select species to download from HGNC/NCBI:" Foreground="#666" FontSize="11" Margin="0,0,0,8"/>
                                <WrapPanel Margin="0,0,0,10">
                                    <CheckBox x:Name="UpdateHumanCheck" Content="Human (HGNC)" IsChecked="True" Margin="0,0,15,5"/>
                                    <CheckBox x:Name="UpdateMouseCheck" Content="Mouse (NCBI)" IsChecked="True" Margin="0,0,15,5"/>
                                    <CheckBox x:Name="UpdateRatCheck" Content="Rat (NCBI)" IsChecked="True" Margin="0,0,15,5"/>
                                    <CheckBox x:Name="UpdateZebrafishCheck" Content="Zebrafish (NCBI)" Margin="0,0,15,5"/>
                                    <CheckBox x:Name="UpdateFlyCheck" Content="Fly (NCBI)" Margin="0,0,15,5"/>
                                    <CheckBox x:Name="UpdateWormCheck" Content="Worm (NCBI)" Margin="0,0,0,5"/>
                                </WrapPanel>
                                <StackPanel Orientation="Horizontal">
                                    <Button Content="⬇️ Download Selected" Style="{StaticResource ActionButtonStyle}"
                                            Click="UpdateDatabase_Click" Background="#1976D2" Padding="12,6"/>
                                    <TextBlock x:Name="UpdateStatusText" Text="" Foreground="#666" 
                                               VerticalAlignment="Center" Margin="15,0,0,0" FontSize="11"/>
                                </StackPanel>
                            </StackPanel>
                        </Border>
                    </StackPanel>
                </Border>
            </StackPanel>
        </ScrollViewer>
    </Grid>
</Page>


==================================================
FILE_NAME: GeneIdConverterPage.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\GeneIdConverterPage.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using Microsoft.Win32;
using BioSAK.Services;

namespace BioSAK.Pages
{
    public partial class GeneIdConverterPage : Page
    {
        private readonly GeneIdService _geneService;
        private List<GeneConversionResult> _currentResults;

        public GeneIdConverterPage()
        {
            InitializeComponent();
            _geneService = new GeneIdService();

            InputGenesTextBox.TextChanged += (s, e) => UpdateInputCount();
            Loaded += GeneIdConverterPage_Loaded;
        }

        private async void GeneIdConverterPage_Loaded(object sender, RoutedEventArgs e)
        {
            await LoadDatabaseAsync();
        }

        #region Progress

        private void ShowProgress(string title, int value = 0)
        {
            ProgressTitle.Text = title;
            ProgressBar.Value = value;
            ProgressText.Text = $"{value}%";
            ProgressOverlay.Visibility = Visibility.Visible;
        }

        private void UpdateProgress(int value, string message = null)
        {
            ProgressBar.Value = value;
            ProgressText.Text = message ?? $"{value}%";
            Dispatcher.Invoke(() => { }, System.Windows.Threading.DispatcherPriority.Render);
        }

        private void HideProgress()
        {
            ProgressOverlay.Visibility = Visibility.Collapsed;
        }

        #endregion

        #region Database Loading

        private async Task LoadDatabaseAsync()
        {
            try
            {
                ShowProgress("Loading gene database...", 0);

                string species = GetSelectedSpecies();
                UpdateProgress(20, $"Loading {species} data...");

                // 檢查資料庫是否存在
                if (!_geneService.DatabaseExists(species))
                {
                    HideProgress();
                    DatabaseVersionText.Text = $"Database for {species} not found!";
                    LastUpdateText.Text = "Please click 'Download Selected' to get the database.";

                    // 顯示可用的資料庫
                    var available = _geneService.GetAvailableDatabases();
                    if (available.Count > 0)
                    {
                        AvailableDbText.Text = $"Available databases: {string.Join(", ", available)}";
                    }
                    else
                    {
                        AvailableDbText.Text = "No databases found. Please download first.";
                    }
                    return;
                }

                bool loaded = await _geneService.LoadDatabaseAsync(species);

                if (loaded)
                {
                    UpdateProgress(100, "Complete!");
                    var info = _geneService.GetDatabaseInfo();
                    DatabaseVersionText.Text = $"Version: {info.Version} | Genes: {info.GeneCount:N0} | Source: {info.Sources}";
                    LastUpdateText.Text = $"Last update: {info.LastUpdate:yyyy-MM-dd}";

                    var available = _geneService.GetAvailableDatabases();
                    AvailableDbText.Text = $"Available databases: {string.Join(", ", available)}";
                }
                else
                {
                    DatabaseVersionText.Text = "Failed to load database.";
                    LastUpdateText.Text = _geneService.LastError ?? "Unknown error";
                }

                HideProgress();
            }
            catch (Exception ex)
            {
                HideProgress();
                MessageBox.Show($"Error loading database: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async void SpeciesComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!IsLoaded) return;
            await LoadDatabaseAsync();
        }

        private string GetSelectedSpecies()
        {
            if (SpeciesComboBox.SelectedItem is ComboBoxItem item)
                return item.Tag?.ToString() ?? "human";
            return "human";
        }

        #endregion

        #region Input Handling

        private void UpdateInputCount()
        {
            var genes = ParseInputGenes();
            InputCountText.Text = $"{genes.Count} genes";
        }

        private List<string> ParseInputGenes()
        {
            var text = InputGenesTextBox.Text;
            if (string.IsNullOrWhiteSpace(text)) return new List<string>();

            var separators = new[] { '\n', '\r', ',', '\t', ';' };
            return text.Split(separators, StringSplitOptions.RemoveEmptyEntries)
                       .Select(g => g.Trim())
                       .Where(g => !string.IsNullOrEmpty(g))
                       .Distinct()
                       .ToList();
        }

        private void Paste_Click(object sender, RoutedEventArgs e)
        {
            if (Clipboard.ContainsText())
            {
                InputGenesTextBox.Text = Clipboard.GetText();
            }
        }

        private void Clear_Click(object sender, RoutedEventArgs e)
        {
            InputGenesTextBox.Clear();
            ResultsDataGrid.ItemsSource = null;
            _currentResults = null;
            ResultSummaryText.Text = "";
            NotFoundExpander.Visibility = Visibility.Collapsed;
            MultiMatchExpander.Visibility = Visibility.Collapsed;
        }

        private void LoadFile_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new OpenFileDialog
            {
                Filter = "Text files (*.txt;*.csv;*.tsv)|*.txt;*.csv;*.tsv|All files (*.*)|*.*"
            };

            if (dialog.ShowDialog() == true)
            {
                try
                {
                    InputGenesTextBox.Text = File.ReadAllText(dialog.FileName);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error loading file: {ex.Message}", "Error",
                        MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        #endregion

        #region Conversion

        private async void Convert_Click(object sender, RoutedEventArgs e)
        {
            var genes = ParseInputGenes();
            if (genes.Count == 0)
            {
                MessageBox.Show("Please enter gene IDs to convert.", "Input Required",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            if (!_geneService.IsDatabaseLoaded)
            {
                MessageBox.Show("Gene database not loaded. Please wait or click 'Download Selected'.",
                    "Database Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                ShowProgress("Converting gene IDs...", 0);

                bool useAutoDetect = InputTypeAuto.IsChecked == true;
                string fixedInputType = GetInputType();

                var results = new List<GeneConversionResult>();
                var notFound = new List<string>();
                var multiMatch = new List<string>();

                await Task.Run(() =>
                {
                    for (int i = 0; i < genes.Count; i++)
                    {
                        if (i % 100 == 0)
                        {
                            int progress = (i * 100) / genes.Count;
                            Dispatcher.Invoke(() => UpdateProgress(progress, $"Processing {i + 1}/{genes.Count}..."));
                        }

                        var gene = genes[i];

                        // 決定輸入類型
                        string inputType = useAutoDetect ? _geneService.DetectIdType(gene) : fixedInputType;

                        var matches = _geneService.Convert(gene, inputType);

                        if (matches.Count == 0)
                        {
                            notFound.Add(gene);
                            results.Add(new GeneConversionResult
                            {
                                Input = gene,
                                Status = "Not Found"
                            });
                        }
                        else if (matches.Count == 1)
                        {
                            var m = matches[0];
                            results.Add(new GeneConversionResult
                            {
                                Input = gene,
                                Status = "OK",
                                Symbol = m.Symbol,
                                EnsemblId = m.EnsemblId,
                                EntrezId = m.EntrezId,
                                HgncId = m.HgncId,
                                FullName = m.FullName,
                                Biotype = m.Biotype
                            });
                        }
                        else
                        {
                            multiMatch.Add($"{gene} ({matches.Count} matches)");
                            var m = matches[0];
                            results.Add(new GeneConversionResult
                            {
                                Input = gene,
                                Status = $"Multi ({matches.Count})",
                                Symbol = m.Symbol,
                                EnsemblId = m.EnsemblId,
                                EntrezId = m.EntrezId,
                                HgncId = m.HgncId,
                                FullName = m.FullName,
                                Biotype = m.Biotype
                            });

                            for (int j = 1; j < Math.Min(matches.Count, 5); j++)
                            {
                                var mm = matches[j];
                                results.Add(new GeneConversionResult
                                {
                                    Input = $"  └─ {gene}",
                                    Status = $"Alt {j + 1}",
                                    Symbol = mm.Symbol,
                                    EnsemblId = mm.EnsemblId,
                                    EntrezId = mm.EntrezId,
                                    HgncId = mm.HgncId,
                                    FullName = mm.FullName,
                                    Biotype = mm.Biotype
                                });
                            }
                        }
                    }
                });

                UpdateProgress(100, "Complete!");

                _currentResults = results;
                ResultsDataGrid.ItemsSource = results;

                int found = genes.Count - notFound.Count;
                ResultSummaryText.Text = $"Found: {found}/{genes.Count} | Not found: {notFound.Count} | Multiple matches: {multiMatch.Count}";

                if (notFound.Count > 0)
                {
                    NotFoundText.Text = string.Join(", ", notFound.Take(50));
                    if (notFound.Count > 50)
                        NotFoundText.Text += $"... and {notFound.Count - 50} more";
                    NotFoundExpander.Visibility = Visibility.Visible;
                }
                else
                {
                    NotFoundExpander.Visibility = Visibility.Collapsed;
                }

                if (multiMatch.Count > 0)
                {
                    MultiMatchText.Text = string.Join("\n", multiMatch.Take(20));
                    if (multiMatch.Count > 20)
                        MultiMatchText.Text += $"\n... and {multiMatch.Count - 20} more";
                    MultiMatchExpander.Visibility = Visibility.Visible;
                }
                else
                {
                    MultiMatchExpander.Visibility = Visibility.Collapsed;
                }

                HideProgress();
            }
            catch (Exception ex)
            {
                HideProgress();
                MessageBox.Show($"Error: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private string GetInputType()
        {
            if (InputTypeAuto.IsChecked == true) return "auto";
            if (InputTypeSymbol.IsChecked == true) return "symbol";
            if (InputTypeEnsembl.IsChecked == true) return "ensembl";
            if (InputTypeEntrez.IsChecked == true) return "entrez";
            if (InputTypeHGNC.IsChecked == true) return "hgnc";
            return "symbol";
        }

        #endregion

        #region Copy Functions

        private void CopyCell_Click(object sender, RoutedEventArgs e)
        {
            if (ResultsDataGrid.SelectedCells.Count > 0)
            {
                var sb = new StringBuilder();
                var selectedCells = ResultsDataGrid.SelectedCells
                    .OrderBy(c => ResultsDataGrid.Items.IndexOf(c.Item))
                    .ThenBy(c => c.Column.DisplayIndex);

                int lastRowIndex = -1;
                foreach (var cell in selectedCells)
                {
                    int rowIndex = ResultsDataGrid.Items.IndexOf(cell.Item);

                    if (lastRowIndex != -1 && rowIndex != lastRowIndex)
                        sb.AppendLine();
                    else if (lastRowIndex == rowIndex)
                        sb.Append("\t");

                    var item = cell.Item as GeneConversionResult;
                    if (item != null)
                    {
                        string value = GetCellValue(item, cell.Column.Header.ToString());
                        sb.Append(value ?? "");
                    }

                    lastRowIndex = rowIndex;
                }

                if (sb.Length > 0)
                    Clipboard.SetText(sb.ToString());
            }
        }

        private void CopyRow_Click(object sender, RoutedEventArgs e)
        {
            var selectedItems = ResultsDataGrid.SelectedItems.Cast<GeneConversionResult>().ToList();
            if (selectedItems.Count == 0 && ResultsDataGrid.SelectedCells.Count > 0)
            {
                // 從選取的儲存格取得列
                selectedItems = ResultsDataGrid.SelectedCells
                    .Select(c => c.Item as GeneConversionResult)
                    .Where(i => i != null)
                    .Distinct()
                    .ToList();
            }

            if (selectedItems.Count > 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine("Input\tStatus\tSymbol\tEnsembl ID\tEntrez ID\tHGNC ID\tFull Name\tBiotype");

                foreach (var item in selectedItems)
                {
                    sb.AppendLine($"{item.Input}\t{item.Status}\t{item.Symbol}\t{item.EnsemblId}\t{item.EntrezId}\t{item.HgncId}\t{item.FullName}\t{item.Biotype}");
                }

                Clipboard.SetText(sb.ToString());
            }
        }

        private void CopyColumn_Click(object sender, RoutedEventArgs e)
        {
            if (ResultsDataGrid.SelectedCells.Count > 0 && _currentResults != null)
            {
                var columnHeader = ResultsDataGrid.SelectedCells[0].Column.Header.ToString();
                var values = _currentResults
                    .Where(r => !r.Input.StartsWith("  └─"))
                    .Select(r => GetCellValue(r, columnHeader))
                    .Where(v => !string.IsNullOrEmpty(v));

                Clipboard.SetText(string.Join("\n", values));
            }
        }

        private string GetCellValue(GeneConversionResult item, string columnHeader)
        {
            return columnHeader switch
            {
                "Input" => item.Input,
                "Status" => item.Status,
                "Symbol" => item.Symbol,
                "Ensembl ID" => item.EnsemblId,
                "Entrez ID" => item.EntrezId,
                "HGNC ID" => item.HgncId,
                "Full Name" => item.FullName,
                "Biotype" => item.Biotype,
                _ => ""
            };
        }

        #endregion

        #region Export

        private void ExportCsv_Click(object sender, RoutedEventArgs e)
        {
            if (_currentResults == null || _currentResults.Count == 0)
            {
                MessageBox.Show("No results to export.", "Export", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var dialog = new SaveFileDialog
            {
                Filter = "CSV files (*.csv)|*.csv",
                FileName = $"GeneIdConversion_{GetSelectedSpecies()}_{DateTime.Now:yyyyMMdd_HHmmss}.csv"
            };

            if (dialog.ShowDialog() == true)
            {
                var sb = new StringBuilder();
                sb.AppendLine("Input,Status,Symbol,EnsemblId,EntrezId,HgncId,FullName,Biotype");

                foreach (var r in _currentResults.Where(r => !r.Input.StartsWith("  └─")))
                {
                    sb.AppendLine($"\"{EscapeCsv(r.Input)}\",\"{r.Status}\",\"{EscapeCsv(r.Symbol)}\"," +
                        $"\"{EscapeCsv(r.EnsemblId)}\",\"{EscapeCsv(r.EntrezId)}\",\"{EscapeCsv(r.HgncId)}\"," +
                        $"\"{EscapeCsv(r.FullName)}\",\"{EscapeCsv(r.Biotype)}\"");
                }

                File.WriteAllText(dialog.FileName, sb.ToString(), Encoding.UTF8);
                MessageBox.Show($"Exported to:\n{dialog.FileName}", "Export Complete",
                    MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        private string EscapeCsv(string value)
        {
            if (string.IsNullOrEmpty(value)) return "";
            return value.Replace("\"", "\"\"");
        }

        private void CopyAll_Click(object sender, RoutedEventArgs e)
        {
            if (_currentResults == null || _currentResults.Count == 0)
            {
                MessageBox.Show("No results to copy.", "Copy", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var sb = new StringBuilder();
            sb.AppendLine("Input\tStatus\tSymbol\tEnsemblId\tEntrezId\tHgncId\tFullName\tBiotype");

            foreach (var r in _currentResults.Where(r => !r.Input.StartsWith("  └─")))
            {
                sb.AppendLine($"{r.Input}\t{r.Status}\t{r.Symbol}\t{r.EnsemblId}\t{r.EntrezId}\t{r.HgncId}\t{r.FullName}\t{r.Biotype}");
            }

            Clipboard.SetText(sb.ToString());
            MessageBox.Show("Results copied to clipboard (Tab-separated)!", "Copy Complete",
                MessageBoxButton.OK, MessageBoxImage.Information);
        }

        #endregion

        #region Database Update

        private async void UpdateDatabase_Click(object sender, RoutedEventArgs e)
        {
            var selectedSpecies = new List<string>();
            if (UpdateHumanCheck.IsChecked == true) selectedSpecies.Add("human");
            if (UpdateMouseCheck.IsChecked == true) selectedSpecies.Add("mouse");
            if (UpdateRatCheck.IsChecked == true) selectedSpecies.Add("rat");
            if (UpdateZebrafishCheck.IsChecked == true) selectedSpecies.Add("zebrafish");
            if (UpdateFlyCheck.IsChecked == true) selectedSpecies.Add("fly");
            if (UpdateWormCheck.IsChecked == true) selectedSpecies.Add("worm");

            if (selectedSpecies.Count == 0)
            {
                MessageBox.Show("Please select at least one species to download.", "Selection Required",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var speciesNames = string.Join(", ", selectedSpecies.Select(s => char.ToUpper(s[0]) + s.Substring(1)));
            var result = MessageBox.Show(
                $"Download gene databases for:\n{speciesNames}\n\nThis may take 2-10 minutes depending on your internet connection.\n\nContinue?",
                "Download Databases", MessageBoxButton.YesNo, MessageBoxImage.Question);

            if (result != MessageBoxResult.Yes) return;

            try
            {
                int totalSpecies = selectedSpecies.Count;
                int completed = 0;
                var failed = new List<string>();

                foreach (var species in selectedSpecies)
                {
                    ShowProgress($"Downloading {species}...", 0);
                    UpdateStatusText.Text = $"Downloading {completed + 1}/{totalSpecies}: {species}";

                    bool success = await _geneService.DownloadDatabaseAsync(species, (progress, message) =>
                    {
                        Dispatcher.Invoke(() =>
                        {
                            UpdateProgress(progress, message);
                        });
                    });

                    if (!success)
                    {
                        failed.Add(species);
                    }

                    completed++;
                }

                HideProgress();

                await LoadDatabaseAsync();

                if (failed.Count == 0)
                {
                    UpdateStatusText.Text = $"✓ Downloaded {completed} database(s) successfully";
                    MessageBox.Show($"Successfully downloaded {completed} gene database(s)!",
                        "Download Complete", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                else
                {
                    UpdateStatusText.Text = $"⚠ {failed.Count} download(s) failed";
                    MessageBox.Show($"Downloaded {completed - failed.Count}/{completed} databases.\n\nFailed: {string.Join(", ", failed)}",
                        "Download Partial", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            catch (Exception ex)
            {
                HideProgress();
                UpdateStatusText.Text = "✗ Download failed";
                MessageBox.Show($"Error downloading databases:\n{ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #endregion
    }

    #region Result Model

    public class GeneConversionResult
    {
        public string Input { get; set; }
        public string Status { get; set; }
        public string Symbol { get; set; }
        public string EnsemblId { get; set; }
        public string EntrezId { get; set; }
        public string HgncId { get; set; }
        public string FullName { get; set; }
        public string Biotype { get; set; }
    }

    #endregion
}


==================================================
FILE_NAME: MWCal.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\MWCal.xaml
==================================================
<Page x:Class="BioSAK.MWCal"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      xmlns:local="clr-namespace:BioSAK"
      mc:Ignorable="d" 
      d:DesignHeight="400" d:DesignWidth="500" 
      Background="WhiteSmoke"
      Title="Concentration Calculator">

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="120"/>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="90"/>
        </Grid.ColumnDefinitions>

        <!-- Title -->
        <TextBlock Grid.Row="0" Grid.ColumnSpan="3" Text= "Concentration Calculator" 
                   FontSize="18" FontWeight="Bold" HorizontalAlignment="Center" Margin="0,0,0,20"/>

        <!-- M.W. -->
        <TextBlock Grid.Row="1" Grid.Column="0" Text="M.W. (g/mol):" VerticalAlignment="Center" Margin="0,0,10,10"/>
        <TextBox x:Name="txtMW" Grid.Row="1" Grid.Column="1" Grid.ColumnSpan="2" 
                 Height="28" Margin="0,0,0,10" VerticalContentAlignment="Center"
                 PreviewTextInput="NumericOnly_PreviewTextInput"/>

        <!-- Volume -->
        <TextBlock Grid.Row="2" Grid.Column="0" Text="Volume:" VerticalAlignment="Center" Margin="0,0,10,10"/>
        <TextBox x:Name="txtVolume" Grid.Row="2" Grid.Column="1" 
                 Height="28" Margin="0,0,10,10" VerticalContentAlignment="Center"
                 PreviewTextInput="NumericOnly_PreviewTextInput"/>
        <ComboBox x:Name="cboVolumeUnit" Grid.Row="2" Grid.Column="2" 
                  Height="28" Margin="0,0,0,10" SelectedIndex="2">
            <ComboBoxItem Content="L"/>
            <ComboBoxItem Content="mL"/>
            <ComboBoxItem Content="μL"/>
            <ComboBoxItem Content="nL"/>
        </ComboBox>

        <!-- Mass -->
        <TextBlock Grid.Row="3" Grid.Column="0" Text="Mass:" VerticalAlignment="Center" Margin="0,0,10,10"/>
        <TextBox x:Name="txtMass" Grid.Row="3" Grid.Column="1" 
                 Height="28" Margin="0,0,10,10" VerticalContentAlignment="Center"
                 PreviewTextInput="NumericOnly_PreviewTextInput"/>
        <ComboBox x:Name="cboMassUnit" Grid.Row="3" Grid.Column="2" 
                  Height="28" Margin="0,0,0,10" SelectedIndex="1">
            <ComboBoxItem Content="g"/>
            <ComboBoxItem Content="mg"/>
            <ComboBoxItem Content="μg"/>
            <ComboBoxItem Content="ng"/>
            <ComboBoxItem Content="pg"/>
        </ComboBox>

        <!-- Concentration -->
        <TextBlock Grid.Row="4" Grid.Column="0" Text="Concentration:" VerticalAlignment="Center" Margin="0,0,10,10"/>
        <TextBox x:Name="txtConcentration" Grid.Row="4" Grid.Column="1" 
                 Height="28" Margin="0,0,10,10" VerticalContentAlignment="Center"
                 PreviewTextInput="NumericOnly_PreviewTextInput"/>
        <ComboBox x:Name="cboConcUnit" Grid.Row="4" Grid.Column="2" 
                  Height="28" Margin="0,0,0,10" SelectedIndex="1">
            <ComboBoxItem Content="M"/>
            <ComboBoxItem Content="mM"/>
            <ComboBoxItem Content="μM"/>
            <ComboBoxItem Content="nM"/>
            <ComboBoxItem Content="w/v%"/>
        </ComboBox>

        <!-- Buttons -->
        <StackPanel Grid.Row="5" Grid.ColumnSpan="3" Orientation="Horizontal" 
                    HorizontalAlignment="Center" Margin="0,15,0,15">
            <Button x:Name="btnCalculate" Content="Calculate" Width="100" Height="32" 
                    Click="BtnCalculate_Click" Margin="0,0,15,0" FontSize="14"/>
            <Button x:Name="btnClear" Content="Clear" Width="100" Height="32" 
                    Click="BtnClear_Click" FontSize="14"/>
        </StackPanel>

        <!-- Result/Status -->
        <Border x:Name="ResultBorder" Grid.Row="6" Grid.ColumnSpan="3" Background="#E8F5E9" BorderBrush="#4CAF50" 
                BorderThickness="1" CornerRadius="5" Padding="10" Margin="0,5,0,0">
            <TextBlock x:Name="txtResult" Text="Enter values and click Calculate" 
                       TextWrapping="Wrap" Foreground="#2E7D32" FontSize="13"/>
        </Border>
    </Grid>
</Page>


==================================================
FILE_NAME: MWCal.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\MWCal.xaml.cs
==================================================
using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

namespace BioSAK
{
    public partial class MWCal : Page
    {
        public MWCal()
        {
            InitializeComponent();
        }

        private void NumericOnly_PreviewTextInput(object sender, TextCompositionEventArgs e)
        {
            // Allow digits, decimal point, and scientific notation
            foreach (char c in e.Text)
            {
                if (!char.IsDigit(c) && c != '.' && c != 'e' && c != 'E' && c != '-' && c != '+')
                {
                    e.Handled = true;
                    return;
                }
            }
        }

        private void BtnCalculate_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                // Parse values (empty string = null)
                double? mw = ParseDouble(txtMW.Text);
                double? volume = ParseDouble(txtVolume.Text);
                double? mass = ParseDouble(txtMass.Text);
                double? concentration = ParseDouble(txtConcentration.Text);

                // Get units
                string volumeUnit = ((ComboBoxItem)cboVolumeUnit.SelectedItem).Content.ToString()!;
                string massUnit = ((ComboBoxItem)cboMassUnit.SelectedItem).Content.ToString()!;
                string concUnit = ((ComboBoxItem)cboConcUnit.SelectedItem).Content.ToString()!;

                // Count empty fields
                int emptyCount = 0;
                string emptyField = "";

                if (!mw.HasValue) { emptyCount++; emptyField = "M.W."; }
                if (!volume.HasValue) { emptyCount++; emptyField = "Volume"; }
                if (!mass.HasValue) { emptyCount++; emptyField = "Mass"; }
                if (!concentration.HasValue) { emptyCount++; emptyField = "Concentration"; }

                if (emptyCount == 0)
                {
                    // All fields filled - calculate and display concentration
                    double result = CalculateConcentration(mw!.Value, volume!.Value, volumeUnit, mass!.Value, massUnit, concUnit);
                    txtConcentration.Text = FormatResult(result);
                    txtResult.Text = $"Concentration = {FormatResult(result)} {concUnit}";
                    SetResultStyle(true);
                }
                else if (emptyCount == 1)
                {
                    // One field empty - calculate it
                    double result = 0;
                    string resultUnit = "";

                    if (!mw.HasValue)
                    {
                        // Calculate M.W. - only possible for molar concentrations
                        if (concUnit == "w/v%")
                        {
                            txtResult.Text = "Cannot calculate M.W. from w/v% concentration";
                            SetResultStyle(false);
                            return;
                        }
                        result = CalculateMW(volume!.Value, volumeUnit, mass!.Value, massUnit, concentration!.Value, concUnit);
                        txtMW.Text = FormatResult(result);
                        resultUnit = "g/mol";
                        emptyField = "M.W.";
                    }
                    else if (!volume.HasValue)
                    {
                        result = CalculateVolume(mw!.Value, mass!.Value, massUnit, concentration!.Value, concUnit);
                        // Convert result (in base unit) to selected unit
                        double displayResult = ConvertVolumeFromBase(result, volumeUnit);
                        txtVolume.Text = FormatResult(displayResult);
                        result = displayResult;
                        resultUnit = volumeUnit;
                        emptyField = "Volume";
                    }
                    else if (!mass.HasValue)
                    {
                        result = CalculateMass(mw!.Value, volume!.Value, volumeUnit, concentration!.Value, concUnit);
                        // Convert result (in base unit) to selected unit
                        double displayResult = ConvertMassFromBase(result, massUnit);
                        txtMass.Text = FormatResult(displayResult);
                        result = displayResult;
                        resultUnit = massUnit;
                        emptyField = "Mass";
                    }
                    else if (!concentration.HasValue)
                    {
                        result = CalculateConcentration(mw!.Value, volume!.Value, volumeUnit, mass!.Value, massUnit, concUnit);
                        txtConcentration.Text = FormatResult(result);
                        resultUnit = concUnit;
                        emptyField = "Concentration";
                    }

                    txtResult.Text = $"{emptyField} = {FormatResult(result)} {resultUnit}";
                    SetResultStyle(true);
                }
                else
                {
                    txtResult.Text = $"Please fill in at least 3 fields (currently {4 - emptyCount} filled)";
                    SetResultStyle(false);
                }
            }
            catch (Exception ex)
            {
                txtResult.Text = $"Error: {ex.Message}";
                SetResultStyle(false);
            }
        }

        private double? ParseDouble(string text)
        {
            if (string.IsNullOrWhiteSpace(text))
                return null;
            if (double.TryParse(text, out double result))
                return result;
            return null;
        }

        private string FormatResult(double value)
        {
            if (Math.Abs(value) < 0.001 || Math.Abs(value) >= 1000000)
                return value.ToString("E4");
            else if (Math.Abs(value) < 1)
                return value.ToString("F6").TrimEnd('0').TrimEnd('.');
            else
                return value.ToString("F4").TrimEnd('0').TrimEnd('.');
        }

        #region Unit Conversions

        // Convert volume to nL
        private double ConvertVolumeToNL(double value, string unit)
        {
            return unit switch
            {
                "L" => value * 1e9,
                "mL" => value * 1e6,
                "μL" => value * 1e3,
                "nL" => value,
                _ => value
            };
        }

        // Convert volume to L (base unit for calculations)
        private double ConvertVolumeToL(double value, string unit)
        {
            return unit switch
            {
                "L" => value,
                "mL" => value * 1e-3,
                "μL" => value * 1e-6,
                "nL" => value * 1e-9,
                _ => value
            };
        }

        // Convert from L to target unit
        private double ConvertVolumeFromBase(double valueInL, string targetUnit)
        {
            return targetUnit switch
            {
                "L" => valueInL,
                "mL" => valueInL * 1e3,
                "μL" => valueInL * 1e6,
                "nL" => valueInL * 1e9,
                _ => valueInL
            };
        }

        // Convert mass to pg
        private double ConvertMassToPg(double value, string unit)
        {
            return unit switch
            {
                "g" => value * 1e12,
                "mg" => value * 1e9,
                "μg" => value * 1e6,
                "ng" => value * 1e3,
                "pg" => value,
                _ => value
            };
        }

        // Convert mass to g (base unit for calculations)
        private double ConvertMassToG(double value, string unit)
        {
            return unit switch
            {
                "g" => value,
                "mg" => value * 1e-3,
                "μg" => value * 1e-6,
                "ng" => value * 1e-9,
                "pg" => value * 1e-12,
                _ => value
            };
        }

        // Convert from g to target unit
        private double ConvertMassFromBase(double valueInG, string targetUnit)
        {
            return targetUnit switch
            {
                "g" => valueInG,
                "mg" => valueInG * 1e3,
                "μg" => valueInG * 1e6,
                "ng" => valueInG * 1e9,
                "pg" => valueInG * 1e12,
                _ => valueInG
            };
        }

        // Convert concentration from mM to target unit
        private double ConvertConcentrationFromMM(double mM, string targetUnit)
        {
            return targetUnit switch
            {
                "M" => mM / 1000,
                "mM" => mM,
                "μM" => mM * 1000,
                "nM" => mM * 1e6,
                _ => mM
            };
        }

        // Convert concentration to M (base unit)
        private double ConvertConcentrationToM(double value, string unit)
        {
            return unit switch
            {
                "M" => value,
                "mM" => value * 1e-3,
                "μM" => value * 1e-6,
                "nM" => value * 1e-9,
                _ => value
            };
        }

        #endregion

        #region Calculation Methods

        /// <summary>
        /// Calculate concentration given M.W., volume, and mass
        /// </summary>
        private double CalculateConcentration(double mw, double volume, string volumeUnit,
            double mass, string massUnit, string concUnit)
        {
            if (concUnit == "w/v%")
            {
                // w/v% = (mass in g / volume in mL) * 100
                double massG = ConvertMassToG(mass, massUnit);
                double volumeML = ConvertVolumeToL(volume, volumeUnit) * 1000; // L to mL
                return (massG / volumeML) * 100;
            }
            else
            {
                // Molar concentration
                // Convert to pg and nL, then calculate mM
                double massPg = ConvertMassToPg(mass, massUnit);
                double volumeNL = ConvertVolumeToNL(volume, volumeUnit);

                // pg / (g/mol) / nL = pmol / nL = mM
                double mM = massPg / mw / volumeNL;

                return ConvertConcentrationFromMM(mM, concUnit);
            }
        }

        /// <summary>
        /// Calculate mass given M.W., volume, and concentration
        /// Returns mass in grams (base unit)
        /// </summary>
        private double CalculateMass(double mw, double volume, string volumeUnit,
            double concentration, string concUnit)
        {
            if (concUnit == "w/v%")
            {
                // mass (g) = w/v% * volume (mL) / 100
                double volumeML = ConvertVolumeToL(volume, volumeUnit) * 1000;
                return concentration * volumeML / 100;
            }
            else
            {
                // mass = concentration (M) * M.W. (g/mol) * volume (L)
                double concM = ConvertConcentrationToM(concentration, concUnit);
                double volumeL = ConvertVolumeToL(volume, volumeUnit);
                return concM * mw * volumeL;
            }
        }

        /// <summary>
        /// Calculate volume given M.W., mass, and concentration
        /// Returns volume in L (base unit)
        /// </summary>
        private double CalculateVolume(double mw, double mass, string massUnit,
            double concentration, string concUnit)
        {
            if (concUnit == "w/v%")
            {
                // volume (mL) = mass (g) * 100 / w/v%
                double massG = ConvertMassToG(mass, massUnit);
                double volumeML = massG * 100 / concentration;
                return volumeML / 1000; // Convert to L
            }
            else
            {
                // volume (L) = mass (g) / (concentration (M) * M.W. (g/mol))
                double massG = ConvertMassToG(mass, massUnit);
                double concM = ConvertConcentrationToM(concentration, concUnit);
                return massG / (concM * mw);
            }
        }

        /// <summary>
        /// Calculate M.W. given volume, mass, and concentration
        /// Only valid for molar concentrations
        /// </summary>
        private double CalculateMW(double volume, string volumeUnit, double mass, string massUnit,
            double concentration, string concUnit)
        {
            // M.W. = mass (g) / (concentration (M) * volume (L))
            double massG = ConvertMassToG(mass, massUnit);
            double concM = ConvertConcentrationToM(concentration, concUnit);
            double volumeL = ConvertVolumeToL(volume, volumeUnit);
            return massG / (concM * volumeL);
        }

        #endregion

        private void SetResultStyle(bool success)
        {
            if (success)
            {
                // 直接使用變數名稱 ResultBorder，而不是用 txtResult.Parent 去抓
                ResultBorder.Background = new System.Windows.Media.SolidColorBrush(
                    System.Windows.Media.Color.FromRgb(232, 245, 233)); // #E8F5E9
                ResultBorder.BorderBrush = new System.Windows.Media.SolidColorBrush(
                    System.Windows.Media.Color.FromRgb(76, 175, 80)); // #4CAF50
                txtResult.Foreground = new System.Windows.Media.SolidColorBrush(
                    System.Windows.Media.Color.FromRgb(46, 125, 50)); // #2E7D32
            }
            else
            {
                ResultBorder.Background = new System.Windows.Media.SolidColorBrush(
                    System.Windows.Media.Color.FromRgb(255, 235, 238)); // #FFEBEE
                ResultBorder.BorderBrush = new System.Windows.Media.SolidColorBrush(
                    System.Windows.Media.Color.FromRgb(244, 67, 54)); // #F44336
                txtResult.Foreground = new System.Windows.Media.SolidColorBrush(
                    System.Windows.Media.Color.FromRgb(198, 40, 40)); // #C62828
            }
        }

        private void BtnClear_Click(object sender, RoutedEventArgs e)
        {
            txtMW.Text = "";
            txtVolume.Text = "";
            txtMass.Text = "";
            txtConcentration.Text = "";
            txtResult.Text = "Enter values and click Calculate";
            SetResultStyle(true);
        }
    }
}


==================================================
FILE_NAME: NucleotideComplementary.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\NucleotideComplementary.xaml
==================================================
<Page x:Class="BioSAK.NucleotideComplementary"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      xmlns:local="clr-namespace:BioSAK"
      mc:Ignorable="d" 
      d:DesignHeight="600" d:DesignWidth="800"
      Background="White"
      Title="NucleotideComplementary">

    <Grid Margin="20">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="20"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <Grid Grid.Column="0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>

            <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,10">
                <TextBlock Text="Mode:" VerticalAlignment="Center" Margin="0,0,10,0" FontWeight="Bold"/>
                <RadioButton x:Name="RadioDNA" Content="DNA" IsChecked="True" GroupName="Mode" Margin="0,0,15,0" Click="DNA_Click"/>
                <RadioButton x:Name="RadioRNA" Content="RNA" GroupName="Mode" Click="RNA_Click"/>
            </StackPanel>

            <Grid Grid.Row="1">
                <TextBox x:Name="Input" 
                         TextWrapping="Wrap" 
                         AcceptsReturn="True"
                         VerticalScrollBarVisibility="Auto"
                         Padding="5"
                         FontSize="14"
                         PreviewTextInput="Input_PreviewTextInput" 
                         TextChanged="Input_TextChanged" 
                         BorderBrush="#CCCCCC"/>

                <TextBlock x:Name="Hint" 
                           Text="Input sequence here..." 
                           Foreground="Gray" 
                           Margin="8,8,0,0"
                           IsHitTestVisible="False"/>
            </Grid>
        </Grid>

        <ScrollViewer Grid.Column="2" VerticalScrollBarVisibility="Auto">
            <StackPanel>
                <TextBlock Text="Reverse" FontWeight="SemiBold" Margin="0,0,0,5"/>
                <TextBox x:Name="Reverse" Height="100" TextWrapping="Wrap" IsReadOnly="True" Background="#F9F9F9" Margin="0,0,0,20" Padding="5"/>

                <TextBlock Text="Complement" FontWeight="SemiBold" Margin="0,0,0,5"/>
                <TextBox x:Name="Complement" Height="100" TextWrapping="Wrap" IsReadOnly="True" Background="#F9F9F9" Margin="0,0,0,20" Padding="5"/>

                <TextBlock Text="Reverse Complement" FontWeight="SemiBold" Margin="0,0,0,5"/>
                <TextBox x:Name="ReverseComplement" Height="100" TextWrapping="Wrap" IsReadOnly="True" Background="#F9F9F9" Padding="5"/>
            </StackPanel>
        </ScrollViewer>
    </Grid>
</Page>

==================================================
FILE_NAME: NucleotideComplementary.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\NucleotideComplementary.xaml.cs
==================================================
using System;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

namespace BioSAK
{
    public partial class NucleotideComplementary : Page
    {
        private bool isDNA = true; // 追蹤目前模式

        public NucleotideComplementary()
        {
            InitializeComponent();
        }

        // 當點擊 DNA RadioButton
        private void DNA_Click(object sender, RoutedEventArgs e)
        {
            isDNA = true;
            UpdateCalculation(); // 切換模式時立即重新計算
        }

        // 當點擊 RNA RadioButton
        private void RNA_Click(object sender, RoutedEventArgs e)
        {
            isDNA = false;
            UpdateCalculation(); // 切換模式時立即重新計算
        }

        private void Input_PreviewTextInput(object sender, TextCompositionEventArgs e)
        {
            // 驗證輸入：允許 DNA(ATGCN) 或 RNA(AUCGN)
            
            string allowed = "ATGCNUatgcnu";

            // 如果要嚴格限制當下模式：
            // string allowed = isDNA ? "ATGCNatgcn" : "AUCGNaucgn";

            foreach (char c in e.Text)
            {
                if (!allowed.Contains(c))
                {
                    e.Handled = true; // 阻止輸入
                    return;
                }
            }
        }

        private void Input_TextChanged(object sender, TextChangedEventArgs e)
        {
            // 控制提示文字顯示
            Hint.Visibility = string.IsNullOrEmpty(Input.Text) ? Visibility.Visible : Visibility.Hidden;

            // 執行計算
            UpdateCalculation();
        }

        // 將計算邏輯獨立出來，方便重複呼叫
        private void UpdateCalculation()
        {
            if (Input == null) return; // 避免初始化時報錯

            string inputSeq = Input.Text.ToUpper().Trim();

            // 如果沒輸入，清空結果
            if (string.IsNullOrEmpty(inputSeq))
            {
                Reverse.Text = "";
                Complement.Text = "";
                ReverseComplement.Text = "";
                return;
            }

            // 1. Reverse
            Reverse.Text = GetReverse(inputSeq);

            // 2. Complement & Reverse Complement
            if (isDNA)
            {
                Complement.Text = GetComplement(inputSeq);
                ReverseComplement.Text = GetReverseComplement(inputSeq);
            }
            else
            {
                Complement.Text = GetRNAComplement(inputSeq);
                ReverseComplement.Text = GetRNAReverseComplement(inputSeq);
            }
        }


        private static string GetReverse(string input)
        {
            char[] reversed = input.ToCharArray();
            Array.Reverse(reversed);
            return new string(reversed);
        }

        private static string GetComplement(string input)
        {
            StringBuilder complement = new StringBuilder();
            foreach (char baseChar in input)
            {
                switch (baseChar)
                {
                    case 'A': complement.Append('T'); break;
                    case 'T': complement.Append('A'); break;
                    case 'C': complement.Append('G'); break;
                    case 'G': complement.Append('C'); break;
                    case 'N': complement.Append('N'); break;
                    case 'U': complement.Append('A'); break; // 容錯處理
                    default: complement.Append('?'); break;
                }
            }
            return complement.ToString();
        }

        private static string GetRNAComplement(string input)
        {
            StringBuilder complement = new StringBuilder();
            foreach (char baseChar in input)
            {
                switch (baseChar)
                {
                    case 'A': complement.Append('U'); break;
                    case 'U': complement.Append('A'); break;
                    case 'C': complement.Append('G'); break;
                    case 'G': complement.Append('C'); break;
                    case 'N': complement.Append('N'); break;
                    case 'T': complement.Append('A'); break; // 容錯處理
                    default: complement.Append('?'); break;
                }
            }
            return complement.ToString();
        }

        private static string GetReverseComplement(string input)
        {
            // 先反轉
            char[] arr = input.ToCharArray();
            Array.Reverse(arr);
            string reversed = new string(arr);

            // 再取互補 (直接呼叫上面的 GetComplement 邏輯，避免重複 switch case)
            // 但因為您原本的方法是寫在一個大方法裡，維持您的寫法也可以：
            StringBuilder sb = new StringBuilder();
            foreach (char c in reversed)
            {
                switch (c)
                {
                    case 'A': sb.Append('T'); break;
                    case 'T': sb.Append('A'); break;
                    case 'C': sb.Append('G'); break;
                    case 'G': sb.Append('C'); break;
                    case 'N': sb.Append('N'); break;
                    default: sb.Append('?'); break;
                }
            }
            return sb.ToString();
        }

        private static string GetRNAReverseComplement(string input)
        {
            char[] arr = input.ToCharArray();
            Array.Reverse(arr);
            string reversed = new string(arr);

            StringBuilder sb = new StringBuilder();
            foreach (char c in reversed)
            {
                switch (c)
                {
                    case 'A': sb.Append('U'); break;
                    case 'U': sb.Append('A'); break;
                    case 'C': sb.Append('G'); break;
                    case 'G': sb.Append('C'); break;
                    case 'N': sb.Append('N'); break;
                    default: sb.Append('?'); break;
                }
            }
            return sb.ToString();
        }
    }
}

==================================================
FILE_NAME: Page1.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\Page1.xaml
==================================================
<Page x:Class="BioSAK.Page1"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      xmlns:local="clr-namespace:BioSAK"
      mc:Ignorable="d" 
      d:DesignHeight="450" d:DesignWidth="800"
      Title="Page1">

    <Grid>
        <TextBlock HorizontalAlignment="Left" Margin="300,0,0,0" TextWrapping="Wrap" VerticalAlignment="Center" Height="96" Width="409" FontSize="48"><Run FontStyle="Italic" Text="Coming soon!"/></TextBlock>

    </Grid>
</Page>


==================================================
FILE_NAME: Page1.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\Page1.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace BioSAK
{
    /// <summary>
    /// Page1.xaml 的互動邏輯
    /// </summary>
    public partial class Page1 : Page
    {
        public Page1()
        {
            InitializeComponent();
        }
    }
}


==================================================
FILE_NAME: PrimerDesignerPage.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\PrimerDesignerPage.xaml
==================================================
<Page x:Class="BioSAK.Pages.PrimerDesignerPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      mc:Ignorable="d" d:DesignHeight="800" d:DesignWidth="1100"
      Title="Primer Designer" Background="#F5F5F5">

    <Page.Resources>
        <Style x:Key="PrimaryButtonStyle" TargetType="Button">
            <Setter Property="Background" Value="#2196F3"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="16,10"/>
            <Setter Property="FontSize" Value="13"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" CornerRadius="5" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#1976D2"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        <Style x:Key="SecondaryButtonStyle" TargetType="Button">
            <Setter Property="Background" Value="#4CAF50"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="15,8"/>
            <Setter Property="FontSize" Value="12"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" CornerRadius="4" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#388E3C"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        <Style x:Key="SmallButtonStyle" TargetType="Button">
            <Setter Property="Background" Value="#FF9800"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="10,5"/>
            <Setter Property="FontSize" Value="11"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" CornerRadius="3" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#F57C00"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        <Style x:Key="DangerButtonStyle" TargetType="Button">
            <Setter Property="Background" Value="#F44336"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="12,6"/>
            <Setter Property="FontSize" Value="12"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" CornerRadius="4" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#D32F2F"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        <Style x:Key="TealButtonStyle" TargetType="Button">
            <Setter Property="Background" Value="#009688"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="14,8"/>
            <Setter Property="FontSize" Value="12"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" CornerRadius="4" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#00796B"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        <Style x:Key="CardStyle" TargetType="Border">
            <Setter Property="Background" Value="White"/>
            <Setter Property="CornerRadius" Value="8"/>
            <Setter Property="Padding" Value="15"/>
            <Setter Property="Margin" Value="0,0,0,10"/>
            <Setter Property="Effect">
                <Setter.Value>
                    <DropShadowEffect BlurRadius="6" ShadowDepth="1" Opacity="0.15"/>
                </Setter.Value>
            </Setter>
        </Style>
        <Style x:Key="SectionTitleStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Foreground" Value="#333"/>
            <Setter Property="Margin" Value="0,0,0,10"/>
        </Style>
        <Style x:Key="LabelStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="12"/>
            <Setter Property="Foreground" Value="#555"/>
            <Setter Property="Margin" Value="0,0,0,4"/>
        </Style>
        <Style x:Key="InputStyle" TargetType="TextBox">
            <Setter Property="Padding" Value="10,8"/>
            <Setter Property="FontSize" Value="13"/>
            <Setter Property="BorderBrush" Value="#DDD"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="Background" Value="White"/>
        </Style>
        <Style x:Key="ComboStyle" TargetType="ComboBox">
            <Setter Property="Padding" Value="10,8"/>
            <Setter Property="FontSize" Value="13"/>
            <Setter Property="BorderBrush" Value="#DDD"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="Background" Value="White"/>
        </Style>
        <Style x:Key="SeqBoxStyle" TargetType="TextBox">
            <Setter Property="FontFamily" Value="Consolas"/>
            <Setter Property="FontSize" Value="13"/>
            <Setter Property="Padding" Value="8"/>
            <Setter Property="BorderBrush" Value="#CCC"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="AcceptsReturn" Value="True"/>
            <Setter Property="TextWrapping" Value="Wrap"/>
            <Setter Property="VerticalScrollBarVisibility" Value="Auto"/>
        </Style>
    </Page.Resources>

    <ScrollViewer x:Name="PageScrollViewer" VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled" PreviewMouseWheel="PageScrollViewer_PreviewMouseWheel">
        <Grid Margin="10" MinHeight="750">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*" MinHeight="450"/>
            </Grid.RowDefinitions>

            <!-- ==================== ROW 0: Collapsible Input ==================== -->
            <Border Grid.Row="0" Background="White" CornerRadius="8" BorderBrush="#E0E0E0" BorderThickness="1" Margin="0,0,0,8">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>
                    <Border Grid.Row="0" Background="#FAFAFA" CornerRadius="8,8,0,0" Padding="12,10" MouseLeftButtonDown="InputHeader_Click" Cursor="Hand">
                        <Grid>
                            <StackPanel Orientation="Horizontal">
                                <TextBlock x:Name="CollapseArrow" Text="▼" FontSize="12" Foreground="#666" VerticalAlignment="Center" Margin="0,0,8,0"/>
                                <TextBlock Text="🧬 Primer Designer" FontSize="16" FontWeight="Bold" Foreground="#333" VerticalAlignment="Center"/>
                                <TextBlock x:Name="InputSectionSummary" Text="" FontSize="12" Foreground="#4CAF50" VerticalAlignment="Center" Margin="15,0,0,0" FontWeight="SemiBold"/>
                            </StackPanel>
                            <TextBlock Text="Click to expand/collapse" FontSize="10" Foreground="#999" HorizontalAlignment="Right" VerticalAlignment="Center"/>
                        </Grid>
                    </Border>
                    <Border x:Name="InputContentPanel" Grid.Row="1" Padding="15" BorderBrush="#EEE" BorderThickness="0,1,0,0">
                        <Grid>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="25"/>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="25"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>

                            <!-- ★ Col 0: Direct Sequence Input (DEFAULT) -->
                            <StackPanel Grid.Column="0">
                                <TextBlock Text="📝 Direct Sequence Input" FontSize="14" FontWeight="SemiBold" Foreground="#333" Margin="0,0,0,10"/>
                                <Grid>
                                    <TextBox x:Name="DirectSequenceInput" Style="{StaticResource SeqBoxStyle}" Height="155" TextChanged="DirectSequenceInput_TextChanged"/>
                                    <TextBlock x:Name="DirectSeqHint" Text="Paste DNA template sequence (ATGC)..." Foreground="#AAA" FontSize="12" Margin="10,10,0,0" IsHitTestVisible="False"/>
                                </Grid>
                                <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                                    <TextBlock x:Name="DirectSeqLengthLabel" Text="Length: 0 bp" FontSize="11" Foreground="#888" VerticalAlignment="Center"/>
                                    <Button Content="Use This Sequence" Style="{StaticResource TealButtonStyle}" Margin="15,0,0,0" Click="UseDirectSequence_Click"/>
                                </StackPanel>
                            </StackPanel>

                            <Rectangle Grid.Column="1" Width="1" Fill="#E0E0E0" Margin="12,0"/>

                            <!-- Col 2: Search Gene from NCBI -->
                            <StackPanel Grid.Column="2">
                                <TextBlock Text="🔍 Search Gene from NCBI" FontSize="14" FontWeight="SemiBold" Foreground="#333" Margin="0,0,0,10"/>
                                <TextBlock Text="Gene Symbol / Alias" Style="{StaticResource LabelStyle}"/>
                                <TextBox x:Name="GeneSymbolTextBox" Style="{StaticResource InputStyle}" Text="TP53"/>
                                <Grid Margin="0,8,0,0">
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="8"/>
                                        <ColumnDefinition Width="*"/>
                                    </Grid.ColumnDefinitions>
                                    <StackPanel Grid.Column="0">
                                        <TextBlock Text="Species" Style="{StaticResource LabelStyle}"/>
                                        <ComboBox x:Name="SpeciesComboBox" Style="{StaticResource ComboStyle}">
                                            <ComboBoxItem Content="Homo sapiens" IsSelected="True" Tag="9606"/>
                                            <ComboBoxItem Content="Mus musculus" Tag="10090"/>
                                            <ComboBoxItem Content="Rattus norvegicus" Tag="10116"/>
                                        </ComboBox>
                                    </StackPanel>
                                    <StackPanel Grid.Column="2">
                                        <TextBlock Text="Sequence Type" Style="{StaticResource LabelStyle}"/>
                                        <ComboBox x:Name="SeqTypeComboBox" Style="{StaticResource ComboStyle}">
                                            <ComboBoxItem Content="mRNA (NM_)" IsSelected="True" Tag="mRNA"/>
                                            <ComboBoxItem Content="Genomic (NG_)" Tag="Genomic"/>
                                        </ComboBox>
                                    </StackPanel>
                                </Grid>
                                <TextBlock Text="── OR enter accession ──" HorizontalAlignment="Center" Foreground="#CCC" FontSize="10" Margin="0,8"/>
                                <TextBlock Text="Accession (NM_ / NG_ / NR_)" Style="{StaticResource LabelStyle}"/>
                                <TextBox x:Name="AccessionTextBox" Style="{StaticResource InputStyle}"/>
                                <Button x:Name="FetchGeneButton" Content="🔍 Fetch Gene" Style="{StaticResource PrimaryButtonStyle}" Margin="0,10,0,0" Click="FetchGeneButton_Click"/>
                            </StackPanel>

                            <Rectangle Grid.Column="3" Width="1" Fill="#E0E0E0" Margin="12,0"/>

                            <!-- Col 4: Isoform Selection (HIDDEN initially) -->
                            <StackPanel x:Name="IsoformPanel" Grid.Column="4" Visibility="Collapsed">
                                <TextBlock Text="📋 Transcript Isoforms" FontSize="14" FontWeight="SemiBold" Foreground="#333" Margin="0,0,0,10"/>
                                <ListBox x:Name="IsoformListBox" MaxHeight="180" BorderBrush="#DDD" BorderThickness="1" SelectionChanged="IsoformListBox_SelectionChanged">
                                    <ListBox.ItemTemplate>
                                        <DataTemplate>
                                            <StackPanel Orientation="Horizontal" ToolTip="{Binding Description}">
                                                <TextBlock Text="{Binding IsoformLabel}" FontWeight="SemiBold" Width="90" FontSize="12" Foreground="#7B1FA2"/>
                                                <TextBlock Text="{Binding Accession}" FontSize="11" Width="105" Foreground="#333" FontFamily="Consolas"/>
                                                <TextBlock Text="{Binding LengthDisplay}" Foreground="#888" FontSize="11" Width="70"/>
                                            </StackPanel>
                                        </DataTemplate>
                                    </ListBox.ItemTemplate>
                                </ListBox>
                            </StackPanel>
                        </Grid>
                    </Border>
                </Grid>
            </Border>

            <!-- ==================== ROW 1: Gene Structure Visualization ==================== -->
            <Border x:Name="GeneVisualizationPanel" Grid.Row="1" Style="{StaticResource CardStyle}" Margin="0,0,0,8" Visibility="Collapsed">
                <StackPanel>
                    <Grid Margin="0,0,0,5">
                        <TextBlock x:Name="GeneInfoLabel" Text="" FontSize="12" FontWeight="SemiBold" Foreground="#333"/>
                        <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">
                            <Button Content="−" Width="28" Height="24" Style="{StaticResource SmallButtonStyle}" Click="ZoomOutButton_Click" Margin="0,0,3,0"/>
                            <Button Content="Reset" Height="24" Style="{StaticResource SmallButtonStyle}" Click="ZoomResetButton_Click" Margin="0,0,3,0"/>
                            <Button Content="+" Width="28" Height="24" Style="{StaticResource SmallButtonStyle}" Click="ZoomInButton_Click"/>
                        </StackPanel>
                    </Grid>
                    <ScrollViewer x:Name="GeneVisualizationScrollViewer" HorizontalScrollBarVisibility="Auto" VerticalScrollBarVisibility="Disabled" Height="110" PreviewMouseWheel="GeneVisualizationScrollViewer_PreviewMouseWheel">
                        <Canvas x:Name="GeneVisualizationCanvas" Background="#FAFAFA" Height="105" MouseLeftButtonDown="GeneCanvas_MouseLeftButtonDown" MouseLeftButtonUp="GeneCanvas_MouseLeftButtonUp" MouseMove="GeneCanvas_MouseMove"/>
                    </ScrollViewer>
                    <!-- Region Selection -->
                    <Border Background="#FAFAF0" CornerRadius="4" Padding="8,6" Margin="0,8,0,0" BorderBrush="#E0E0E0" BorderThickness="1">
                        <Grid>
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>
                            <TextBlock Grid.Row="0" Text="💡 Click and drag on the gene map above to select a region as your primer design template." FontSize="11" Foreground="#666" FontStyle="Italic" TextWrapping="Wrap" Margin="0,0,0,4"/>
                            <StackPanel Grid.Row="1" Orientation="Horizontal">
                                <TextBlock Text="Selected Region:" FontSize="12" Foreground="#555" VerticalAlignment="Center"/>
                                <TextBlock x:Name="SelectedRegionLabel" Text="No region selected" FontSize="12" Foreground="#2196F3" VerticalAlignment="Center" Margin="8,0,0,0" FontWeight="SemiBold"/>
                                <Button x:Name="UseSelectedRegionButton" Content="Use Selected Region" Style="{StaticResource SecondaryButtonStyle}" Margin="15,0,0,0" IsEnabled="False" Click="UseSelectedRegion_Click"/>
                                <Button Content="Use Entire Sequence" Style="{StaticResource SmallButtonStyle}" Margin="8,0,0,0" Click="UseEntireSequence_Click"/>
                            </StackPanel>
                        </Grid>
                    </Border>
                    <Border x:Name="InfoBar" Background="#E3F2FD" CornerRadius="4" Padding="10,6" Margin="0,6,0,0" Visibility="Collapsed">
                        <StackPanel Orientation="Horizontal">
                            <TextBlock x:Name="InfoIcon" Text="✅" FontSize="12" VerticalAlignment="Center" Margin="0,0,6,0"/>
                            <TextBlock x:Name="InfoText" Text="" FontSize="12" VerticalAlignment="Center" TextWrapping="Wrap"/>
                        </StackPanel>
                    </Border>
                </StackPanel>
            </Border>

            <!-- Loading Overlay -->
            <Border x:Name="LoadingOverlay" Grid.RowSpan="3" Background="#80FFFFFF" Visibility="Collapsed" CornerRadius="8" Panel.ZIndex="100">
                <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                    <ProgressBar IsIndeterminate="True" Width="200" Height="4"/>
                    <TextBlock x:Name="LoadingText" Text="Loading..." FontSize="13" Foreground="#555" Margin="0,8,0,0" HorizontalAlignment="Center"/>
                </StackPanel>
            </Border>

            <!-- ==================== ROW 2: Main Content ==================== -->
            <Grid Grid.Row="2">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="380"/>
                    <ColumnDefinition Width="10"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- ===== LEFT: Parameters ===== -->
                <ScrollViewer x:Name="LeftParamsScrollViewer" Grid.Column="0" VerticalScrollBarVisibility="Auto">
                    <StackPanel>
                        <!-- Active Template -->
                        <Border Style="{StaticResource CardStyle}">
                            <StackPanel>
                                <TextBlock Text="Active Template Sequence" Style="{StaticResource SectionTitleStyle}"/>
                                <TextBox x:Name="ActiveTemplateDisplay" Style="{StaticResource SeqBoxStyle}" Height="60" IsReadOnly="True" Background="#F9F9F9"/>
                                <TextBlock x:Name="ActiveTemplateLengthLabel" Text="No template loaded" FontSize="11" Foreground="#888" Margin="0,5,0,0"/>
                            </StackPanel>
                        </Border>

                        <!-- Design Mode -->
                        <Border Style="{StaticResource CardStyle}">
                            <StackPanel>
                                <TextBlock Text="Design Mode" Style="{StaticResource SectionTitleStyle}"/>
                                <RadioButton x:Name="ManualModeRadio" Content="Manual — Analyze / find complement" GroupName="DesignMode" Margin="0,0,0,8" Checked="DesignMode_Changed"/>
                                <RadioButton x:Name="AutoModeRadio" Content="Auto — Pick optimal primer pairs" IsChecked="True" GroupName="DesignMode" Checked="DesignMode_Changed"/>
                            </StackPanel>
                        </Border>

                        <!-- ===== Manual Panel (with conditions + find missing strand) ===== -->
                        <Border x:Name="ManualInputPanel" Style="{StaticResource CardStyle}" Visibility="Collapsed">
                            <StackPanel>
                                <TextBlock Text="Primer Sequences (5'→3')" Style="{StaticResource SectionTitleStyle}"/>
                                <TextBlock Text="Forward Primer" Style="{StaticResource LabelStyle}"/>
                                <TextBox x:Name="ForwardPrimerInput" FontFamily="Consolas" FontSize="13" Padding="8" BorderBrush="#CCC" BorderThickness="1"/>
                                <TextBlock Text="Reverse Primer (enter as 5'→3')" Style="{StaticResource LabelStyle}" Margin="0,10,0,4"/>
                                <TextBox x:Name="ReversePrimerInput" FontFamily="Consolas" FontSize="13" Padding="8" BorderBrush="#CCC" BorderThickness="1"/>

                                <TextBlock Text="Conditions for missing strand" FontSize="12" FontWeight="SemiBold" Foreground="#555" Margin="0,12,0,6"/>
                                <TextBlock Text="If one primer is empty, auto-find the complementary strand using these criteria:" FontSize="11" Foreground="#888" TextWrapping="Wrap" Margin="0,0,0,6"/>
                                <Grid>
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="10"/>
                                        <ColumnDefinition Width="*"/>
                                    </Grid.ColumnDefinitions>
                                    <Grid.RowDefinitions>
                                        <RowDefinition/>
                                        <RowDefinition/>
                                        <RowDefinition/>
                                        <RowDefinition/>
                                    </Grid.RowDefinitions>
                                    <TextBlock Text="Target Tm (°C)" Style="{StaticResource LabelStyle}" Grid.Row="0" Grid.Column="0"/>
                                    <TextBox x:Name="ManualTargetTmInput" Text="60" Padding="6" BorderBrush="#CCC" Grid.Row="1" Grid.Column="0" Margin="0,0,0,6"/>
                                    <TextBlock Text="Tm tolerance (±°C)" Style="{StaticResource LabelStyle}" Grid.Row="0" Grid.Column="2"/>
                                    <TextBox x:Name="ManualTmToleranceInput" Text="3" Padding="6" BorderBrush="#CCC" Grid.Row="1" Grid.Column="2" Margin="0,0,0,6"/>
                                    <TextBlock Text="Target Product (bp)" Style="{StaticResource LabelStyle}" Grid.Row="2" Grid.Column="0"/>
                                    <TextBox x:Name="ManualTargetProductInput" Text="300" Padding="6" BorderBrush="#CCC" Grid.Row="3" Grid.Column="0" Margin="0,0,0,6"/>
                                    <TextBlock Text="Product tolerance (±bp)" Style="{StaticResource LabelStyle}" Grid.Row="2" Grid.Column="2"/>
                                    <TextBox x:Name="ManualProductToleranceInput" Text="200" Padding="6" BorderBrush="#CCC" Grid.Row="3" Grid.Column="2" Margin="0,0,0,6"/>
                                </Grid>
                                <Button Content="Analyze / Find Complement" Style="{StaticResource PrimaryButtonStyle}" Margin="0,10,0,0" Click="AnalyzePrimers_Click"/>
                            </StackPanel>
                        </Border>

                        <!-- ===== Auto-Pick Panel (with target + RE checkbox) ===== -->
                        <Border x:Name="AutoDesignPanel" Style="{StaticResource CardStyle}">
                            <StackPanel>
                                <TextBlock Text="Auto-Pick Parameters" Style="{StaticResource SectionTitleStyle}"/>
                                <Grid>
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="8"/>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="8"/>
                                        <ColumnDefinition Width="*"/>
                                    </Grid.ColumnDefinitions>
                                    <Grid.RowDefinitions>
                                        <RowDefinition/>
                                        <RowDefinition/>
                                        <RowDefinition/>
                                        <RowDefinition/>
                                        <RowDefinition/>
                                        <RowDefinition/>
                                    </Grid.RowDefinitions>

                                    <TextBlock Text="Min Length" Style="{StaticResource LabelStyle}" Grid.Row="0" Grid.Column="0"/>
                                    <TextBox x:Name="MinLengthInput" Text="18" Padding="5" BorderBrush="#CCC" Grid.Row="1" Grid.Column="0" Margin="0,0,0,6"/>
                                    <TextBlock Text="Max Length" Style="{StaticResource LabelStyle}" Grid.Row="0" Grid.Column="2"/>
                                    <TextBox x:Name="MaxLengthInput" Text="25" Padding="5" BorderBrush="#CCC" Grid.Row="1" Grid.Column="2" Margin="0,0,0,6"/>
                                    <TextBlock Text="Max ΔTm (°C)" Style="{StaticResource LabelStyle}" Grid.Row="0" Grid.Column="4"/>
                                    <TextBox x:Name="MaxTmDiffInput" Text="3" Padding="5" BorderBrush="#CCC" Grid.Row="1" Grid.Column="4" Margin="0,0,0,6"/>

                                    <TextBlock Text="Min Tm (°C)" Style="{StaticResource LabelStyle}" Grid.Row="2" Grid.Column="0"/>
                                    <TextBox x:Name="MinTmInput" Text="55" Padding="5" BorderBrush="#CCC" Grid.Row="3" Grid.Column="0" Margin="0,0,0,6"/>
                                    <TextBlock Text="Target Tm (°C)" Style="{StaticResource LabelStyle}" Grid.Row="2" Grid.Column="2" Foreground="#1976D2" FontWeight="SemiBold"/>
                                    <TextBox x:Name="TargetTmInput" Text="60" Padding="5" BorderBrush="#90CAF9" BorderThickness="2" Grid.Row="3" Grid.Column="2" Margin="0,0,0,6"/>
                                    <TextBlock Text="Max Tm (°C)" Style="{StaticResource LabelStyle}" Grid.Row="2" Grid.Column="4"/>
                                    <TextBox x:Name="MaxTmInput" Text="65" Padding="5" BorderBrush="#CCC" Grid.Row="3" Grid.Column="4" Margin="0,0,0,6"/>

                                    <TextBlock Text="Min Product (bp)" Style="{StaticResource LabelStyle}" Grid.Row="4" Grid.Column="0"/>
                                    <TextBox x:Name="MinProductInput" Text="100" Padding="5" BorderBrush="#CCC" Grid.Row="5" Grid.Column="0" Margin="0,0,0,4"/>
                                    <TextBlock Text="Target Product (bp)" Style="{StaticResource LabelStyle}" Grid.Row="4" Grid.Column="2" Foreground="#1976D2" FontWeight="SemiBold"/>
                                    <TextBox x:Name="TargetProductInput" Text="300" Padding="5" BorderBrush="#90CAF9" BorderThickness="2" Grid.Row="5" Grid.Column="2" Margin="0,0,0,4"/>
                                    <TextBlock Text="Max Product (bp)" Style="{StaticResource LabelStyle}" Grid.Row="4" Grid.Column="4"/>
                                    <TextBox x:Name="MaxProductInput" Text="1000" Padding="5" BorderBrush="#CCC" Grid.Row="5" Grid.Column="4" Margin="0,0,0,4"/>
                                </Grid>

                                <CheckBox x:Name="GcClampCheckBox" Content="Require GC clamp (3' G or C)" IsChecked="True" Margin="0,6,0,0"/>
                                <CheckBox x:Name="SelfCompCheckBox" Content="Penalize self-complementarity (ΔG &lt; -5 kcal/mol)" IsChecked="True" Margin="0,4,0,0"/>

                                <!-- Reaction Conditions (Owczarzy 2008 / SantaLucia 1998) -->
                                <Border Background="#F5F9FF" CornerRadius="4" Padding="8,6" Margin="0,8,0,0" BorderBrush="#BBDEFB" BorderThickness="1">
                                    <StackPanel>
                                        <TextBlock Text="🧪 Reaction Conditions" FontSize="11" FontWeight="SemiBold" Foreground="#1565C0" Margin="0,0,0,4"/>
                                        <Grid>
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="6"/>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="6"/>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="6"/>
                                                <ColumnDefinition Width="*"/>
                                            </Grid.ColumnDefinitions>
                                            <Grid.RowDefinitions>
                                                <RowDefinition/>
                                                <RowDefinition/>
                                            </Grid.RowDefinitions>
                                            <TextBlock Text="Na⁺ (mM)" FontSize="10" Foreground="#666" Grid.Row="0" Grid.Column="0"/>
                                            <TextBox x:Name="NaConcInput" Text="50" Padding="3" FontSize="11" BorderBrush="#CCC" Grid.Row="1" Grid.Column="0" ToolTip="Monovalent cation concentration (mM)"/>
                                            <TextBlock Text="Mg²⁺ (mM)" FontSize="10" Foreground="#666" Grid.Row="0" Grid.Column="2"/>
                                            <TextBox x:Name="MgConcInput" Text="1.5" Padding="3" FontSize="11" BorderBrush="#CCC" Grid.Row="1" Grid.Column="2" ToolTip="Divalent cation concentration (mM)"/>
                                            <TextBlock Text="dNTP (mM)" FontSize="10" Foreground="#666" Grid.Row="0" Grid.Column="4"/>
                                            <TextBox x:Name="DntpConcInput" Text="0.6" Padding="3" FontSize="11" BorderBrush="#CCC" Grid.Row="1" Grid.Column="4" ToolTip="dNTP concentration (mM)"/>
                                            <TextBlock Text="Primer (nM)" FontSize="10" Foreground="#666" Grid.Row="0" Grid.Column="6"/>
                                            <TextBox x:Name="PrimerConcInput" Text="250" Padding="3" FontSize="11" BorderBrush="#CCC" Grid.Row="1" Grid.Column="6" ToolTip="Primer concentration (nM)"/>
                                        </Grid>
                                        <TextBlock Text="Tm: Owczarzy 2008 + SantaLucia 1998 NN" FontSize="9" Foreground="#999" FontStyle="Italic" Margin="0,3,0,0"/>
                                    </StackPanel>
                                </Border>

                                <!-- RE in Auto-Pick -->
                                <CheckBox x:Name="AutoPickRECheckBox" Content="Include restriction enzyme overhangs" Margin="0,6,0,0" Checked="AutoPickRECheckBox_Changed" Unchecked="AutoPickRECheckBox_Changed"/>
                                <Border x:Name="AutoPickREPanel" Visibility="Collapsed" Background="#F5F5F5" CornerRadius="4" Padding="8" Margin="0,4,0,0">
                                    <StackPanel>
                                        <Grid>
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="8"/>
                                                <ColumnDefinition Width="*"/>
                                            </Grid.ColumnDefinitions>
                                            <StackPanel Grid.Column="0">
                                                <TextBlock Text="Fwd 5' RE" FontSize="11" Foreground="#555"/>
                                                <ComboBox x:Name="AutoFwdREComboBox" FontSize="11" Padding="4" Margin="0,2,0,0"/>
                                            </StackPanel>
                                            <StackPanel Grid.Column="2">
                                                <TextBlock Text="Rev 5' RE" FontSize="11" Foreground="#555"/>
                                                <ComboBox x:Name="AutoRevREComboBox" FontSize="11" Padding="4" Margin="0,2,0,0"/>
                                            </StackPanel>
                                        </Grid>
                                        <StackPanel Orientation="Horizontal" Margin="0,6,0,0">
                                            <TextBlock Text="Protective bases:" VerticalAlignment="Center" FontSize="11" Foreground="#555"/>
                                            <TextBox x:Name="ProtectiveBasesInput" Text="2" Width="40" Padding="3" Margin="6,0,0,0" FontSize="11" BorderBrush="#CCC" ToolTip="Extra bases before RE site for efficient cutting"/>
                                            <TextBlock Text="bp" VerticalAlignment="Center" Margin="4,0,0,0" FontSize="11" Foreground="#888"/>
                                        </StackPanel>
                                        <Border Background="#EEEEEE" CornerRadius="3" Padding="6" Margin="0,6,0,0">
                                            <StackPanel>
                                                <TextBlock Text="Preview (top result):" FontSize="10" Foreground="#777" Margin="0,0,0,2"/>
                                                <TextBlock x:Name="FwdWithREPreview" FontFamily="Consolas" FontSize="10" Foreground="#1976D2" TextWrapping="Wrap"/>
                                                <TextBlock x:Name="RevWithREPreview" FontFamily="Consolas" FontSize="10" Foreground="#388E3C" TextWrapping="Wrap" Margin="0,1,0,0"/>
                                            </StackPanel>
                                        </Border>
                                    </StackPanel>
                                </Border>

                                <Button Content="🔍 Auto-Pick Primers" Style="{StaticResource SecondaryButtonStyle}" Margin="0,12,0,0" Click="AutoPickPrimers_Click"/>
                            </StackPanel>
                        </Border>


                        <Button Content="Clear All" Style="{StaticResource DangerButtonStyle}" HorizontalAlignment="Left" Margin="0,3,0,10" Click="ClearAll_Click"/>
                    </StackPanel>
                </ScrollViewer>

                <!-- ===== RIGHT: Results (with ScrollViewer) ===== -->
                <Border Grid.Column="2" Background="Transparent">
                    <ScrollViewer x:Name="RightResultsScrollViewer" VerticalScrollBarVisibility="Visible" HorizontalScrollBarVisibility="Disabled">
                        <StackPanel Margin="0,0,5,0">
                            <!-- Auto Results (DataGrid at top) -->
                            <Border x:Name="AutoResultsPanel" Style="{StaticResource CardStyle}" Visibility="Collapsed">
                                <StackPanel>
                                    <StackPanel Orientation="Horizontal" Margin="0,0,0,8">
                                        <TextBlock Text="🏆 Auto-Picked Primer Pairs" Style="{StaticResource SectionTitleStyle}" Foreground="#00796B"/>
                                        <Button Content="Export CSV" Style="{StaticResource SmallButtonStyle}" Margin="15,0,0,0" Click="ExportAutoResults_Click" VerticalAlignment="Center"/>
                                    </StackPanel>
                                    <TextBlock Text="💡 Click to preview primer details below." FontSize="10" Foreground="#999" Margin="0,0,0,4" FontStyle="Italic"/>
                                    <DataGrid x:Name="AutoResultsDataGrid" AutoGenerateColumns="False" IsReadOnly="True" CanUserSortColumns="True" HeadersVisibility="Column" GridLinesVisibility="Horizontal" BorderBrush="#E0E0E0" BorderThickness="1" MaxHeight="300" FontSize="11" SelectionChanged="AutoResultsDataGrid_SelectionChanged" MouseDoubleClick="AutoResultsDataGrid_MouseDoubleClick">
                                        <DataGrid.Columns>
                                            <DataGridTextColumn Header="#" Binding="{Binding Rank}" Width="30"/>
                                            <DataGridTextColumn Header="Fwd (5'→3')" Binding="{Binding ForwardDisplay}" Width="160">
                                                <DataGridTextColumn.ElementStyle>
                                                    <Style TargetType="TextBlock">
                                                        <Setter Property="FontFamily" Value="Consolas"/>
                                                        <Setter Property="FontSize" Value="10"/>
                                                    </Style>
                                                </DataGridTextColumn.ElementStyle>
                                            </DataGridTextColumn>
                                            <DataGridTextColumn Header="Rev (5'→3')" Binding="{Binding ReverseDisplay}" Width="160">
                                                <DataGridTextColumn.ElementStyle>
                                                    <Style TargetType="TextBlock">
                                                        <Setter Property="FontFamily" Value="Consolas"/>
                                                        <Setter Property="FontSize" Value="10"/>
                                                    </Style>
                                                </DataGridTextColumn.ElementStyle>
                                            </DataGridTextColumn>
                                            <DataGridTextColumn Header="Fwd Tm" Binding="{Binding ForwardTm, StringFormat={}{0:F1}}" Width="52"/>
                                            <DataGridTextColumn Header="Rev Tm" Binding="{Binding ReverseTm, StringFormat={}{0:F1}}" Width="52"/>
                                            <DataGridTextColumn Header="ΔTm" Binding="{Binding TmDiff, StringFormat={}{0:F1}}" Width="38"/>
                                            <DataGridTextColumn Header="Product" Binding="{Binding ProductSize}" Width="52"/>
                                            <DataGridTextColumn Header="Score" Binding="{Binding Score, StringFormat={}{0:F1}}" Width="45"/>
                                        </DataGrid.Columns>
                                    </DataGrid>
                                    <TextBlock x:Name="AutoResultsInfo" Text="" FontSize="11" Foreground="#888" Margin="0,5,0,0"/>
                                </StackPanel>
                            </Border>
                            <!-- Pair Summary (between results grid and primer details) -->
                            <Border x:Name="PairSummaryPanel" Style="{StaticResource CardStyle}" Visibility="Collapsed">
                                <StackPanel>
                                    <StackPanel Orientation="Horizontal">
                                        <TextBlock Text="🔗 Primer Pair Summary" Style="{StaticResource SectionTitleStyle}" Foreground="#7B1FA2"/>
                                        <Button Content="🔬 Primer-BLAST (NCBI)" FontSize="11" Padding="8,4" Margin="15,0,0,0"
                                            Background="#1565C0" Foreground="White" BorderThickness="0" Cursor="Hand"
                                            Click="PrimerBlast_Click" ToolTip="Open NCBI Primer-BLAST with current primers pre-filled" VerticalAlignment="Center">
                                            <Button.Resources>
                                                <Style TargetType="Border">
                                                    <Setter Property="CornerRadius" Value="4"/>
                                                </Style>
                                            </Button.Resources>
                                        </Button>
                                    </StackPanel>
                                    <Grid Margin="0,6,0,0">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <StackPanel Grid.Column="0" Margin="0,0,8,0">
                                            <TextBlock Text="Product" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="ProductSize" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="1" Margin="0,0,8,0">
                                            <TextBlock Text="ΔTm" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="TmDifference" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="2" Margin="0,0,8,0">
                                            <TextBlock Text="Hetero-Dimer" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="HeteroDimer" FontSize="14" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="3" Margin="0,0,8,0">
                                            <TextBlock Text="Score" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="OverallScore" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                    </Grid>
                                    <TextBlock x:Name="PairWarnings" TextWrapping="Wrap" Foreground="#E65100" FontSize="11" Margin="0,8,0,0"/>
                                </StackPanel>
                            </Border>
                            <!-- Forward Primer -->
                            <Border x:Name="ForwardResultPanel" Style="{StaticResource CardStyle}">
                                <StackPanel>
                                    <StackPanel Orientation="Horizontal" Margin="0,0,0,8">
                                        <TextBlock Text="➤ Forward Primer" Style="{StaticResource SectionTitleStyle}" Foreground="#1976D2"/>
                                        <Button Content="Copy" Style="{StaticResource SmallButtonStyle}" Margin="15,0,0,0" Click="CopyForwardPrimer_Click" VerticalAlignment="Center"/>
                                    </StackPanel>
                                    <TextBlock x:Name="FwdSequenceDisplay" FontFamily="Consolas" FontSize="14" Foreground="#333" TextWrapping="Wrap" Margin="0,0,0,8"/>
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition/>
                                            <RowDefinition/>
                                            <RowDefinition/>
                                        </Grid.RowDefinitions>
                                        <StackPanel Grid.Column="0" Grid.Row="0" Margin="0,0,8,8">
                                            <TextBlock Text="Length" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="FwdLength" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="1" Grid.Row="0" Margin="0,0,8,8">
                                            <TextBlock Text="Tm (°C)" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="FwdTm" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="2" Grid.Row="0" Margin="0,0,8,8">
                                            <TextBlock Text="GC %" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="FwdGC" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="3" Grid.Row="0" Margin="0,0,8,8">
                                            <TextBlock Text="M.W." FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="FwdMW" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="0" Grid.Row="1" Margin="0,0,8,8">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="GC Clamp" FontSize="11" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="9" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="FwdGCClamp" FontSize="14" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="1" Grid.Row="1" Margin="0,0,8,8">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Self-Comp" FontSize="11" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="9" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="FwdSelfComp" FontSize="14" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="2" Grid.Row="1" Margin="0,0,8,8">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Hairpin" FontSize="11" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="9" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="FwdHairpin" FontSize="14" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="3" Grid.Row="1" Margin="0,0,8,8">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="3' ΔG" FontSize="11" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="9" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="FwdEndStability" FontSize="14" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="0" Grid.Row="2" Margin="0,0,8,0">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Self-Dimer ΔG" FontSize="10" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="8" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="FwdSelfDimerDG" FontSize="13" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="1" Grid.Row="2" Margin="0,0,8,0">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Hairpin ΔG" FontSize="10" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="8" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="FwdHairpinDG" FontSize="13" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="2" Grid.Row="2" Margin="0,0,8,0" Grid.ColumnSpan="2">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Any Self-Comp" FontSize="10" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="8" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="FwdAnyComp" FontSize="13" FontWeight="SemiBold"/>
                                        </StackPanel>
                                    </Grid>
                                    <TextBlock x:Name="FwdWarnings" TextWrapping="Wrap" Foreground="#E65100" FontSize="11" Margin="0,8,0,0"/>
                                </StackPanel>
                            </Border>
                            <!-- Reverse Primer -->
                            <Border x:Name="ReverseResultPanel" Style="{StaticResource CardStyle}">
                                <StackPanel>
                                    <StackPanel Orientation="Horizontal" Margin="0,0,0,8">
                                        <TextBlock Text="◄ Reverse Primer" Style="{StaticResource SectionTitleStyle}" Foreground="#388E3C"/>
                                        <Button Content="Copy" Style="{StaticResource SmallButtonStyle}" Margin="15,0,0,0" Click="CopyReversePrimer_Click" VerticalAlignment="Center"/>
                                    </StackPanel>
                                    <TextBlock x:Name="RevSequenceDisplay" FontFamily="Consolas" FontSize="14" Foreground="#333" TextWrapping="Wrap" Margin="0,0,0,8"/>
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition/>
                                            <RowDefinition/>
                                            <RowDefinition/>
                                        </Grid.RowDefinitions>
                                        <StackPanel Grid.Column="0" Grid.Row="0" Margin="0,0,8,8">
                                            <TextBlock Text="Length" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="RevLength" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="1" Grid.Row="0" Margin="0,0,8,8">
                                            <TextBlock Text="Tm (°C)" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="RevTm" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="2" Grid.Row="0" Margin="0,0,8,8">
                                            <TextBlock Text="GC %" FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="RevGC" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="3" Grid.Row="0" Margin="0,0,8,8">
                                            <TextBlock Text="M.W." FontSize="11" Foreground="#888"/>
                                            <TextBlock x:Name="RevMW" FontSize="16" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="0" Grid.Row="1" Margin="0,0,8,8">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="GC Clamp" FontSize="11" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="9" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="RevGCClamp" FontSize="14" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="1" Grid.Row="1" Margin="0,0,8,8">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Self-Comp" FontSize="11" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="9" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="RevSelfComp" FontSize="14" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="2" Grid.Row="1" Margin="0,0,8,8">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Hairpin" FontSize="11" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="9" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="RevHairpin" FontSize="14" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="3" Grid.Row="1" Margin="0,0,8,8">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="3' ΔG" FontSize="11" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="9" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="RevEndStability" FontSize="14" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="0" Grid.Row="2" Margin="0,0,8,0">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Self-Dimer ΔG" FontSize="10" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="8" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="RevSelfDimerDG" FontSize="13" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="1" Grid.Row="2" Margin="0,0,8,0">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Hairpin ΔG" FontSize="10" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="8" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="RevHairpinDG" FontSize="13" FontWeight="SemiBold"/>
                                        </StackPanel>
                                        <StackPanel Grid.Column="2" Grid.Row="2" Margin="0,0,8,0" Grid.ColumnSpan="2">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="Any Self-Comp" FontSize="10" Foreground="#888"/>
                                                <TextBlock Text=" ⓘ" FontSize="8" Foreground="#7B1FA2" Cursor="Hand" MouseLeftButtonDown="ScrollToGuide_Click" ToolTip="Click for explanation"/>
                                            </StackPanel>
                                            <TextBlock x:Name="RevAnyComp" FontSize="13" FontWeight="SemiBold"/>
                                        </StackPanel>
                                    </Grid>
                                    <TextBlock x:Name="RevWarnings" TextWrapping="Wrap" Foreground="#E65100" FontSize="11" Margin="0,8,0,0"/>
                                </StackPanel>
                            </Border>
                            <!-- Parameter Guide (always visible) -->
                            <Border x:Name="ParameterDetailPanel" Style="{StaticResource CardStyle}" Background="#F3E5F5" BorderBrush="#B39DDB" BorderThickness="1.5">
                                <StackPanel>
                                    <TextBlock Text="📘 Analysis Parameters Guide" Style="{StaticResource SectionTitleStyle}" Foreground="#5E35B1" Margin="0,0,0,6"/>
                                    <TextBlock TextWrapping="Wrap" FontSize="11" Foreground="#555" LineHeight="18">
                                    <Run FontWeight="SemiBold" Foreground="#1976D2">GC Clamp</Run><Run> — Primer ends with G or C at the 3' terminus, enhancing binding stability at the extension initiation site.</Run><LineBreak/>
                                    <Run FontWeight="SemiBold" Foreground="#1976D2">Self-Comp</Run><Run> — Maximum number of consecutive self-complementary bases (primer aligned to its own reverse complement). A score ≥4 indicates significant self-dimer formation risk.</Run><LineBreak/>
                                    <Run FontWeight="SemiBold" Foreground="#1976D2">Hairpin</Run><Run> — Maximum stem base pairs in intramolecular hairpin structures. A score ≥3 suggests the primer may fold into a stable hairpin during annealing, reducing availability.</Run><LineBreak/>
                                    <Run FontWeight="SemiBold" Foreground="#1976D2">3' ΔG</Run><Run> — Free energy of the last 5 bases at the 3' end (kcal/mol, SantaLucia 1998 NN model). Highly negative values (&lt;-9) indicate excessive 3' stability that may promote non-specific extension or mispriming.</Run><LineBreak/>
                                    <Run FontWeight="SemiBold" Foreground="#1976D2">Self-Dimer ΔG</Run><Run> — Thermodynamic stability of the most stable self-dimer alignment (kcal/mol). Calculated by sliding the primer against its reverse complement across all offsets, summing NN ΔG for consecutive base pairs plus initiation penalty (+1.96 kcal/mol). Values &lt;-6 trigger a warning.</Run><LineBreak/>
                                    <Run FontWeight="SemiBold" Foreground="#1976D2">Hairpin ΔG</Run><Run> — Free energy of the most stable intramolecular hairpin (kcal/mol). Combines stem ΔG from NN parameters with empirical loop penalties (Zuker 2003). Values &lt;-3 trigger a warning.</Run><LineBreak/>
                                    <Run FontWeight="SemiBold" Foreground="#1976D2">Any Self-Comp</Run><Run> — Total complementary bases (non-consecutive) in the worst-case alignment. Evaluates cumulative weak-binding risk from multiple short complementary regions. Exceeding 40% of primer length triggers a yellow warning.</Run>
                                    </TextBlock>
                                </StackPanel>
                            </Border>
                            <!-- Sequence View -->
                            <Border x:Name="SequenceViewPanel" Style="{StaticResource CardStyle}" Visibility="Collapsed">
                                <StackPanel>
                                    <TextBlock Text="📋 Primer Binding Visualization" Style="{StaticResource SectionTitleStyle}"/>
                                    <Border Background="#FAFAFA" CornerRadius="4" Padding="10" BorderBrush="#E0E0E0" BorderThickness="1">
                                        <TextBlock x:Name="SequenceVisualization" FontFamily="Consolas" FontSize="12" TextWrapping="Wrap" xml:space="preserve"/>
                                    </Border>
                                </StackPanel>
                            </Border>
                        </StackPanel>
                    </ScrollViewer>
                </Border>
            </Grid>
        </Grid>
    </ScrollViewer>
</Page>


==================================================
FILE_NAME: PrimerDesignerPage.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\PrimerDesignerPage.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using Microsoft.Win32;
using System.IO;
using BioSAK.Services;
using BioSAK.Models;

namespace BioSAK.Pages
{
    public partial class PrimerDesignerPage : Page
    {
        #region === Fields ===

        private static readonly HttpClient httpClient = new HttpClient();
        private readonly GeneIdService _geneIdService;
        private List<RestrictionEnzyme> _allEnzymes;
        private CancellationTokenSource _fetchCts; // prevents race conditions on rapid clicks

        // ── Static NN thermodynamic lookup arrays (SantaLucia 1998) ──
        // Indexed by (base1 * 4 + base2) where A=0, C=1, G=2, T=3
        private static readonly int[] _baseIdx = new int[128];
        private static readonly double[] _nnH = new double[16]; // ΔH kcal/mol
        private static readonly double[] _nnS = new double[16]; // ΔS cal/(mol·K)
        private static readonly double[] _nnG = new double[16]; // ΔG kcal/mol at 37°C

        static PrimerDesignerPage()
        {
            for (int i = 0; i < 128; i++) _baseIdx[i] = -1;
            _baseIdx['A'] = 0; _baseIdx['a'] = 0;
            _baseIdx['C'] = 1; _baseIdx['c'] = 1;
            _baseIdx['G'] = 2; _baseIdx['g'] = 2;
            _baseIdx['T'] = 3; _baseIdx['t'] = 3;

            // Order: AA AC AG AT CA CC CG CT GA GC GG GT TA TC TG TT
            double[] h = { -7.9, -8.4, -7.8, -7.2, -8.5, -8.0, -10.6, -7.8, -8.2, -9.8, -8.0, -8.4, -7.2, -8.2, -8.5, -7.9 };
            double[] s = { -22.2, -22.4, -21.0, -20.4, -22.7, -19.9, -27.2, -21.0, -22.2, -24.4, -19.9, -22.4, -21.3, -22.2, -22.7, -22.2 };
            double[] g = { -1.00, -1.44, -1.28, -0.88, -1.45, -1.84, -2.17, -1.28, -1.30, -2.24, -1.84, -1.44, -0.58, -1.30, -1.45, -1.00 };
            Array.Copy(h, _nnH, 16);
            Array.Copy(s, _nnS, 16);
            Array.Copy(g, _nnG, 16);
        }

        // Gene data
        private string _genomicSequence = "";
        private string _activeTemplate = "";
        private string _currentGeneSymbol = "";
        private string _currentAccession = "";
        private string _currentTaxId = "9606";
        private List<ExonInfo> _exonList = new List<ExonInfo>();
        private List<CDSRegion> _cdsList = new List<CDSRegion>();
        private List<TranscriptIsoform> _isoforms = new List<TranscriptIsoform>();

        // Visualization
        private double _currentScale = 0.01;
        private double _defaultScale = 0.01;
        private const double MIN_SCALE = 0.001;
        private const double MAX_SCALE = 1.0;
        private const double MARGIN = 30;
        private const double GENE_Y = 35;

        // Region selection
        private bool _isDragging = false;
        private double _dragStartX;
        private int _selectionStart = -1;
        private int _selectionEnd = -1;
        private int _templateOffset = 0; // genomic offset of _activeTemplate start
        private int _markerFwdStart = -1, _markerFwdLen = 0;
        private int _markerRevStart = -1, _markerRevLen = 0;

        // Collapsible
        private bool _isInputCollapsed = false;

        // Primer results (for RE preview)
        private string _lastFwdPrimer = "";
        private string _lastRevPrimer = "";

        // Tm calculation parameters (defaults match NCBI Primer-BLAST)
        private double _naConc = 0.05;      // 50 mM monovalent cation
        private double _mgConc = 0.0015;    // 1.5 mM Mg2+
        private double _dntpConc = 0.0006;  // 0.6 mM dNTP
        private double _primerConc = 250e-9; // 250 nM primer

        private const string NCBI_ESEARCH_URL = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi";
        private const string NCBI_EFETCH_URL = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi";
        private const string NCBI_ESUMMARY_URL = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi";
        private const string NCBI_ELINK_URL = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/elink.fcgi";

        #endregion

        #region === Constructor ===

        public PrimerDesignerPage()
        {
            InitializeComponent();

            httpClient.Timeout = TimeSpan.FromSeconds(30);
            if (!httpClient.DefaultRequestHeaders.Contains("User-Agent"))
                httpClient.DefaultRequestHeaders.Add("User-Agent", "BioXAK/1.0");

            _geneIdService = new GeneIdService();
            LoadRestrictionEnzymes();

            // Register numeric-only input validation on all parameter TextBoxes
            var numericBoxes = new[] {
                MinLengthInput, MaxLengthInput, MaxTmDiffInput,
                MinTmInput, TargetTmInput, MaxTmInput,
                MinProductInput, TargetProductInput, MaxProductInput,
                ManualTargetTmInput, ManualTmToleranceInput, ManualTargetProductInput, ManualProductToleranceInput,
                NaConcInput, MgConcInput, DntpConcInput, PrimerConcInput
            };
            foreach (var tb in numericBoxes)
            {
                tb.PreviewTextInput += NumericTextBox_PreviewTextInput;
                DataObject.AddPastingHandler(tb, NumericTextBox_Pasting);
            }
        }

        private void LoadRestrictionEnzymes()
        {
            try { _allEnzymes = RebaseParser.LoadEnzymes(); }
            catch { _allEnzymes = new List<RestrictionEnzyme>(); }

            var reItems = new List<string> { "(None)" };
            var commonNames = new[] { "EcoRI", "BamHI", "HindIII", "XhoI", "NheI", "NcoI", "XbaI",
                "SalI", "NotI", "KpnI", "SacI", "NdeI", "BglII", "SpeI", "AgeI", "MluI",
                "EcoRV", "SmaI", "PstI", "ApaI", "PacI", "ClaI", "MfeI" };

            foreach (var name in commonNames)
            {
                var enz = _allEnzymes.FirstOrDefault(e => e.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
                if (enz != null) reItems.Add($"{enz.Name}  ({enz.RecognitionSequence})");
            }
            reItems.Add("── All Enzymes ──");
            foreach (var enz in _allEnzymes.Where(e => !commonNames.Contains(e.Name, StringComparer.OrdinalIgnoreCase)))
                reItems.Add($"{enz.Name}  ({enz.RecognitionSequence})");

            AutoFwdREComboBox.ItemsSource = reItems;
            AutoRevREComboBox.ItemsSource = reItems;
            AutoFwdREComboBox.SelectedIndex = 0;
            AutoRevREComboBox.SelectedIndex = 0;
        }

        #endregion

        #region === Data Models ===

        private class PrimerAnalysis
        {
            public string Sequence { get; set; } = "";
            public int Length { get; set; }
            public double Tm { get; set; }
            public double GCPercent { get; set; }
            public double MolecularWeight { get; set; }
            public bool HasGCClamp { get; set; }
            public int SelfComplementarityScore { get; set; }
            public int HairpinScore { get; set; }
            public double EndStabilityDeltaG { get; set; }
            public double SelfDimerDeltaG { get; set; }
            public double HairpinDeltaG { get; set; }
            public int AnyCompScore { get; set; }
            public List<string> Warnings { get; set; } = new List<string>();
        }

        public class PrimerPairResult
        {
            public int Rank { get; set; }
            public string ForwardSequence { get; set; } = "";
            public string ReverseSequence { get; set; } = "";
            public string ForwardDisplay { get; set; } = "";
            public string ReverseDisplay { get; set; } = "";
            public double ForwardTm { get; set; }
            public double ReverseTm { get; set; }
            public double TmDiff { get; set; }
            public int ProductSize { get; set; }
            public double Score { get; set; }
            public int FwdStart { get; set; }
            public int RevStart { get; set; }
        }

        public class TranscriptIsoform
        {
            public string Accession { get; set; } = "";
            public string NucId { get; set; } = "";
            public int Length { get; set; }
            public string Description { get; set; } = "";
            public string IsoformLabel { get; set; } = "";
            public string LengthDisplay => $"{Length:N0} bp";
        }

        #endregion

        #region === Collapsible Input ===

        private void InputHeader_Click(object sender, MouseButtonEventArgs e)
        {
            _isInputCollapsed = !_isInputCollapsed;
            InputContentPanel.Visibility = _isInputCollapsed ? Visibility.Collapsed : Visibility.Visible;
            CollapseArrow.Text = _isInputCollapsed ? "▶" : "▼";
        }

        #endregion

        #region === Direct Sequence Input ===

        private void DirectSequenceInput_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (DirectSeqHint == null) return;
            string text = DirectSequenceInput.Text;
            DirectSeqHint.Visibility = string.IsNullOrEmpty(text) ? Visibility.Visible : Visibility.Collapsed;
            DirectSeqLengthLabel.Text = $"Length: {CleanSequence(text).Length} bp";
        }

        private void UseDirectSequence_Click(object sender, RoutedEventArgs e)
        {
            string seq = CleanSequence(DirectSequenceInput.Text);
            if (seq.Length < 20)
            {
                MessageBox.Show("Please enter a longer sequence (≥20 bp).", "Input", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            _genomicSequence = seq;
            _currentGeneSymbol = "Custom";
            _currentAccession = "Direct input";
            _exonList.Clear();
            _cdsList.Clear();
            GeneVisualizationPanel.Visibility = Visibility.Collapsed;
            SetActiveTemplate(seq);
            InputSectionSummary.Text = $"✔ Custom sequence ({seq.Length} bp)";
        }

        #endregion

        #region === NCBI Gene Fetch ===

        private async void FetchGeneButton_Click(object sender, RoutedEventArgs e)
        {
            // Cancel any previous in-flight fetch (prevents race condition)
            _fetchCts?.Cancel();
            _fetchCts = new CancellationTokenSource();
            var ct = _fetchCts.Token;

            try
            {
                ShowLoading(true, "Connecting to NCBI...");
                string accession = AccessionTextBox.Text.Trim();
                string geneSymbol = GeneSymbolTextBox.Text.Trim();
                _currentTaxId = GetSelectedTaxId();
                string seqType = GetSelectedSeqType();

                if (!string.IsNullOrEmpty(accession))
                {
                    ShowLoading(true, $"Fetching {accession}...");
                    await FetchByAccession(accession, ct);
                }
                else if (!string.IsNullOrEmpty(geneSymbol))
                {
                    ShowLoading(true, $"Searching {geneSymbol}...");
                    await FetchByGeneSymbol(geneSymbol, _currentTaxId, seqType, ct);
                }
                else
                {
                    ShowInfo("Enter gene symbol or accession.", true);
                    return;
                }

                ct.ThrowIfCancellationRequested();

                if (!string.IsNullOrEmpty(_genomicSequence))
                {
                    InputSectionSummary.Text = $"✔ {_currentGeneSymbol} ({_currentAccession}) loaded";
                    GeneVisualizationPanel.Visibility = Visibility.Visible;

                    if (_isoforms.Count > 0)
                        IsoformPanel.Visibility = Visibility.Visible;

                    SetActiveTemplate(_genomicSequence);
                }
            }
            catch (OperationCanceledException) { /* user clicked again, ignore */ }
            catch (Exception ex) { ShowInfo($"Error: {ex.Message}", true); }
            finally { ShowLoading(false); }
        }

        private string GetSelectedTaxId()
        {
            if (SpeciesComboBox.SelectedItem is ComboBoxItem item && item.Tag != null)
                return item.Tag.ToString();
            return "9606";
        }

        private string GetSelectedSeqType()
        {
            if (SeqTypeComboBox.SelectedItem is ComboBoxItem item && item.Tag != null)
                return item.Tag.ToString();
            return "mRNA";
        }

        private string GetSpeciesNameFromTaxId(string taxId) => taxId switch
        {
            "9606" => "human",
            "10090" => "mouse",
            "10116" => "rat",
            _ => "human"
        };

        private async Task FetchByGeneSymbol(string geneSymbol, string taxId, string seqType, CancellationToken ct = default)
        {
            string geneId = null;
            string resolvedSymbol = geneSymbol;

            ShowLoading(true, "Searching local database...");
            string speciesName = GetSpeciesNameFromTaxId(taxId);

            if (_geneIdService.DatabaseExists(speciesName))
            {
                bool loaded = await _geneIdService.LoadDatabaseAsync(speciesName);
                if (loaded && _geneIdService.IsDatabaseLoaded)
                {
                    var matches = _geneIdService.Convert(geneSymbol, "symbol");
                    if (matches.Count > 0)
                    {
                        resolvedSymbol = matches[0].Symbol;
                        if (!string.IsNullOrEmpty(matches[0].EntrezId))
                        {
                            geneId = matches[0].EntrezId;
                            ShowLoading(true, $"Found: {resolvedSymbol} (Entrez: {geneId})");
                        }
                    }
                }
            }

            if (string.IsNullOrEmpty(geneId))
            {
                ct.ThrowIfCancellationRequested();
                ShowLoading(true, $"Searching NCBI for {resolvedSymbol}...");
                string searchUrl = $"{NCBI_ESEARCH_URL}?db=gene&term={Uri.EscapeDataString(resolvedSymbol)}[Gene Name]+AND+{taxId}[Taxonomy ID]&retmode=xml";
                var resp = await httpClient.GetStringAsync(searchUrl);
                ct.ThrowIfCancellationRequested();
                var xml = System.Xml.Linq.XDocument.Parse(resp);
                var ids = xml.Descendants("Id").Select(x => x.Value).ToList();

                if (ids.Count == 0)
                {
                    searchUrl = $"{NCBI_ESEARCH_URL}?db=gene&term={Uri.EscapeDataString(resolvedSymbol)}[sym]+AND+{taxId}[Taxonomy ID]&retmode=xml";
                    resp = await httpClient.GetStringAsync(searchUrl);
                    ct.ThrowIfCancellationRequested();
                    xml = System.Xml.Linq.XDocument.Parse(resp);
                    ids = xml.Descendants("Id").Select(x => x.Value).ToList();
                }

                if (ids.Count == 0) { ShowInfo($"Gene '{geneSymbol}' not found.", true); return; }
                geneId = ids.First();
            }

            ct.ThrowIfCancellationRequested();
            ShowLoading(true, $"Gene ID: {geneId}, finding transcripts...");
            if (seqType == "mRNA") await FetchMRNATranscripts(geneId, resolvedSymbol, taxId, ct);
            else await FetchGenomicSequence(geneId, resolvedSymbol, taxId, ct);
        }

        /// <summary>
        /// Fetch mRNA transcripts — parse "transcript variant X" from NCBI description
        /// to display real isoform labels instead of arbitrary numbers.
        /// </summary>
        private async Task FetchMRNATranscripts(string geneId, string geneSymbol, string taxId, CancellationToken ct = default)
        {
            string searchUrl = $"{NCBI_ESEARCH_URL}?db=nuccore&term={Uri.EscapeDataString(geneSymbol)}[Gene]+AND+(NM_[Accession]+OR+NR_[Accession])+AND+{taxId}[Taxonomy ID]+AND+RefSeq[Filter]&retmax=20&retmode=xml";
            var resp = await httpClient.GetStringAsync(searchUrl);
            ct.ThrowIfCancellationRequested();
            var xml = System.Xml.Linq.XDocument.Parse(resp);
            var nucIds = xml.Descendants("Id").Select(x => x.Value).ToList();

            if (nucIds.Count == 0)
            {
                string elinkUrl = $"{NCBI_ELINK_URL}?dbfrom=gene&db=nuccore&id={geneId}&linkname=gene_nuccore_refseqrna&retmode=xml";
                resp = await httpClient.GetStringAsync(elinkUrl);
                xml = System.Xml.Linq.XDocument.Parse(resp);
                nucIds = xml.Descendants("Link").Select(x => x.Element("Id")?.Value).Where(x => x != null).ToList();
            }

            if (nucIds.Count == 0) { ShowInfo($"No mRNA transcripts found for '{geneSymbol}'. Try Genomic mode.", true); return; }

            ShowLoading(true, $"Found {nucIds.Count} transcript(s), fetching details...");
            _isoforms.Clear();

            // Use ESummary (not EFetch) for proper DocumentSummary XML
            string summaryUrl = $"{NCBI_ESUMMARY_URL}?db=nuccore&id={string.Join(",", nucIds.Take(15))}&retmode=xml";
            resp = await httpClient.GetStringAsync(summaryUrl);
            xml = System.Xml.Linq.XDocument.Parse(resp);

            // ESummary v2 returns <DocumentSummarySet><DocumentSummary uid="...">
            var docSums = xml.Descendants("DocumentSummary").ToList();

            if (docSums.Count > 0)
            {
                foreach (var docSum in docSums)
                {
                    string uid = docSum.Attribute("uid")?.Value ?? "";
                    string acc = docSum.Element("AccessionVersion")?.Value ?? docSum.Element("Caption")?.Value ?? "";
                    string title = docSum.Element("Title")?.Value ?? "";
                    int.TryParse(docSum.Element("Slen")?.Value ?? "0", out int len);

                    if (string.IsNullOrEmpty(acc) && !string.IsNullOrEmpty(uid)) acc = uid;
                    if (string.IsNullOrEmpty(acc)) continue;

                    string isoformLabel = ExtractIsoformLabel(title);

                    _isoforms.Add(new TranscriptIsoform
                    {
                        Accession = acc,
                        NucId = uid,
                        Length = len,
                        Description = title.Length > 80 ? title.Substring(0, 80) + "..." : title,
                        IsoformLabel = isoformLabel
                    });
                }
            }

            // Fallback: ESummary v1 (old format with <Item Name="...">)
            if (_isoforms.Count == 0)
            {
                var docSumsOld = xml.Descendants("DocSum").ToList();
                foreach (var docSum in docSumsOld)
                {
                    string uid = docSum.Element("Id")?.Value ?? "";
                    string acc = docSum.Descendants("Item").FirstOrDefault(i => i.Attribute("Name")?.Value == "AccessionVersion")?.Value
                              ?? docSum.Descendants("Item").FirstOrDefault(i => i.Attribute("Name")?.Value == "Caption")?.Value ?? "";
                    string title = docSum.Descendants("Item").FirstOrDefault(i => i.Attribute("Name")?.Value == "Title")?.Value ?? "";
                    int.TryParse(docSum.Descendants("Item").FirstOrDefault(i => i.Attribute("Name")?.Value == "Length")?.Value ?? "0", out int len);

                    if (string.IsNullOrEmpty(acc) && !string.IsNullOrEmpty(uid)) acc = uid;
                    if (string.IsNullOrEmpty(acc)) continue;

                    string isoformLabel = ExtractIsoformLabel(title);

                    _isoforms.Add(new TranscriptIsoform
                    {
                        Accession = acc,
                        NucId = uid,
                        Length = len,
                        Description = title.Length > 80 ? title.Substring(0, 80) + "..." : title,
                        IsoformLabel = isoformLabel
                    });
                }
            }

            // Last resort fallback
            if (_isoforms.Count == 0)
            {
                foreach (var id in nucIds.Take(10))
                    _isoforms.Add(new TranscriptIsoform { Accession = id, NucId = id, Description = "RefSeq transcript", IsoformLabel = "—" });
            }

            // Sort by variant/isoform number (natural sort: numeric first, then alpha)
            _isoforms = _isoforms.OrderBy(iso =>
            {
                var m = Regex.Match(iso.IsoformLabel, @"\d+");
                return m.Success ? int.Parse(m.Value) : int.MaxValue;
            }).ThenBy(iso => iso.IsoformLabel).ThenBy(iso => iso.Accession).ToList();

            IsoformListBox.ItemsSource = _isoforms;
            IsoformPanel.Visibility = Visibility.Visible;

            if (_isoforms.Count > 0)
                IsoformListBox.SelectedIndex = 0;
        }

        /// <summary>
        /// Extract isoform label from NCBI title.
        /// Matches patterns: "transcript variant 1", "transcript variant X2", "transcript variant alpha"
        /// If not found, returns "—" to indicate no isoform info in NCBI data.
        /// </summary>
        private string ExtractIsoformLabel(string title)
        {
            if (string.IsNullOrEmpty(title)) return "—";

            // Pattern: "transcript variant X" where X can be a number, letter combo, or word
            // Strip trailing comma/period/semicolon that comes from NCBI title format
            var match = Regex.Match(title, @"transcript variant\s+([\w]+)", RegexOptions.IgnoreCase);
            if (match.Success)
                return $"Variant {match.Groups[1].Value}";

            // Pattern: "isoform X" in title
            match = Regex.Match(title, @"isoform\s+([\w]+)", RegexOptions.IgnoreCase);
            if (match.Success)
                return $"Isoform {match.Groups[1].Value}";

            return "—";
        }

        private async Task FetchGenomicSequence(string geneId, string geneSymbol, string taxId, CancellationToken ct = default)
        {
            string elinkUrl = $"{NCBI_ELINK_URL}?dbfrom=gene&db=nuccore&id={geneId}&linkname=gene_nuccore_refseqgene&retmode=xml";
            var resp = await httpClient.GetStringAsync(elinkUrl);
            ct.ThrowIfCancellationRequested();
            var xml = System.Xml.Linq.XDocument.Parse(resp);
            var nucIds = xml.Descendants("Link").Select(x => x.Element("Id")?.Value).Where(x => x != null).ToList();

            if (nucIds.Count == 0)
            {
                string searchUrl = $"{NCBI_ESEARCH_URL}?db=nuccore&term=NG_[Accession]+AND+{Uri.EscapeDataString(geneSymbol)}[Gene]+AND+{taxId}[Taxonomy ID]+AND+RefSeqGene[Keyword]&retmax=5&retmode=xml";
                resp = await httpClient.GetStringAsync(searchUrl);
                xml = System.Xml.Linq.XDocument.Parse(resp);
                nucIds = xml.Descendants("Id").Select(x => x.Value).ToList();
            }

            if (nucIds.Count == 0) { ShowInfo($"No RefSeqGene for '{geneSymbol}'. Try mRNA mode.", true); return; }
            ct.ThrowIfCancellationRequested();
            await FetchAndParseGenBank(nucIds.First(), ct);
        }

        private async void IsoformListBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (IsoformListBox.SelectedItem is TranscriptIsoform iso)
            {
                try
                {
                    ShowLoading(true, $"Loading {iso.Accession}...");
                    string nucId = !string.IsNullOrEmpty(iso.NucId) ? iso.NucId : iso.Accession;

                    // If nucId is not numeric UID, resolve via Accession search
                    if (!long.TryParse(nucId, out _))
                    {
                        string searchUrl = $"{NCBI_ESEARCH_URL}?db=nuccore&term={nucId}[Accession]&retmode=xml";
                        var resp = await httpClient.GetStringAsync(searchUrl);
                        var xml = System.Xml.Linq.XDocument.Parse(resp);
                        nucId = xml.Descendants("Id").FirstOrDefault()?.Value ?? iso.NucId;
                    }

                    await FetchAndParseGenBank(nucId);

                    if (!string.IsNullOrEmpty(_genomicSequence))
                    {
                        GeneVisualizationPanel.Visibility = Visibility.Visible;
                        SetActiveTemplate(_genomicSequence);
                        InputSectionSummary.Text = $"✔ {_currentGeneSymbol} ({_currentAccession}) {_genomicSequence.Length:N0} bp";
                    }
                }
                catch (Exception ex) { ShowInfo($"Error loading isoform: {ex.Message}", true); }
                finally { ShowLoading(false); }
            }
        }

        private async Task FetchByAccession(string accession, CancellationToken ct = default)
        {
            string searchUrl = $"{NCBI_ESEARCH_URL}?db=nuccore&term={accession}[Accession]&retmode=xml";
            var resp = await httpClient.GetStringAsync(searchUrl);
            ct.ThrowIfCancellationRequested();
            var xml = System.Xml.Linq.XDocument.Parse(resp);
            var nucId = xml.Descendants("Id").FirstOrDefault()?.Value;
            if (string.IsNullOrEmpty(nucId)) { ShowInfo($"Accession '{accession}' not found.", true); return; }
            await FetchAndParseGenBank(nucId, ct);
        }

        private async Task FetchAndParseGenBank(string nucId, CancellationToken ct = default)
        {
            ShowLoading(true, "Downloading GenBank...");
            string gbUrl = $"{NCBI_EFETCH_URL}?db=nuccore&id={nucId}&rettype=gb&retmode=text";
            var gbResponse = await httpClient.GetStringAsync(gbUrl);
            ct.ThrowIfCancellationRequested();

            ShowLoading(true, "Downloading sequence...");
            string fastaUrl = $"{NCBI_EFETCH_URL}?db=nuccore&id={nucId}&rettype=fasta&retmode=text";
            var fastaResponse = await httpClient.GetStringAsync(fastaUrl);
            ct.ThrowIfCancellationRequested();

            _genomicSequence = ParseFastaSequence(fastaResponse);

            ShowLoading(true, "Parsing features...");
            ParseGenBankForCDSAndExons(gbResponse);
            UpdateGeneVisualization();

            ShowInfo($"✔ {_currentGeneSymbol} ({_currentAccession}) | {_genomicSequence.Length:N0} bp | Exons: {_exonList.Count} | CDS: {_cdsList.Sum(c => c.Length):N0} bp", false);
        }

        private string ParseFastaSequence(string input)
        {
            var lines = input.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            var sb = new StringBuilder();
            foreach (var line in lines)
                if (!line.StartsWith(">"))
                    sb.Append(Regex.Replace(line, "[^ATCGatcg]", ""));
            return sb.ToString().ToUpper();
        }

        private void ParseGenBankForCDSAndExons(string gbText)
        {
            _exonList.Clear();
            _cdsList.Clear();

            var accMatch = Regex.Match(gbText, @"ACCESSION\s+(\S+)");
            if (accMatch.Success) _currentAccession = accMatch.Groups[1].Value;

            var geneMatch = Regex.Match(gbText, @"/gene=""([^""]+)""");
            if (geneMatch.Success) _currentGeneSymbol = geneMatch.Groups[1].Value;

            // CDS — use state-machine approach to handle multiline location strings
            // Matches: "     CDS             join(123..456,789..1011)"
            //          "     CDS             complement(join(...))"
            //          "     CDS             123..456"
            var cdsHeaderMatch = Regex.Match(gbText, @"^\s{5}CDS\s+", RegexOptions.Multiline);
            if (cdsHeaderMatch.Success)
            {
                // Read from CDS location start until we hit a line that doesn't start with spaces
                // or starts a /qualifier
                int startIdx = cdsHeaderMatch.Index + cdsHeaderMatch.Length;
                var sb = new StringBuilder();
                int i = startIdx;
                while (i < gbText.Length)
                {
                    int lineEnd = gbText.IndexOf('\n', i);
                    if (lineEnd < 0) lineEnd = gbText.Length;
                    string line = gbText.Substring(i, lineEnd - i).TrimEnd('\r');

                    // Stop if we hit a qualifier or a new feature
                    if (line.Contains("/")) break;
                    if (sb.Length > 0 && line.Length > 0 && !char.IsWhiteSpace(line[0])) break;
                    if (sb.Length > 0 && Regex.IsMatch(line, @"^\s{5}\S")) break;

                    sb.Append(line.Trim());
                    i = lineEnd + 1;
                }

                string content = Regex.Replace(sb.ToString(), @"\s+", "");
                var ranges = Regex.Matches(content, @"<?(\d+)\.\.>?(\d+)");
                int num = 1;
                foreach (Match range in ranges)
                {
                    int s = int.Parse(range.Groups[1].Value);
                    int end = int.Parse(range.Groups[2].Value);
                    _cdsList.Add(new CDSRegion { PartNumber = num++, Start = s, End = end, Length = end - s + 1 });
                }
            }

            // Exons — handle both simple and complement locations
            var exonMatches = Regex.Matches(gbText, @"^\s{5}exon\s+(?:complement\()?<?(\d+)\.\.>?(\d+)\)?", RegexOptions.Multiline);
            int exNum = 1;
            foreach (Match m in exonMatches)
            {
                int s = int.Parse(m.Groups[1].Value);
                int end = int.Parse(m.Groups[2].Value);
                _exonList.Add(new ExonInfo { ExonNumber = exNum++, Start = s, End = end, Length = end - s + 1 });
            }

            _exonList = _exonList.OrderBy(e => e.Start).ToList();
            for (int idx = 0; idx < _exonList.Count; idx++) _exonList[idx].ExonNumber = idx + 1;
        }

        #endregion

        #region === Gene Structure Visualization ===

        private void UpdateGeneVisualization()
        {
            GeneVisualizationCanvas.Children.Clear();
            if (_exonList.Count == 0 && _cdsList.Count == 0 && string.IsNullOrEmpty(_genomicSequence)) return;

            int totalLen = _genomicSequence.Length;
            if (totalLen == 0) return;

            double viewportWidth = Math.Max(GeneVisualizationCanvas.ActualWidth, 800);
            double minScaleViewport = (viewportWidth - 2 * MARGIN) / totalLen;
            double minExonWidth = 15;
            double minScaleExons = _exonList.Count > 0 && _exonList.Min(e => e.Length) > 0
                ? minExonWidth / _exonList.Min(e => e.Length) : minScaleViewport;

            _currentScale = Math.Max(minScaleViewport, Math.Min(minScaleExons, 0.1));
            _currentScale = Math.Max(MIN_SCALE, Math.Min(MAX_SCALE, _currentScale));
            _defaultScale = _currentScale;

            RedrawVisualization();
            GeneInfoLabel.Text = $"{_currentGeneSymbol} | {_currentAccession} | {totalLen:N0} bp | {_exonList.Count} exons | CDS: {_cdsList.Sum(c => c.Length):N0} bp";
        }

        private void RedrawVisualization()
        {
            GeneVisualizationCanvas.Children.Clear();
            if (string.IsNullOrEmpty(_genomicSequence)) return;

            int totalLen = _genomicSequence.Length;
            double viewportWidth = Math.Max(GeneVisualizationScrollViewer?.ViewportWidth ?? 800, 800);
            double canvasWidth = Math.Max(2 * MARGIN + totalLen * _currentScale, viewportWidth);

            GeneVisualizationCanvas.Width = canvasWidth;
            GeneVisualizationCanvas.Height = 105;

            // Backbone
            GeneVisualizationCanvas.Children.Add(new Line
            {
                X1 = MARGIN,
                Y1 = GENE_Y,
                X2 = canvasWidth - MARGIN,
                Y2 = GENE_Y,
                Stroke = Brushes.LightGray,
                StrokeThickness = 2
            });

            // Exons
            foreach (var exon in _exonList)
            {
                double x = MARGIN + (exon.Start - 1) * _currentScale;
                double w = Math.Max(exon.Length * _currentScale, 4);
                var rect = new Rectangle
                {
                    Width = w,
                    Height = 18,
                    Fill = new SolidColorBrush(Color.FromRgb(200, 230, 255)),
                    Stroke = new SolidColorBrush(Color.FromRgb(100, 181, 246)),
                    StrokeThickness = 1,
                    RadiusX = 2,
                    RadiusY = 2,
                    ToolTip = $"Exon {exon.ExonNumber}: {exon.Start:N0}-{exon.End:N0} ({exon.Length:N0} bp)"
                };
                Canvas.SetLeft(rect, x); Canvas.SetTop(rect, GENE_Y - 9);
                GeneVisualizationCanvas.Children.Add(rect);

                if (w > 20)
                {
                    var lbl = new TextBlock { Text = $"E{exon.ExonNumber}", FontSize = 8, Foreground = Brushes.Gray };
                    Canvas.SetLeft(lbl, x + 3); Canvas.SetTop(lbl, GENE_Y - 7);
                    GeneVisualizationCanvas.Children.Add(lbl);
                }
            }

            // CDS
            foreach (var cds in _cdsList)
            {
                double x = MARGIN + (cds.Start - 1) * _currentScale;
                double w = Math.Max(cds.Length * _currentScale, 4);
                var rect = new Rectangle
                {
                    Width = w,
                    Height = 10,
                    Fill = new SolidColorBrush(Color.FromRgb(255, 183, 77)),
                    Stroke = new SolidColorBrush(Color.FromRgb(255, 152, 0)),
                    StrokeThickness = 1,
                    RadiusX = 2,
                    RadiusY = 2,
                    ToolTip = $"CDS {cds.PartNumber}: {cds.Start:N0}-{cds.End:N0}"
                };
                Canvas.SetLeft(rect, x); Canvas.SetTop(rect, GENE_Y - 5);
                GeneVisualizationCanvas.Children.Add(rect);
            }

            // Selection overlay
            if (_selectionStart >= 0 && _selectionEnd >= 0)
                DrawSelectionOverlay();

            DrawScale(canvasWidth, totalLen);

            // Draw primer position markers
            DrawPrimerMarkers();
        }

        private void DrawPrimerMarkers()
        {
            if (_markerFwdStart < 0 && _markerRevStart < 0) return;
            double markerY = GENE_Y + 14; // below the backbone

            if (_markerFwdStart >= 0)
            {
                int genomicPos = _templateOffset + _markerFwdStart;
                double x = MARGIN + genomicPos * _currentScale;
                double w = Math.Max(_markerFwdLen * _currentScale, 6);

                var rect = new Rectangle
                {
                    Width = w,
                    Height = 5,
                    Fill = new SolidColorBrush(Color.FromRgb(25, 118, 210)), // blue
                    RadiusX = 1,
                    RadiusY = 1,
                    ToolTip = $"Forward Primer: {genomicPos + 1}–{genomicPos + _markerFwdLen} ({_markerFwdLen} bp)"
                };
                Canvas.SetLeft(rect, x); Canvas.SetTop(rect, markerY);
                GeneVisualizationCanvas.Children.Add(rect);

                // Arrow head (right-pointing ▶)
                var arrow = new Polygon
                {
                    Points = new PointCollection { new Point(0, 0), new Point(5, 2.5), new Point(0, 5) },
                    Fill = new SolidColorBrush(Color.FromRgb(25, 118, 210))
                };
                Canvas.SetLeft(arrow, x + w); Canvas.SetTop(arrow, markerY);
                GeneVisualizationCanvas.Children.Add(arrow);

                var lbl = new TextBlock { Text = "Fwd", FontSize = 7, Foreground = new SolidColorBrush(Color.FromRgb(25, 118, 210)), FontWeight = FontWeights.Bold };
                Canvas.SetLeft(lbl, x); Canvas.SetTop(lbl, markerY + 6);
                GeneVisualizationCanvas.Children.Add(lbl);
            }

            if (_markerRevStart >= 0)
            {
                int genomicPos = _templateOffset + _markerRevStart;
                double x = MARGIN + genomicPos * _currentScale;
                double w = Math.Max(_markerRevLen * _currentScale, 6);

                var rect = new Rectangle
                {
                    Width = w,
                    Height = 5,
                    Fill = new SolidColorBrush(Color.FromRgb(56, 142, 60)), // green
                    RadiusX = 1,
                    RadiusY = 1,
                    ToolTip = $"Reverse Primer: {genomicPos + 1}–{genomicPos + _markerRevLen} ({_markerRevLen} bp)"
                };
                Canvas.SetLeft(rect, x); Canvas.SetTop(rect, markerY + 16);
                GeneVisualizationCanvas.Children.Add(rect);

                // Arrow head (left-pointing ◀)
                var arrow = new Polygon
                {
                    Points = new PointCollection { new Point(5, 0), new Point(0, 2.5), new Point(5, 5) },
                    Fill = new SolidColorBrush(Color.FromRgb(56, 142, 60))
                };
                Canvas.SetLeft(arrow, x - 5); Canvas.SetTop(arrow, markerY + 16);
                GeneVisualizationCanvas.Children.Add(arrow);

                var lbl = new TextBlock { Text = "Rev", FontSize = 7, Foreground = new SolidColorBrush(Color.FromRgb(56, 142, 60)), FontWeight = FontWeights.Bold };
                Canvas.SetLeft(lbl, x + w - 16); Canvas.SetTop(lbl, markerY + 22);
                GeneVisualizationCanvas.Children.Add(lbl);
            }
        }

        private void DrawScale(double canvasWidth, int totalLen)
        {
            double scaleY = 70;
            int tick = totalLen <= 1000 ? 100 : totalLen <= 5000 ? 500 : totalLen <= 20000 ? 2000 :
                       totalLen <= 100000 ? 10000 : totalLen <= 500000 ? 50000 : 100000;

            for (int pos = 0; pos <= totalLen; pos += tick)
            {
                double x = MARGIN + pos * _currentScale;
                if (x > canvasWidth - MARGIN) break;

                GeneVisualizationCanvas.Children.Add(new Line
                {
                    X1 = x,
                    Y1 = scaleY,
                    X2 = x,
                    Y2 = scaleY + 4,
                    Stroke = Brushes.Gray,
                    StrokeThickness = 1
                });

                string label = pos >= 1000000 ? $"{pos / 1e6:0.#}M" : pos >= 1000 ? $"{pos / 1e3:0.#}k" : pos.ToString();
                var lbl = new TextBlock { Text = label, FontSize = 8, Foreground = Brushes.Gray };
                Canvas.SetLeft(lbl, x - 10); Canvas.SetTop(lbl, scaleY + 5);
                GeneVisualizationCanvas.Children.Add(lbl);
            }
        }

        #endregion

        #region === Canvas Region Selection ===

        private void GeneCanvas_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (string.IsNullOrEmpty(_genomicSequence)) return;
            _isDragging = true;
            _dragStartX = e.GetPosition(GeneVisualizationCanvas).X;
            GeneVisualizationCanvas.CaptureMouse();
        }

        private void GeneCanvas_MouseMove(object sender, MouseEventArgs e)
        {
            if (!_isDragging || string.IsNullOrEmpty(_genomicSequence)) return;

            double currentX = e.GetPosition(GeneVisualizationCanvas).X;
            double startX = Math.Min(_dragStartX, currentX);
            double endX = Math.Max(_dragStartX, currentX);

            int startBp = Math.Max(0, (int)((startX - MARGIN) / _currentScale));
            int endBp = Math.Min(_genomicSequence.Length, (int)((endX - MARGIN) / _currentScale));

            _selectionStart = startBp;
            _selectionEnd = endBp;

            RedrawVisualization();
            SelectedRegionLabel.Text = $"{startBp + 1} – {endBp} ({endBp - startBp} bp)";
        }

        private void GeneCanvas_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (!_isDragging) return;
            _isDragging = false;
            GeneVisualizationCanvas.ReleaseMouseCapture();
            UseSelectedRegionButton.IsEnabled = _selectionStart >= 0 && _selectionEnd > _selectionStart && (_selectionEnd - _selectionStart) >= 20;
        }

        private void DrawSelectionOverlay()
        {
            if (_selectionStart < 0 || _selectionEnd <= _selectionStart) return;

            double x = MARGIN + _selectionStart * _currentScale;
            double w = (_selectionEnd - _selectionStart) * _currentScale;

            var rect = new Rectangle
            {
                Width = Math.Max(w, 2),
                Height = 50,
                Fill = new SolidColorBrush(Color.FromArgb(50, 33, 150, 243)),
                Stroke = new SolidColorBrush(Color.FromRgb(33, 150, 243)),
                StrokeThickness = 1,
                StrokeDashArray = new DoubleCollection { 4, 2 }
            };
            Canvas.SetLeft(rect, x); Canvas.SetTop(rect, GENE_Y - 25);
            GeneVisualizationCanvas.Children.Add(rect);

            // "Stretched to selected region" label
            var label = new TextBlock
            {
                Text = "▸ Stretched to selection",
                FontSize = 9,
                Foreground = new SolidColorBrush(Color.FromRgb(33, 150, 243)),
                FontStyle = FontStyles.Italic
            };
            Canvas.SetLeft(label, x + 2); Canvas.SetTop(label, GENE_Y - 24);
            GeneVisualizationCanvas.Children.Add(label);
        }

        private void UseSelectedRegion_Click(object sender, RoutedEventArgs e)
        {
            if (_selectionStart < 0 || _selectionEnd <= _selectionStart) return;
            int start = Math.Max(0, _selectionStart);
            int end = Math.Min(_genomicSequence.Length, _selectionEnd);
            string region = _genomicSequence.Substring(start, end - start);
            _templateOffset = start;
            SetActiveTemplate(region);
            ShowInfo($"Active template set to region {start + 1}–{end} ({region.Length} bp)", false);
            ActiveTemplateDisplay.BringIntoView();
        }

        private void UseEntireSequence_Click(object sender, RoutedEventArgs e)
        {
            if (!string.IsNullOrEmpty(_genomicSequence))
            {
                _templateOffset = 0;
                SetActiveTemplate(_genomicSequence);
                ActiveTemplateDisplay.BringIntoView();
            }
        }

        #endregion

        #region === Zoom ===

        private void ZoomInButton_Click(object sender, RoutedEventArgs e) => ZoomVisualization(1.5);
        private void ZoomOutButton_Click(object sender, RoutedEventArgs e) => ZoomVisualization(1.0 / 1.5);
        private void ZoomResetButton_Click(object sender, RoutedEventArgs e) { _currentScale = _defaultScale; RedrawVisualization(); }

        private void GeneVisualizationScrollViewer_PreviewMouseWheel(object sender, MouseWheelEventArgs e)
        {
            if (Keyboard.Modifiers == ModifierKeys.Control)
            {
                ZoomVisualization(e.Delta > 0 ? 1.2 : 1.0 / 1.2);
                e.Handled = true;
            }
            else
            {
                var sv = sender as ScrollViewer;
                sv?.ScrollToHorizontalOffset(sv.HorizontalOffset - e.Delta);
                e.Handled = true;
            }
        }

        private void ZoomVisualization(double factor)
        {
            if (string.IsNullOrEmpty(_genomicSequence)) return;
            double newScale = Math.Max(MIN_SCALE, Math.Min(MAX_SCALE, _currentScale * factor));
            if (Math.Abs(newScale - _currentScale) < 0.0001) return;
            _currentScale = newScale;
            RedrawVisualization();
        }

        #endregion

        #region === Set Active Template (auto-switch to AutoPick when template exists) ===

        private void SetActiveTemplate(string seq)
        {
            _activeTemplate = seq;
            ActiveTemplateDisplay.Text = seq.Length > 500 ? seq.Substring(0, 500) + "..." : seq;
            ActiveTemplateLengthLabel.Text = $"Active template: {seq.Length:N0} bp";

            // Auto-switch to Auto-Pick mode when template is loaded
            if (seq.Length >= 50)
            {
                AutoModeRadio.IsChecked = true;
            }
        }

        #endregion

        #region === Design Mode Toggle ===

        private void DesignMode_Changed(object sender, RoutedEventArgs e)
        {
            if (ManualInputPanel == null || AutoDesignPanel == null) return;
            bool isManual = ManualModeRadio.IsChecked == true;
            ManualInputPanel.Visibility = isManual ? Visibility.Visible : Visibility.Collapsed;
            AutoDesignPanel.Visibility = isManual ? Visibility.Collapsed : Visibility.Visible;
        }

        #endregion

        #region === RE Checkbox in Auto-Pick ===

        private void AutoPickRECheckBox_Changed(object sender, RoutedEventArgs e)
        {
            if (AutoPickREPanel == null) return;
            AutoPickREPanel.Visibility = AutoPickRECheckBox.IsChecked == true ? Visibility.Visible : Visibility.Collapsed;
        }

        #endregion

        #region === Manual Primer Analysis (with find-missing-strand) ===

        private void UpdateIonConcentrations()
        {
            if (double.TryParse(NaConcInput.Text, out double na) && na > 0) _naConc = na / 1000.0; // mM → M
            if (double.TryParse(MgConcInput.Text, out double mg) && mg >= 0) _mgConc = mg / 1000.0;
            if (double.TryParse(DntpConcInput.Text, out double dntp) && dntp >= 0) _dntpConc = dntp / 1000.0;
            if (double.TryParse(PrimerConcInput.Text, out double pc) && pc > 0) _primerConc = pc * 1e-9; // nM → M
        }

        private void AnalyzePrimers_Click(object sender, RoutedEventArgs e)
        {
            UpdateIonConcentrations();
            string fwd = CleanSequence(ForwardPrimerInput.Text);
            string rev = CleanSequence(ReversePrimerInput.Text);

            if (string.IsNullOrEmpty(fwd) && string.IsNullOrEmpty(rev))
            {
                MessageBox.Show("Please enter at least one primer.", "Input Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            // If one primer is missing and we have a template, try to find the complementary strand
            if (!string.IsNullOrEmpty(_activeTemplate) && (string.IsNullOrEmpty(fwd) || string.IsNullOrEmpty(rev)))
            {
                FindMissingStrand(ref fwd, ref rev);
            }

            _lastFwdPrimer = fwd;
            _lastRevPrimer = rev;

            PrimerAnalysis fwdA = null, revA = null;

            if (!string.IsNullOrEmpty(fwd))
            {
                fwdA = AnalyzePrimer(fwd);
                DisplayPrimerResult(fwdA, FwdSequenceDisplay, FwdLength, FwdTm, FwdGC, FwdMW, FwdGCClamp, FwdSelfComp, FwdHairpin, FwdEndStability, FwdWarnings, FwdSelfDimerDG, FwdHairpinDG, FwdAnyComp);
            }
            else ClearPrimerDisplay(FwdSequenceDisplay, FwdLength, FwdTm, FwdGC, FwdMW, FwdGCClamp, FwdSelfComp, FwdHairpin, FwdEndStability, FwdWarnings, FwdSelfDimerDG, FwdHairpinDG, FwdAnyComp);

            if (!string.IsNullOrEmpty(rev))
            {
                revA = AnalyzePrimer(rev);
                DisplayPrimerResult(revA, RevSequenceDisplay, RevLength, RevTm, RevGC, RevMW, RevGCClamp, RevSelfComp, RevHairpin, RevEndStability, RevWarnings, RevSelfDimerDG, RevHairpinDG, RevAnyComp);
            }
            else ClearPrimerDisplay(RevSequenceDisplay, RevLength, RevTm, RevGC, RevMW, RevGCClamp, RevSelfComp, RevHairpin, RevEndStability, RevWarnings, RevSelfDimerDG, RevHairpinDG, RevAnyComp);

            if (fwdA != null && revA != null)
            {
                DisplayPairSummary(fwdA, revA, _activeTemplate);
                PairSummaryPanel.Visibility = Visibility.Visible;
            }
            else PairSummaryPanel.Visibility = Visibility.Collapsed;

            if (!string.IsNullOrEmpty(_activeTemplate) && (fwdA != null || revA != null))
            {
                GenerateSequenceVisualization(_activeTemplate, fwd, rev);
                SequenceViewPanel.Visibility = Visibility.Visible;
            }
            else SequenceViewPanel.Visibility = Visibility.Collapsed;

            AutoResultsPanel.Visibility = Visibility.Collapsed;
            UpdateREPreview();
        }

        /// <summary>
        /// When one primer is provided and the other is empty, search the template for
        /// the best complementary primer matching the user's criteria.
        /// Searches ALL binding sites on the template (not just the first), to handle
        /// non-unique sequences and find the globally best pairing.
        /// </summary>
        private void FindMissingStrand(ref string fwd, ref string rev)
        {
            if (!double.TryParse(ManualTargetTmInput.Text, out double targetTm)) targetTm = 60;
            if (!double.TryParse(ManualTmToleranceInput.Text, out double tmTol)) tmTol = 3;
            if (!int.TryParse(ManualTargetProductInput.Text, out int targetProduct)) targetProduct = 300;
            if (!int.TryParse(ManualProductToleranceInput.Text, out int productTol)) productTol = 200;

            string template = _activeTemplate;
            bool findingReverse = !string.IsNullOrEmpty(fwd) && string.IsNullOrEmpty(rev);
            bool findingForward = string.IsNullOrEmpty(fwd) && !string.IsNullOrEmpty(rev);

            if (findingReverse)
            {
                // Find ALL forward primer positions on template
                var fwdPositions = FindAllOccurrences(template, fwd);
                if (fwdPositions.Count == 0)
                {
                    ShowInfo("Forward primer not found on template. Cannot find complementary reverse primer.", true);
                    return;
                }

                PrimerAnalysis bestA = null;
                string bestSeq = "";
                double bestScore = double.MinValue;

                foreach (int fwdPos in fwdPositions)
                {
                    int minEnd = fwdPos + fwd.Length + targetProduct - productTol;
                    int maxEnd = Math.Min(template.Length, fwdPos + fwd.Length + targetProduct + productTol);

                    for (int end = Math.Max(minEnd, fwdPos + fwd.Length + 50); end <= maxEnd; end++)
                    {
                        for (int len = 18; len <= 25 && end - len >= 0; len++)
                        {
                            string region = template.Substring(end - len, len);
                            string rc = GetReverseComplement(region);
                            var a = AnalyzePrimer(rc);

                            if (Math.Abs(a.Tm - targetTm) > tmTol) continue;
                            if (a.GCPercent < 30 || a.GCPercent > 70) continue;

                            int prod = end - fwdPos;
                            double score = 100 - Math.Abs(a.Tm - targetTm) * 3 - Math.Abs(prod - targetProduct) * 0.1
                                - a.SelfComplementarityScore * 2 - a.HairpinScore * 3;

                            if (score > bestScore)
                            {
                                bestScore = score;
                                bestA = a;
                                bestSeq = rc;
                            }
                        }
                    }
                }

                if (bestA != null)
                {
                    rev = bestSeq;
                    ReversePrimerInput.Text = rev;
                    string siteMsg = fwdPositions.Count > 1 ? $" ({fwdPositions.Count} binding sites evaluated)" : "";
                    ShowInfo($"Found complementary reverse primer: {rev} (Tm={bestA.Tm:F1}°C){siteMsg}", false);
                }
                else
                {
                    ShowInfo("No reverse primer found matching criteria. Try adjusting parameters.", true);
                }
            }
            else if (findingForward)
            {
                string revRC = GetReverseComplement(rev);
                var revPositions = FindAllOccurrences(template, revRC);
                if (revPositions.Count == 0)
                {
                    ShowInfo("Reverse primer not found on template. Cannot find complementary forward primer.", true);
                    return;
                }

                PrimerAnalysis bestA = null;
                string bestSeq = "";
                double bestScore = double.MinValue;

                foreach (int revPos in revPositions)
                {
                    int maxStart = revPos - targetProduct + productTol;
                    int minStart = Math.Max(0, revPos - targetProduct - productTol);

                    for (int start = minStart; start <= Math.Min(maxStart, revPos - 50); start++)
                    {
                        for (int len = 18; len <= 25 && start + len <= template.Length; len++)
                        {
                            string seq = template.Substring(start, len);
                            var a = AnalyzePrimer(seq);

                            if (Math.Abs(a.Tm - targetTm) > tmTol) continue;
                            if (a.GCPercent < 30 || a.GCPercent > 70) continue;

                            int prod = revPos + revRC.Length - start;
                            double score = 100 - Math.Abs(a.Tm - targetTm) * 3 - Math.Abs(prod - targetProduct) * 0.1
                                - a.SelfComplementarityScore * 2 - a.HairpinScore * 3;

                            if (score > bestScore)
                            {
                                bestScore = score;
                                bestA = a;
                                bestSeq = seq;
                            }
                        }
                    }
                }

                if (bestA != null)
                {
                    fwd = bestSeq;
                    ForwardPrimerInput.Text = fwd;
                    string siteMsg = revPositions.Count > 1 ? $" ({revPositions.Count} binding sites evaluated)" : "";
                    ShowInfo($"Found complementary forward primer: {fwd} (Tm={bestA.Tm:F1}°C){siteMsg}", false);
                }
                else
                {
                    ShowInfo("No forward primer found matching criteria. Try adjusting parameters.", true);
                }
            }
        }

        /// <summary>Find all occurrences of a subsequence in a template string.</summary>
        private List<int> FindAllOccurrences(string template, string query)
        {
            var positions = new List<int>();
            int idx = 0;
            while ((idx = template.IndexOf(query, idx, StringComparison.Ordinal)) >= 0)
            {
                positions.Add(idx);
                idx++; // allow overlapping matches
            }
            return positions;
        }

        #endregion

        #region === Auto Primer Picking (with target values + RE integration) ===

        private CancellationTokenSource _autoPickCts;

        private async void AutoPickPrimers_Click(object sender, RoutedEventArgs e)
        {
            UpdateIonConcentrations();
            string template = _activeTemplate;
            if (string.IsNullOrEmpty(template) || template.Length < 50)
            {
                MessageBox.Show("Load or enter a template (≥50 bp) first.", "Input Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            // Cancel previous auto-pick if still running
            _autoPickCts?.Cancel();
            _autoPickCts = new CancellationTokenSource();
            var ct = _autoPickCts.Token;

            if (!int.TryParse(MinLengthInput.Text, out int minLen)) minLen = 18;
            if (!int.TryParse(MaxLengthInput.Text, out int maxLen)) maxLen = 25;
            if (!double.TryParse(MinTmInput.Text, out double minTm)) minTm = 55;
            if (!double.TryParse(MaxTmInput.Text, out double maxTm)) maxTm = 65;
            if (!double.TryParse(TargetTmInput.Text, out double targetTm)) targetTm = 60;
            if (!int.TryParse(MinProductInput.Text, out int minProd)) minProd = 100;
            if (!int.TryParse(MaxProductInput.Text, out int maxProd)) maxProd = 1000;
            if (!int.TryParse(TargetProductInput.Text, out int targetProd)) targetProd = 300;
            if (!double.TryParse(MaxTmDiffInput.Text, out double maxTmDiff)) maxTmDiff = 3;
            bool gcClamp = GcClampCheckBox.IsChecked == true;
            bool penalizeSelfComp = SelfCompCheckBox.IsChecked == true;

            // RE integration
            bool includeRE = AutoPickRECheckBox.IsChecked == true;
            string fwdRESeq = includeRE ? GetSelectedRESequence(AutoFwdREComboBox) : "";
            string revRESeq = includeRE ? GetSelectedRESequence(AutoRevREComboBox) : "";

            ShowLoading(true, "Scanning primer candidates...");
            await Task.Delay(10); // let UI update

            List<PrimerPairResult> top = null;
            int totalResults = 0;

            try
            {
                top = await Task.Run(() =>
                {
                    // ════════════════════════════════════════════════════════════
                    // PHASE 1: Fast candidate generation using lightweight analysis
                    // AnalyzePrimerFast only computes: Tm, GC%, GCClamp, SelfComp, HairpinScore
                    // Skips expensive O(n²/n³): SelfDimerΔG, HairpinΔG, AnyComp, EndStability, MW
                    // This alone provides ~5-8x speedup over full AnalyzePrimer
                    // ════════════════════════════════════════════════════════════

                    var fwdCands = new List<(int start, PrimerAnalysis a)>();
                    for (int s = 0; s <= template.Length - minLen; s++)
                    {
                        ct.ThrowIfCancellationRequested();
                        for (int len = minLen; len <= maxLen && s + len <= template.Length; len++)
                        {
                            var a = AnalyzePrimerFast(template.Substring(s, len));
                            if (a.Tm < minTm || a.Tm > maxTm) continue;
                            if (gcClamp && !a.HasGCClamp) continue;
                            if (a.GCPercent < 30 || a.GCPercent > 70) continue;
                            fwdCands.Add((s, a));
                        }
                    }

                    var revCands = new List<(int start, PrimerAnalysis a)>();
                    for (int end = minLen; end <= template.Length; end++)
                    {
                        ct.ThrowIfCancellationRequested();
                        for (int len = minLen; len <= maxLen && end - len >= 0; len++)
                        {
                            string rc = GetReverseComplement(template.Substring(end - len, len));
                            var a = AnalyzePrimerFast(rc);
                            if (a.Tm < minTm || a.Tm > maxTm) continue;
                            if (gcClamp && !a.HasGCClamp) continue;
                            if (a.GCPercent < 30 || a.GCPercent > 70) continue;
                            revCands.Add((end - len, a));
                        }
                    }

                    // Sort reverse candidates by start position for binary search
                    revCands.Sort((a, b) => a.start.CompareTo(b.start));
                    var revStarts = revCands.Select(r => r.start).ToArray();

                    // ════════════════════════════════════════════════════════════
                    // PHASE 2: Fast pairing with sliding window + running Top-K
                    // Uses cheap score (no HeteroDimer) for initial ranking,
                    // then refines only the top candidates with expensive checks.
                    // ════════════════════════════════════════════════════════════

                    // Collect candidate pairs with cheap score (skip HeteroDimer in initial pass)
                    const int TOP_K = 50; // keep top-50 for refinement
                    var topPairs = new List<(int fStart, PrimerAnalysis fA, int rStart, PrimerAnalysis rA, int prod, double cheapScore)>();
                    double worstKeptScore = double.MinValue;

                    foreach (var f in fwdCands)
                    {
                        ct.ThrowIfCancellationRequested();
                        int rMin = f.start + minProd - maxLen;
                        int rMax = f.start + maxProd - minLen;

                        int lo = Array.BinarySearch(revStarts, rMin);
                        if (lo < 0) lo = ~lo;

                        for (int ri = lo; ri < revCands.Count && revCands[ri].start <= rMax; ri++)
                        {
                            var r = revCands[ri];
                            int prod = r.start + r.a.Length - f.start;
                            if (prod < minProd || prod > maxProd) continue;

                            double td = Math.Abs(f.a.Tm - r.a.Tm);
                            if (td > maxTmDiff) continue;

                            // Cheap score — no HeteroDimer, no SelfDimerΔG
                            double score = 100.0;
                            score -= td * 3.0;
                            score -= Math.Abs(targetTm - f.a.Tm) * 1.5;
                            score -= Math.Abs(targetTm - r.a.Tm) * 1.5;
                            score -= Math.Abs(targetProd - prod) * 0.02;
                            score -= Math.Abs(50 - f.a.GCPercent) * 0.5;
                            score -= Math.Abs(50 - r.a.GCPercent) * 0.5;
                            score -= f.a.HairpinScore * 3.0;
                            score -= r.a.HairpinScore * 3.0;
                            if (penalizeSelfComp)
                            {
                                score -= f.a.SelfComplementarityScore * 2.0;
                                score -= r.a.SelfComplementarityScore * 2.0;
                            }

                            // Early prune: skip if clearly below current top-K threshold
                            if (topPairs.Count >= TOP_K && score < worstKeptScore - 20.0) continue;

                            topPairs.Add((f.start, f.a, r.start, r.a, prod, score));

                            // Periodically trim to keep memory bounded
                            if (topPairs.Count > TOP_K * 4)
                            {
                                topPairs.Sort((x, y) => y.cheapScore.CompareTo(x.cheapScore));
                                topPairs.RemoveRange(TOP_K * 2, topPairs.Count - TOP_K * 2);
                                worstKeptScore = topPairs[topPairs.Count - 1].cheapScore;
                            }
                        }
                    }

                    // ════════════════════════════════════════════════════════════
                    // PHASE 3: Refine top candidates with expensive calculations
                    // Only ~50-100 pairs get HeteroDimer + SelfDimerΔG scoring
                    // ════════════════════════════════════════════════════════════

                    topPairs.Sort((x, y) => y.cheapScore.CompareTo(x.cheapScore));
                    if (topPairs.Count > TOP_K) topPairs.RemoveRange(TOP_K, topPairs.Count - TOP_K);

                    totalResults = topPairs.Count;
                    var results = new List<PrimerPairResult>(topPairs.Count);

                    foreach (var p in topPairs)
                    {
                        ct.ThrowIfCancellationRequested();
                        int hd = CalculateHeteroDimer(p.fA.Sequence, p.rA.Sequence);

                        double score = p.cheapScore;
                        score -= hd * 2.0;

                        if (penalizeSelfComp)
                        {
                            // Compute SelfDimerΔG only now for the finalists
                            double fDimerDG = CalculateSelfDimerDeltaG(p.fA.Sequence);
                            double rDimerDG = CalculateSelfDimerDeltaG(p.rA.Sequence);
                            if (fDimerDG < -5.0) score -= Math.Abs(fDimerDG + 5.0) * 2.0;
                            if (rDimerDG < -5.0) score -= Math.Abs(rDimerDG + 5.0) * 2.0;
                        }

                        string fwdDisplay = p.fA.Sequence;
                        string revDisplay = p.rA.Sequence;

                        if (includeRE)
                        {
                            string prot = GetProtectiveSequence(2);
                            if (!string.IsNullOrEmpty(fwdRESeq))
                                fwdDisplay = $"{prot}{fwdRESeq}-{p.fA.Sequence}";
                            if (!string.IsNullOrEmpty(revRESeq))
                                revDisplay = $"{prot}{revRESeq}-{p.rA.Sequence}";
                        }

                        results.Add(new PrimerPairResult
                        {
                            ForwardSequence = p.fA.Sequence,
                            ReverseSequence = p.rA.Sequence,
                            ForwardDisplay = fwdDisplay,
                            ReverseDisplay = revDisplay,
                            ForwardTm = p.fA.Tm,
                            ReverseTm = p.rA.Tm,
                            TmDiff = Math.Abs(p.fA.Tm - p.rA.Tm),
                            ProductSize = p.prod,
                            Score = score,
                            FwdStart = p.fStart,
                            RevStart = p.rStart
                        });
                    }

                    var ranked = results.OrderByDescending(r => r.Score).Take(20).ToList();
                    for (int i = 0; i < ranked.Count; i++) ranked[i].Rank = i + 1;
                    return ranked;
                }, ct);
            }
            catch (OperationCanceledException) { return; }
            finally
            {
                ShowLoading(false);
            }

            if (top == null || top.Count == 0)
            {
                MessageBox.Show("No primer pairs match criteria. Try widening parameters.", "No Results", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            AutoResultsDataGrid.ItemsSource = top;
            AutoResultsInfo.Text = $"Found {totalResults:N0} valid pairs, showing top {top.Count}. (Target Tm: {targetTm}°C, Target product: {targetProd} bp)";
            AutoResultsPanel.Visibility = Visibility.Visible;
            AutoResultsDataGrid.SelectedIndex = 0;
        }

        private string GetProtectiveSequence(int count)
        {
            string[] opts = { "", "GC", "GCGC", "ATAT", "GG", "CC", "GCGCGC" };
            return count > 0 && count < opts.Length ? opts[count] : new string('G', count);
        }

        private void AutoResultsDataGrid_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (AutoResultsDataGrid.SelectedItem is PrimerPairResult sel)
            {
                _lastFwdPrimer = sel.ForwardSequence;
                _lastRevPrimer = sel.ReverseSequence;

                var fwd = AnalyzePrimer(sel.ForwardSequence);
                DisplayPrimerResult(fwd, FwdSequenceDisplay, FwdLength, FwdTm, FwdGC, FwdMW, FwdGCClamp, FwdSelfComp, FwdHairpin, FwdEndStability, FwdWarnings, FwdSelfDimerDG, FwdHairpinDG, FwdAnyComp);
                var rev = AnalyzePrimer(sel.ReverseSequence);
                DisplayPrimerResult(rev, RevSequenceDisplay, RevLength, RevTm, RevGC, RevMW, RevGCClamp, RevSelfComp, RevHairpin, RevEndStability, RevWarnings, RevSelfDimerDG, RevHairpinDG, RevAnyComp);

                DisplayPairSummary(fwd, rev, _activeTemplate);
                PairSummaryPanel.Visibility = Visibility.Visible;

                if (!string.IsNullOrEmpty(_activeTemplate))
                {
                    GenerateSequenceVisualization(_activeTemplate, sel.ForwardSequence, sel.ReverseSequence);
                    SequenceViewPanel.Visibility = Visibility.Visible;
                }

                // Update primer markers on gene visualization
                _markerFwdStart = sel.FwdStart;
                _markerFwdLen = sel.ForwardSequence.Length;
                _markerRevStart = sel.RevStart;
                _markerRevLen = sel.ReverseSequence.Length;
                if (GeneVisualizationPanel.Visibility == Visibility.Visible)
                    RedrawVisualization();

                UpdateREPreview();
            }
        }

        private void AutoResultsDataGrid_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            // Double-click scrolls to the guide panel for reference
            ParameterDetailPanel.BringIntoView();
        }

        private void ScrollToGuide_Click(object sender, MouseButtonEventArgs e)
        {
            ParameterDetailPanel.BringIntoView();
        }

        #endregion

        #region === Restriction Enzyme Overhang ===

        private void REComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e) => UpdateREPreview();

        private void UpdateREPreview()
        {
            if (FwdWithREPreview == null) return;

            string fwd = _lastFwdPrimer;
            string rev = _lastRevPrimer;

            if (string.IsNullOrEmpty(fwd) && string.IsNullOrEmpty(rev))
            {
                FwdWithREPreview.Text = "";
                RevWithREPreview.Text = "";
                return;
            }

            if (!int.TryParse(ProtectiveBasesInput?.Text ?? "2", out int protBases)) protBases = 2;
            string protPrefix = GetProtectiveSequence(protBases);

            string fwdRE = GetSelectedRESequence(AutoFwdREComboBox);
            string revRE = GetSelectedRESequence(AutoRevREComboBox);

            FwdWithREPreview.Text = !string.IsNullOrEmpty(fwd) ? $"Fwd: 5'-{protPrefix}{fwdRE}{fwd}-3'" : "";
            RevWithREPreview.Text = !string.IsNullOrEmpty(rev) ? $"Rev: 5'-{protPrefix}{revRE}{rev}-3'" : "";
        }

        private string GetSelectedRESequence(ComboBox combo)
        {
            if (combo.SelectedItem == null) return "";
            string sel = combo.SelectedItem.ToString();
            if (sel == "(None)" || sel.StartsWith("──")) return "";

            var match = Regex.Match(sel, @"^(\S+)\s+\((\S+)\)");
            return match.Success ? match.Groups[2].Value : "";
        }

        private void CopyPrimersWithRE_Click(object sender, RoutedEventArgs e)
        {
            var sb = new StringBuilder();
            if (!string.IsNullOrEmpty(FwdWithREPreview.Text)) sb.AppendLine(FwdWithREPreview.Text);
            if (!string.IsNullOrEmpty(RevWithREPreview.Text)) sb.AppendLine(RevWithREPreview.Text);
            if (sb.Length > 0)
            {
                Clipboard.SetText(sb.ToString());
                ShowInfo("Primers with RE tails copied to clipboard.", false);
            }
        }

        #endregion

        #region === Core Primer Analysis ===

        private PrimerAnalysis AnalyzePrimer(string sequence)
        {
            var a = new PrimerAnalysis
            {
                Sequence = sequence,
                Length = sequence.Length,
                Tm = CalculateTm(sequence),
                GCPercent = CalculateGCPercent(sequence),
                MolecularWeight = CalculateMolecularWeight(sequence),
                HasGCClamp = CheckGCClamp(sequence),
                SelfComplementarityScore = CalculateSelfComplementarity(sequence),
                HairpinScore = CalculateHairpinScore(sequence),
                EndStabilityDeltaG = CalculateEndStability(sequence),
                SelfDimerDeltaG = CalculateSelfDimerDeltaG(sequence),
                HairpinDeltaG = CalculateHairpinDeltaG(sequence),
                AnyCompScore = CalculateAnyComplementarity(sequence)
            };

            if (a.Length < 18) a.Warnings.Add("⚠ Too short (<18 bp).");
            if (a.Length > 30) a.Warnings.Add("⚠ Too long (>30 bp).");
            if (a.Tm < 50) a.Warnings.Add("⚠ Tm too low (<50°C).");
            if (a.Tm > 70) a.Warnings.Add("⚠ Tm too high (>70°C).");
            if (a.GCPercent < 30) a.Warnings.Add("⚠ GC% too low (<30%).");
            if (a.GCPercent > 70) a.Warnings.Add("⚠ GC% too high (>70%).");
            if (!a.HasGCClamp) a.Warnings.Add("⚠ No GC clamp at 3'.");
            if (a.SelfComplementarityScore >= 4) a.Warnings.Add("⚠ High self-complementarity.");
            if (a.HairpinScore >= 3) a.Warnings.Add("⚠ Potential hairpin.");
            if (a.SelfDimerDeltaG < -6.0) a.Warnings.Add($"⚠ Stable self-dimer (ΔG={a.SelfDimerDeltaG:F1} kcal/mol).");
            if (a.HairpinDeltaG < -3.0) a.Warnings.Add($"⚠ Stable hairpin (ΔG={a.HairpinDeltaG:F1} kcal/mol).");
            if (HasRepeats(sequence)) a.Warnings.Add("⚠ Mononucleotide run ≥4.");

            return a;
        }

        /// <summary>
        /// Lightweight primer analysis for Auto-Pick candidate screening.
        /// Only computes Tm, GC%, GCClamp, and simple scoring metrics (SelfComp + HairpinScore).
        /// Skips expensive ΔG calculations (SelfDimer, Hairpin, AnyComp, MW, EndStability, Warnings).
        /// Full analysis is deferred to AnalyzePrimer() for the final top-N candidates only.
        /// Speedup: ~5-10x per candidate (eliminates O(n²/n³) ΔG inner loops for ~80% of candidates).
        /// </summary>
        private PrimerAnalysis AnalyzePrimerFast(string sequence)
        {
            return new PrimerAnalysis
            {
                Sequence = sequence,
                Length = sequence.Length,
                Tm = CalculateTm(sequence),
                GCPercent = CalculateGCPercent(sequence),
                HasGCClamp = CheckGCClamp(sequence),
                SelfComplementarityScore = CalculateSelfComplementarity(sequence),
                HairpinScore = CalculateHairpinScore(sequence)
            };
        }

        /// <summary>
        /// Tm — Nearest-Neighbor (SantaLucia 1998, PNAS 95:1460-1465)
        /// Short oligos (&lt;14 nt): Wallace Rule Tm = 2(A+T) + 4(G+C)
        /// Uses static NN arrays for zero allocation in hot path.
        /// </summary>
        private double CalculateTm(string seq)
        {
            int N = seq.Length;
            if (N == 0) return 0;

            // Count GC for all paths
            int gcCount = 0;
            for (int i = 0; i < N; i++) if (seq[i] == 'G' || seq[i] == 'C') gcCount++;

            if (N < 14) return 2.0 * (N - gcCount) + 4.0 * gcCount;

            double totalH = 0, totalS = 0;
            // Initiation parameters
            char first = seq[0], last = seq[N - 1];
            if (first == 'G' || first == 'C') { totalH += 0.1; totalS += -2.8; } else { totalH += 2.3; totalS += 4.1; }
            if (last == 'G' || last == 'C') { totalH += 0.1; totalS += -2.8; } else { totalH += 2.3; totalS += 4.1; }

            // NN sum — zero allocation, direct array lookup
            for (int i = 0; i < N - 1; i++)
            {
                int b1 = _baseIdx[seq[i]], b2 = _baseIdx[seq[i + 1]];
                if (b1 >= 0 && b2 >= 0) { int idx = b1 * 4 + b2; totalH += _nnH[idx]; totalS += _nnS[idx]; }
            }

            double R = 1.987;
            double tm1M = (totalH * 1000) / (totalS + R * Math.Log(_primerConc / 4.0));
            double fGC = (double)gcCount / N;
            double freeMg = Math.Max(0, _mgConc - _dntpConc);

            if (freeMg > 0 && _naConc > 0)
            {
                double ratio = Math.Sqrt(freeMg) / _naConc;
                double lnMg = Math.Log(freeMg);
                double invTm;

                if (ratio < 0.22)
                {
                    invTm = Owczarzy2004InvTm(tm1M, fGC, _naConc);
                }
                else if (ratio < 6.0)
                {
                    double lnMon = Math.Log(_naConc);
                    double a = 3.92e-5 * (0.843 - 0.352 * Math.Sqrt(_naConc) * lnMon);
                    double b = -9.11e-6;
                    double c = 6.26e-5;
                    double d = 1.42e-5 * (1.279 - 4.03e-3 * lnMon - 8.03e-3 * lnMon * lnMon);
                    double e2 = -4.82e-4;
                    double f = 5.25e-4;
                    double g2 = 8.31e-5 * (0.486 - 0.258 * lnMon + 5.25e-3 * lnMon * lnMon * lnMon);
                    invTm = 1.0 / tm1M + a + b * lnMg + fGC * (c + d * lnMg)
                            + (1.0 / (2.0 * (N - 1))) * (e2 + f * lnMg + g2 * lnMg * lnMg);
                }
                else
                {
                    double a = 3.92e-5, b = -9.11e-6, c = 6.26e-5, d = 1.42e-5;
                    double e2 = -4.82e-4, f = 5.25e-4, g2 = 8.31e-5;
                    invTm = 1.0 / tm1M + a + b * lnMg + fGC * (c + d * lnMg)
                            + (1.0 / (2.0 * (N - 1))) * (e2 + f * lnMg + g2 * lnMg * lnMg);
                }
                return Math.Round(1.0 / invTm - 273.15, 1);
            }
            else if (_naConc > 0)
            {
                double invTm = Owczarzy2004InvTm(tm1M, fGC, _naConc);
                return Math.Round(1.0 / invTm - 273.15, 1);
            }
            else
            {
                double saltS = totalS + 0.368 * (N - 1) * Math.Log(0.05);
                double tm = (totalH * 1000) / (saltS + R * Math.Log(_primerConc / 4.0)) - 273.15;
                return Math.Round(tm, 1);
            }
        }

        /// <summary>Owczarzy 2004 monovalent salt correction (returns 1/Tm in Kelvin)</summary>
        private double Owczarzy2004InvTm(double tm1M_K, double fGC, double naConc)
        {
            double lnNa = Math.Log(naConc);
            return 1.0 / tm1M_K + (4.29 * fGC - 3.95) * 1e-5 * lnNa + 9.40e-6 * lnNa * lnNa;
        }

        private double CalculateGCPercent(string seq)
        {
            if (seq.Length == 0) return 0;
            int gc = 0;
            for (int i = 0; i < seq.Length; i++) if (seq[i] == 'G' || seq[i] == 'C') gc++;
            return Math.Round(100.0 * gc / seq.Length, 1);
        }

        private double CalculateMolecularWeight(string seq)
        {
            if (seq.Length == 0) return 0;
            double mw = 0;
            foreach (char c in seq)
            {
                switch (c)
                {
                    case 'A': mw += 331.2; break;
                    case 'T': mw += 322.2; break;
                    case 'G': mw += 347.2; break;
                    case 'C': mw += 307.2; break;
                    default: mw += 326.9; break;
                }
            }
            return Math.Round(mw - (seq.Length - 1) * 18.0 + 79.0, 1);
        }

        private bool CheckGCClamp(string seq) => seq.Length > 0 && (seq[seq.Length - 1] == 'G' || seq[seq.Length - 1] == 'C');

        private int CalculateSelfComplementarity(string seq)
        {
            if (seq.Length < 4) return 0;
            string rc = GetReverseComplement(seq);
            int max = 0;
            for (int off = 0; off < seq.Length * 2 - 1; off++)
            {
                int cons = 0, best = 0;
                for (int i = 0; i < seq.Length; i++)
                {
                    int j = i - (off - seq.Length + 1);
                    if (j >= 0 && j < rc.Length && IsComplement(seq[i], rc[j])) { cons++; best = Math.Max(best, cons); }
                    else cons = 0;
                }
                max = Math.Max(max, best);
            }
            return max;
        }

        private int CalculateHairpinScore(string seq)
        {
            if (seq.Length < 8) return 0;
            int max = 0;
            for (int ls = 3; ls < seq.Length - 3; ls++)
                for (int ll = 3; ll <= 8 && ls + ll < seq.Length; ll++)
                {
                    int stemLen = Math.Min(ls, seq.Length - ls - ll);
                    int m = 0;
                    for (int k = 0; k < stemLen; k++)
                    {
                        if (IsComplement(seq[ls - 1 - k], seq[ls + ll + k])) m++; else break;
                    }
                    max = Math.Max(max, m);
                }
            return max;
        }

        private double CalculateEndStability(string seq)
        {
            if (seq.Length < 5) return 0;
            double total = 0;
            int start = seq.Length - 5;
            for (int i = start; i < seq.Length - 1; i++)
            {
                int b1 = _baseIdx[seq[i]], b2 = _baseIdx[seq[i + 1]];
                if (b1 >= 0 && b2 >= 0) total += _nnG[b1 * 4 + b2];
            }
            return Math.Round(total, 2);
        }

        /// <summary>
        /// Self-Dimer ΔG — Thermodynamic stability of primer self-dimer
        /// Slides the primer against its own reverse complement at every possible offset.
        /// For each alignment, finds all runs of ≥2 consecutive Watson-Crick base pairs,
        /// sums their NN ΔG values, and adds initiation penalty (+1.96 kcal/mol per duplex).
        /// Returns the most negative (most stable) ΔG across all alignments.
        /// Reference: SantaLucia (1998) PNAS 95:1460-1465
        /// </summary>
        private double CalculateSelfDimerDeltaG(string seq)
        {
            if (seq.Length < 4) return 0;
            string rc = GetReverseComplement(seq);
            double worstDG = 0; // most negative = most stable

            for (int offset = -(seq.Length - 2); offset <= seq.Length - 2; offset++)
            {
                int i0 = Math.Max(0, offset);
                int j0 = Math.Max(0, -offset);
                int runLen = 0;
                double runDG = 0;
                double bestRunDG = 0;

                for (int k = 0; i0 + k < seq.Length && j0 + k < rc.Length; k++)
                {
                    if (IsComplement(seq[i0 + k], rc[j0 + k]))
                    {
                        runLen++;
                        if (runLen >= 2)
                        {
                            int b1 = _baseIdx[seq[i0 + k - 1]], b2 = _baseIdx[seq[i0 + k]];
                            if (b1 >= 0 && b2 >= 0) runDG += _nnG[b1 * 4 + b2];
                        }
                    }
                    else
                    {
                        if (runLen >= 2)
                        {
                            double dg = runDG + 1.96;
                            if (dg < bestRunDG) bestRunDG = dg;
                        }
                        runLen = 0; runDG = 0;
                    }
                }
                if (runLen >= 2)
                {
                    double dg = runDG + 1.96;
                    if (dg < bestRunDG) bestRunDG = dg;
                }
                if (bestRunDG < worstDG) worstDG = bestRunDG;
            }
            return Math.Round(worstDG, 2);
        }

        /// <summary>
        /// Hairpin ΔG — Thermodynamic stability of intramolecular hairpin
        /// Tests all possible loop positions (loop ≥ 3 nt) and stem lengths (≥ 2 bp).
        /// Stem ΔG computed from NN parameters; loop penalty from Jacobson-Stockmayer:
        ///   ΔG_loop = -RT·ln(σ·Ω·(3/(2πl·b²))^(3/2))
        ///   Simplified empirical: ΔG_loop(n) ≈ ΔG_loop(3) + 2.44·RT·ln(n/3)
        ///   where ΔG_loop(3) ≈ +5.2 kcal/mol (triloop), R=1.987 cal/(mol·K), T=310.15K
        /// Returns the most negative (most stable) hairpin ΔG.
        /// Reference: SantaLucia (1998); Zuker (2003) Nucleic Acids Res 31:3406
        /// </summary>
        private double CalculateHairpinDeltaG(string seq)
        {
            if (seq.Length < 8) return 0;
            double worstDG = 0;
            double RT = 1.987 * 310.15 / 1000.0; // kcal/mol at 37°C

            // loop penalty lookup (empirical, kcal/mol)
            double[] loopPenalty = { 0, 0, 0, 5.2, 4.5, 4.4, 4.3, 4.1, 4.1, 3.9, 3.7, 3.5, 3.4, 3.3, 3.2, 3.1, 3.1, 3.0, 3.0, 2.9, 2.9 };

            for (int loopStart = 2; loopStart < seq.Length - 4; loopStart++)
            {
                for (int loopLen = 3; loopLen <= Math.Min(12, seq.Length - loopStart - 2); loopLen++)
                {
                    int maxStem = Math.Min(loopStart, seq.Length - loopStart - loopLen);
                    if (maxStem < 2) continue;

                    int stemBp = 0;
                    double stemDG = 0;
                    for (int s = 0; s < maxStem; s++)
                    {
                        int pos5 = loopStart - 1 - s;
                        int pos3 = loopStart + loopLen + s;
                        if (pos5 < 0 || pos3 >= seq.Length) break;
                        if (IsComplement(seq[pos5], seq[pos3]))
                        {
                            stemBp++;
                            if (stemBp >= 2)
                            {
                                int b1 = _baseIdx[seq[pos5]], b2 = _baseIdx[seq[pos5 + 1]];
                                if (b1 >= 0 && b2 >= 0) stemDG += _nnG[b1 * 4 + b2];
                            }
                        }
                        else break;
                    }

                    if (stemBp >= 2)
                    {
                        double lp = loopLen < loopPenalty.Length ? loopPenalty[loopLen] : 2.9 + 2.44 * RT * Math.Log((double)loopLen / 20.0);
                        double totalDG = stemDG + lp;
                        if (totalDG < worstDG) worstDG = totalDG;
                    }
                }
            }
            return Math.Round(worstDG, 2);
        }

        /// <summary>
        /// Any Self-Complementarity — Total complementary base pairs (not just consecutive)
        /// in the worst-case alignment. Differs from SelfComplementarityScore which
        /// only counts the longest consecutive run.
        /// </summary>
        private int CalculateAnyComplementarity(string seq)
        {
            if (seq.Length < 4) return 0;
            string rc = GetReverseComplement(seq);
            int maxTotal = 0;
            for (int off = 0; off < seq.Length * 2 - 1; off++)
            {
                int total = 0;
                for (int i = 0; i < seq.Length; i++)
                {
                    int j = i - (off - seq.Length + 1);
                    if (j >= 0 && j < rc.Length && IsComplement(seq[i], rc[j])) total++;
                }
                maxTotal = Math.Max(maxTotal, total);
            }
            return maxTotal;
        }

        private int CalculateHeteroDimer(string p1, string p2)
        {
            string rc2 = GetReverseComplement(p2);
            int max = 0, total = p1.Length + rc2.Length - 1;
            for (int off = 0; off < total; off++)
            {
                int cons = 0;
                for (int i = 0; i < p1.Length; i++)
                {
                    int j = i - (off - rc2.Length + 1);
                    if (j >= 0 && j < rc2.Length && IsComplement(p1[i], rc2[j])) { cons++; max = Math.Max(max, cons); }
                    else cons = 0;
                }
            }
            return max;
        }

        private bool HasRepeats(string seq)
        {
            for (int i = 0; i <= seq.Length - 4; i++)
                if (seq[i] == seq[i + 1] && seq[i] == seq[i + 2] && seq[i] == seq[i + 3]) return true;
            return false;
        }

        #endregion

        #region === Utility ===

        private string CleanSequence(string input)
        {
            if (string.IsNullOrEmpty(input)) return "";
            var sb = new StringBuilder();
            foreach (char c in input.ToUpper())
                if (c == 'A' || c == 'T' || c == 'G' || c == 'C') sb.Append(c);
            return sb.ToString();
        }

        private string GetReverseComplement(string seq)
        {
            var sb = new StringBuilder(seq.Length);
            for (int i = seq.Length - 1; i >= 0; i--)
            {
                switch (seq[i])
                {
                    case 'A': sb.Append('T'); break;
                    case 'T': sb.Append('A'); break;
                    case 'G': sb.Append('C'); break;
                    case 'C': sb.Append('G'); break;
                    default: sb.Append('N'); break;
                }
            }
            return sb.ToString();
        }

        private bool IsComplement(char a, char b) =>
            (a == 'A' && b == 'T') || (a == 'T' && b == 'A') || (a == 'G' && b == 'C') || (a == 'C' && b == 'G');

        #endregion

        #region === Display Methods ===

        private void DisplayPrimerResult(PrimerAnalysis a,
            TextBlock seq, TextBlock len, TextBlock tm, TextBlock gc, TextBlock mw,
            TextBlock gcClamp, TextBlock selfComp, TextBlock hairpin, TextBlock endStab, TextBlock warn,
            TextBlock selfDimerDG = null, TextBlock hairpinDG = null, TextBlock anyComp = null)
        {
            seq.Text = $"5'-{a.Sequence}-3'";
            len.Text = $"{a.Length} bp";
            tm.Text = $"{a.Tm:F1}°C";
            gc.Text = $"{a.GCPercent:F1}%";
            mw.Text = $"{a.MolecularWeight:F0}";

            var green = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#4CAF50"));
            var red = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#F44336"));
            var orange = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#FF9800"));

            gcClamp.Text = a.HasGCClamp ? "✓ Yes" : "✗ No";
            gcClamp.Foreground = a.HasGCClamp ? green : red;
            selfComp.Text = $"{a.SelfComplementarityScore}";
            selfComp.Foreground = a.SelfComplementarityScore < 4 ? green : red;
            hairpin.Text = $"{a.HairpinScore}";
            hairpin.Foreground = a.HairpinScore < 3 ? green : red;
            endStab.Text = $"{a.EndStabilityDeltaG:F1}";
            endStab.Foreground = a.EndStabilityDeltaG > -9 ? green : orange;

            if (selfDimerDG != null)
            {
                selfDimerDG.Text = $"{a.SelfDimerDeltaG:F1} kcal";
                selfDimerDG.Foreground = a.SelfDimerDeltaG > -6.0 ? green : a.SelfDimerDeltaG > -9.0 ? orange : red;
            }
            if (hairpinDG != null)
            {
                hairpinDG.Text = $"{a.HairpinDeltaG:F1} kcal";
                hairpinDG.Foreground = a.HairpinDeltaG > -3.0 ? green : a.HairpinDeltaG > -5.0 ? orange : red;
            }
            if (anyComp != null)
            {
                anyComp.Text = $"{a.AnyCompScore}";
                anyComp.Foreground = a.AnyCompScore < a.Length * 0.4 ? green : a.AnyCompScore < a.Length * 0.6 ? orange : red;
            }

            warn.Text = a.Warnings.Count > 0 ? string.Join("\n", a.Warnings) : "";
        }

        private void ClearPrimerDisplay(TextBlock seq, TextBlock len, TextBlock tm, TextBlock gc, TextBlock mw,
            TextBlock gcClamp, TextBlock selfComp, TextBlock hairpin, TextBlock endStab, TextBlock warn,
            TextBlock selfDimerDG = null, TextBlock hairpinDG = null, TextBlock anyComp = null)
        {
            seq.Text = ""; len.Text = "-"; tm.Text = "-"; gc.Text = "-"; mw.Text = "-";
            gcClamp.Text = "-"; selfComp.Text = "-"; hairpin.Text = "-"; endStab.Text = "-"; warn.Text = "";
            if (selfDimerDG != null) selfDimerDG.Text = "-";
            if (hairpinDG != null) hairpinDG.Text = "-";
            if (anyComp != null) anyComp.Text = "-";
        }

        private void DisplayPairSummary(PrimerAnalysis fwd, PrimerAnalysis rev, string template)
        {
            var green = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#4CAF50"));
            var red = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#F44336"));
            var orange = new SolidColorBrush((Color)ColorConverter.ConvertFromString("#FF9800"));

            double tmDiff = Math.Abs(fwd.Tm - rev.Tm);
            TmDifference.Text = $"{tmDiff:F1}°C";
            TmDifference.Foreground = tmDiff <= 5 ? green : red;

            int hd = CalculateHeteroDimer(fwd.Sequence, rev.Sequence);
            HeteroDimer.Text = $"{hd}";
            HeteroDimer.Foreground = hd < 4 ? green : red;

            if (!string.IsNullOrEmpty(template))
            {
                int fPos = template.IndexOf(fwd.Sequence, StringComparison.Ordinal);
                string rcOnT = GetReverseComplement(rev.Sequence);
                int rPos = template.IndexOf(rcOnT, StringComparison.Ordinal);
                ProductSize.Text = (fPos >= 0 && rPos >= 0) ? $"{rPos + rev.Length - fPos} bp" : "N/A";
            }
            else ProductSize.Text = "N/A";

            double score = 100 - tmDiff * 3 - Math.Abs(60 - fwd.Tm) - Math.Abs(60 - rev.Tm)
                - fwd.SelfComplementarityScore * 2 - rev.SelfComplementarityScore * 2 - hd * 2
                - fwd.HairpinScore * 3 - rev.HairpinScore * 3;
            OverallScore.Text = $"{Math.Max(0, score):F0}/100";
            OverallScore.Foreground = score >= 70 ? green : score >= 40 ? orange : red;

            var warns = new List<string>();
            if (tmDiff > 5) warns.Add("⚠ ΔTm > 5°C");
            if (hd >= 4) warns.Add("⚠ Hetero-dimer risk");
            PairWarnings.Text = warns.Count > 0 ? string.Join("\n", warns) : "";
        }

        /// <summary>
        /// Opens NCBI Primer-BLAST in the default browser with current primers pre-filled.
        /// URL parameters: PRIMER_LEFT_INPUT, PRIMER_RIGHT_INPUT, INPUT_SEQUENCE, ORGANISM, PRIMER_PRODUCT_MIN/MAX
        /// </summary>
        private void PrimerBlast_Click(object sender, RoutedEventArgs e)
        {
            string fwd = _lastFwdPrimer;
            string rev = _lastRevPrimer;

            if (string.IsNullOrEmpty(fwd) && string.IsNullOrEmpty(rev))
            {
                MessageBox.Show("Please analyze or select a primer pair first.", "No Primers", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var sb = new StringBuilder("https://www.ncbi.nlm.nih.gov/tools/primer-blast/index.cgi?LINK_LOC=BlastHome");

            if (!string.IsNullOrEmpty(fwd))
                sb.Append($"&PRIMER_LEFT_INPUT={Uri.EscapeDataString(fwd)}");
            if (!string.IsNullOrEmpty(rev))
                sb.Append($"&PRIMER_RIGHT_INPUT={Uri.EscapeDataString(rev)}");

            // Pre-fill accession if available
            if (!string.IsNullOrEmpty(_currentAccession))
                sb.Append($"&INPUT_SEQUENCE={Uri.EscapeDataString(_currentAccession)}");

            // Pre-fill organism (TaxID)
            if (!string.IsNullOrEmpty(_currentTaxId))
                sb.Append($"&ORGANISM={Uri.EscapeDataString(_currentTaxId)}");

            // Pre-fill product size range from current settings
            if (int.TryParse(MinProductInput?.Text, out int minP))
                sb.Append($"&PRIMER_PRODUCT_MIN={minP}");
            if (int.TryParse(MaxProductInput?.Text, out int maxP))
                sb.Append($"&PRIMER_PRODUCT_MAX={maxP}");

            try
            {
                Process.Start(new ProcessStartInfo { FileName = sb.ToString(), UseShellExecute = true });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to open browser:\n{ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void GenerateSequenceVisualization(string template, string fwdSeq, string revSeq)
        {
            var sb = new StringBuilder();
            int fPos = -1, rPos = -1;

            if (!string.IsNullOrEmpty(fwdSeq)) fPos = template.IndexOf(fwdSeq, StringComparison.Ordinal);
            string rcOnT = "";
            if (!string.IsNullOrEmpty(revSeq)) { rcOnT = GetReverseComplement(revSeq); rPos = template.IndexOf(rcOnT, StringComparison.Ordinal); }

            if (fPos >= 0) sb.AppendLine($"Fwd binds: {fPos + 1}–{fPos + fwdSeq.Length}");
            if (rPos >= 0) sb.AppendLine($"Rev binds: {rPos + 1}–{rPos + rcOnT.Length}");
            if (fPos >= 0 && rPos >= 0) sb.AppendLine($"Product: {rPos + rcOnT.Length - fPos} bp");
            sb.AppendLine();

            int ds = Math.Max(0, fPos >= 0 ? fPos - 10 : 0);
            int de = Math.Min(template.Length, rPos >= 0 ? rPos + rcOnT.Length + 10 : Math.Min(template.Length, ds + 200));
            de = Math.Min(de, ds + 200);
            string disp = template.Substring(ds, de - ds);

            var fm = new char[disp.Length];
            var rm = new char[disp.Length];
            for (int i = 0; i < disp.Length; i++) { fm[i] = ' '; rm[i] = ' '; }

            if (fPos >= 0) for (int i = 0; i < fwdSeq.Length; i++) { int idx = fPos - ds + i; if (idx >= 0 && idx < fm.Length) fm[idx] = '>'; }
            if (rPos >= 0) for (int i = 0; i < rcOnT.Length; i++) { int idx = rPos - ds + i; if (idx >= 0 && idx < rm.Length) rm[idx] = '<'; }

            for (int i = 0; i < disp.Length; i += 60)
            {
                int len = Math.Min(60, disp.Length - i);
                sb.AppendLine($"Fwd:  {new string(fm, i, len)}");
                sb.AppendLine($"{ds + i + 1,5} {disp.Substring(i, len)}");
                sb.AppendLine($"Rev:  {new string(rm, i, len)}");
                sb.AppendLine();
            }

            SequenceVisualization.Text = sb.ToString();
        }

        #endregion

        #region === Copy / Export / Clear ===

        private void CopyForwardPrimer_Click(object sender, RoutedEventArgs e)
        { if (!string.IsNullOrEmpty(_lastFwdPrimer)) Clipboard.SetText(_lastFwdPrimer); }

        private void CopyReversePrimer_Click(object sender, RoutedEventArgs e)
        { if (!string.IsNullOrEmpty(_lastRevPrimer)) Clipboard.SetText(_lastRevPrimer); }

        private void ExportAutoResults_Click(object sender, RoutedEventArgs e)
        {
            var items = AutoResultsDataGrid.ItemsSource as List<PrimerPairResult>;
            if (items == null || items.Count == 0) return;

            var dlg = new SaveFileDialog { Filter = "CSV|*.csv", FileName = $"PrimerDesign_{_currentGeneSymbol}_{DateTime.Now:yyyyMMdd}.csv" };
            if (dlg.ShowDialog() == true)
            {
                var sb = new StringBuilder("Rank,Forward,Reverse,Fwd Tm,Rev Tm,dTm,Product,Score\n");
                foreach (var i in items)
                    sb.AppendLine($"{i.Rank},{i.ForwardSequence},{i.ReverseSequence},{i.ForwardTm:F1},{i.ReverseTm:F1},{i.TmDiff:F1},{i.ProductSize},{i.Score:F1}");
                File.WriteAllText(dlg.FileName, sb.ToString());
                MessageBox.Show($"Exported to:\n{dlg.FileName}", "Export", MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        private void ClearAll_Click(object sender, RoutedEventArgs e)
        {
            GeneSymbolTextBox.Text = ""; AccessionTextBox.Text = "";
            DirectSequenceInput.Text = ""; ForwardPrimerInput.Text = ""; ReversePrimerInput.Text = "";
            _genomicSequence = _activeTemplate = _lastFwdPrimer = _lastRevPrimer = "";
            _exonList.Clear(); _cdsList.Clear(); _isoforms.Clear();
            _selectionStart = _selectionEnd = -1;

            ActiveTemplateDisplay.Text = ""; ActiveTemplateLengthLabel.Text = "No template loaded";
            IsoformListBox.ItemsSource = null;
            IsoformPanel.Visibility = Visibility.Collapsed;
            InputSectionSummary.Text = "";
            GeneVisualizationPanel.Visibility = Visibility.Collapsed;
            GeneVisualizationCanvas.Children.Clear();

            ClearPrimerDisplay(FwdSequenceDisplay, FwdLength, FwdTm, FwdGC, FwdMW, FwdGCClamp, FwdSelfComp, FwdHairpin, FwdEndStability, FwdWarnings, FwdSelfDimerDG, FwdHairpinDG, FwdAnyComp);
            ClearPrimerDisplay(RevSequenceDisplay, RevLength, RevTm, RevGC, RevMW, RevGCClamp, RevSelfComp, RevHairpin, RevEndStability, RevWarnings, RevSelfDimerDG, RevHairpinDG, RevAnyComp);

            ProductSize.Text = ""; TmDifference.Text = ""; HeteroDimer.Text = ""; OverallScore.Text = "";
            PairWarnings.Text = ""; PairSummaryPanel.Visibility = Visibility.Collapsed;
            AutoResultsPanel.Visibility = Visibility.Collapsed; SequenceViewPanel.Visibility = Visibility.Collapsed;
            AutoResultsDataGrid.ItemsSource = null; InfoBar.Visibility = Visibility.Collapsed;
            _markerFwdStart = _markerRevStart = -1;
            FwdWithREPreview.Text = ""; RevWithREPreview.Text = "";

            ManualModeRadio.IsChecked = false;
            AutoModeRadio.IsChecked = true;
        }

        #endregion

        #region === Helpers ===

        private void ShowLoading(bool show, string msg = "")
        {
            LoadingOverlay.Visibility = show ? Visibility.Visible : Visibility.Collapsed;
            LoadingText.Text = msg;
        }

        private void ShowInfo(string msg, bool err)
        {
            InfoBar.Visibility = Visibility.Visible;
            InfoBar.Background = new SolidColorBrush(err ? Color.FromRgb(255, 235, 238) : Color.FromRgb(227, 242, 253));
            InfoIcon.Text = err ? "⚠️" : "✅";
            InfoText.Text = msg;
            InfoText.Foreground = new SolidColorBrush(err ? Color.FromRgb(198, 40, 40) : Color.FromRgb(21, 101, 192));
        }

        /// <summary>Input validation: only allow digits, decimal point, and minus sign in numeric TextBoxes.</summary>
        private void NumericTextBox_PreviewTextInput(object sender, TextCompositionEventArgs e)
        {
            // Allow digits, single decimal point, and leading minus
            string newText = e.Text;
            if (sender is TextBox tb)
            {
                string current = tb.Text;
                bool hasDot = current.Contains(".");
                bool hasMinus = current.Contains("-");
                foreach (char c in newText)
                {
                    if (char.IsDigit(c)) continue;
                    if (c == '.' && !hasDot) { hasDot = true; continue; }
                    if (c == '-' && !hasMinus && tb.CaretIndex == 0) { hasMinus = true; continue; }
                    e.Handled = true;
                    return;
                }
            }
        }

        /// <summary>Block paste of non-numeric content.</summary>
        private void NumericTextBox_Pasting(object sender, DataObjectPastingEventArgs e)
        {
            if (e.DataObject.GetDataPresent(typeof(string)))
            {
                string text = (string)e.DataObject.GetData(typeof(string));
                if (!double.TryParse(text, out _)) e.CancelCommand();
            }
            else e.CancelCommand();
        }

        /// <summary>
        /// Handles nested ScrollViewer problem: when an inner scrollable control is at its
        /// top/bottom boundary, forward the scroll to the outer page ScrollViewer.
        /// </summary>
        private void PageScrollViewer_PreviewMouseWheel(object sender, MouseWheelEventArgs e)
        {
            // Find the nearest inner ScrollViewer from the event source
            var innerSV = FindAncestorScrollViewer(e.OriginalSource as DependencyObject);

            if (innerSV == null)
                return; // no inner SV → let PageScrollViewer handle normally

            // Skip horizontal-only ScrollViewers (e.g. GeneVisualizationScrollViewer)
            if (innerSV.VerticalScrollBarVisibility == ScrollBarVisibility.Disabled)
                return;

            // Panel-level ScrollViewers (left params, right results) should NOT capture
            // mouse wheel — the entire page should scroll instead. Only DataGrid's
            // internal ScrollViewer should be allowed to handle its own scrolling.
            bool isDataGridSV = IsInsideDataGrid(innerSV);

            if (!isDataGridSV)
            {
                // Forward to outer PageScrollViewer
                e.Handled = true;
                ScrollPageBy(e.Delta);
                return;
            }

            // DataGrid inner ScrollViewer — allow it to scroll rows
            bool canScrollContent = innerSV.ScrollableHeight > 0.5;
            if (!canScrollContent)
            {
                e.Handled = true;
                ScrollPageBy(e.Delta);
                return;
            }

            bool scrollingUp = e.Delta > 0;
            bool atTop = innerSV.VerticalOffset < 0.5;
            bool atBottom = innerSV.VerticalOffset >= innerSV.ScrollableHeight - 0.5;

            if ((scrollingUp && atTop) || (!scrollingUp && atBottom))
            {
                e.Handled = true;
                ScrollPageBy(e.Delta);
            }
        }

        private static bool IsInsideDataGrid(DependencyObject element)
        {
            var current = element;
            while (current != null)
            {
                if (current is DataGrid) return true;
                try { current = VisualTreeHelper.GetParent(current); }
                catch { return false; }
            }
            return false;
        }

        private void ScrollPageBy(int delta)
        {
            double newOffset = PageScrollViewer.VerticalOffset - delta;
            PageScrollViewer.ScrollToVerticalOffset(newOffset);
        }

        /// <summary>
        /// Walk up the visual tree from source to find the first ScrollViewer
        /// that is NOT the PageScrollViewer itself.
        /// </summary>
        private ScrollViewer FindAncestorScrollViewer(DependencyObject source)
        {
            var current = source;
            while (current != null)
            {
                if (current is ScrollViewer sv && sv != PageScrollViewer)
                    return sv;
                if (current == PageScrollViewer)
                    return null; // reached outer without finding inner
                try { current = VisualTreeHelper.GetParent(current); }
                catch { return null; }
            }
            return null;
        }

        #endregion
    }
}

==================================================
FILE_NAME: ProteinBCA.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\ProteinBCA.xaml
==================================================
<Page x:Class="BioSAK.Pages.ProteinBCA"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      mc:Ignorable="d" 
      d:DesignHeight="800" d:DesignWidth="1200"
      Title="Protein BCA Calculator">

    <Page.Resources>
        <Style TargetType="DataGrid">
            <Setter Property="AutoGenerateColumns" Value="False"/>
            <Setter Property="CanUserAddRows" Value="True"/>
            <Setter Property="CanUserDeleteRows" Value="True"/>
            <Setter Property="GridLinesVisibility" Value="All"/>
            <Setter Property="HeadersVisibility" Value="All"/>
            <Setter Property="RowHeaderWidth" Value="25"/>
            <Setter Property="Background" Value="White"/>
            <Setter Property="BorderBrush" Value="#DDD"/>
            <Setter Property="SelectionUnit" Value="CellOrRowHeader"/>
        </Style>
    </Page.Resources>

    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <GroupBox Grid.Row="0" Header="Global Settings &amp; Controls" Margin="0,0,0,10" Background="#F9F9F9">
            <StackPanel Orientation="Horizontal" Margin="5">
                <TextBlock Text="Global Dilution (x):" VerticalAlignment="Center" FontWeight="Bold"/>
                <TextBox x:Name="TxtGlobalDilution" Width="50" Margin="5,0,15,0" Text="1" TextAlignment="Center" Background="White"/>

                <TextBlock Text="Target (µg):" VerticalAlignment="Center"/>
                <TextBox x:Name="TxtTargetMass" Width="50" Margin="5,0" Text="20" TextAlignment="Center" Background="White"/>

                <TextBlock Text="Total Vol (µL):" VerticalAlignment="Center" Margin="10,0,0,0"/>
                <TextBox x:Name="TxtTotalVol" Width="50" Margin="5,0" Text="20" TextAlignment="Center" Background="White"/>

                <TextBlock Text="Buffer:" VerticalAlignment="Center" Margin="10,0,0,0"/>
                <ComboBox x:Name="ComboBuffer" Width="60" Margin="5,0" SelectedIndex="3">
                    <ComboBoxItem Content="2x"/>
                    <ComboBoxItem Content="3x"/>
                    <ComboBoxItem Content="4x"/>
                    <ComboBoxItem Content="5x"/>
                    <ComboBoxItem Content="6x"/>
                </ComboBox>

                <Button Content="CALCULATE ALL" FontWeight="Bold" Background="#E0F7FA" Margin="30,0,0,0" Padding="20,5" Click="CalculateAll_Click"/>
            </StackPanel>
        </GroupBox>

        <Grid Grid.Row="1">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="10"/>
                <ColumnDefinition Width="400"/>
            </Grid.ColumnDefinitions>

            <Grid Grid.Column="0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="5"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <GroupBox Grid.Row="0" Header="1. Samples Input (OD Values)">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                        </Grid.RowDefinitions>
                        <TextBlock Text="Paste Support: Click any cell (e.g., OD1) and Ctrl+V" Foreground="#666" FontSize="11" Margin="2"/>

                        <DataGrid x:Name="GridSamples" Grid.Row="1" KeyDown="GridSamples_KeyDown">
                            <DataGrid.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Delete Selected Row" Click="DeleteSampleRow_Click"/>
                                </ContextMenu>
                            </DataGrid.ContextMenu>
                            <DataGrid.Columns>
                                <DataGridTextColumn Header="ID" Binding="{Binding ID}" Width="60"/>
                                <DataGridTextColumn Header="OD 1" Binding="{Binding OD1}" Width="80"/>
                                <DataGridTextColumn Header="OD 2" Binding="{Binding OD2}" Width="80"/>
                                <DataGridTextColumn Header="Conc. (µg/µL)" Binding="{Binding CalculatedConc, StringFormat=N2}" IsReadOnly="True" Foreground="Red" FontWeight="Bold" Width="*"/>
                            </DataGrid.Columns>
                        </DataGrid>
                    </Grid>
                </GroupBox>

                <GridSplitter Grid.Row="1" HorizontalAlignment="Stretch" Background="#EEE"/>

                <GroupBox Grid.Row="2" Header="3. Recipe (Calculation Result)">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                        </Grid.RowDefinitions>
                        <Button Content="Copy Recipe Table" Click="CopyRecipe_Click" HorizontalAlignment="Left" Margin="2" Height="22" Padding="10,0"/>

                        <DataGrid x:Name="GridRecipe" Grid.Row="1" IsReadOnly="True">
                            <DataGrid.Columns>
                                <DataGridTextColumn Header="ID" Binding="{Binding SampleID}" Width="60"/>
                                <DataGridTextColumn Header="Sample (µL)" Binding="{Binding SampleVol, StringFormat=N1}" Width="90" FontWeight="Bold"/>
                                <DataGridTextColumn Header="Water (µL)" Binding="{Binding WaterVol, StringFormat=N1}" Width="80"/>
                                <DataGridTextColumn Header="Buffer (µL)" Binding="{Binding BufferVol, StringFormat=N1}" Width="80"/>
                            </DataGrid.Columns>
                        </DataGrid>
                    </Grid>
                </GroupBox>
            </Grid>

            <Grid Grid.Column="2">
                <Grid.RowDefinitions>
                    <RowDefinition Height="250"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <Border Grid.Row="0" BorderBrush="#AAA" BorderThickness="1" Background="White" Margin="0,0,0,10">
                    <Grid>
                        <TextBlock Text="Conc." RenderTransformOrigin="0.5,0.5" HorizontalAlignment="Left" VerticalAlignment="Center" Margin="5,0,0,0">
                            <TextBlock.LayoutTransform>
                                <RotateTransform Angle="-90"/>
                            </TextBlock.LayoutTransform>
                        </TextBlock>
                        <TextBlock Text="OD Absorbance" VerticalAlignment="Bottom" HorizontalAlignment="Center" Margin="0,0,0,5"/>
                        <Canvas x:Name="ChartCanvas" Margin="30,10,10,30" ClipToBounds="True" Background="#FAFAFA"/>
                        <StackPanel HorizontalAlignment="Right" VerticalAlignment="Top" Margin="0,10,20,0" Background="#DDFFFFFF">
                            <TextBlock x:Name="EquationText" Text="y = ax + b" FontWeight="Bold" Foreground="DarkRed"/>
                            <TextBlock x:Name="R2Text" Text="R² = ---" FontSize="11" Foreground="#666"/>
                        </StackPanel>
                    </Grid>
                </Border>

                <GroupBox Grid.Row="1" Header="2. Standard Curve">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                        </Grid.RowDefinitions>
                        <TextBlock Text="Tip: Select start cell to paste" Foreground="#888" FontSize="10" Margin="2"/>

                        <DataGrid x:Name="GridStandards" Grid.Row="1" KeyDown="GridStandards_KeyDown">
                            <DataGrid.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Delete Selected Row" Click="DeleteStandardRow_Click"/>
                                </ContextMenu>
                            </DataGrid.ContextMenu>
                            <DataGrid.Columns>
                                <DataGridTextColumn Header="Conc. (ng/µL)" Binding="{Binding Concentration}" Width="*"/>
                                <DataGridTextColumn Header="OD 1" Binding="{Binding OD1}" Width="60"/>
                                <DataGridTextColumn Header="OD 2" Binding="{Binding OD2}" Width="60"/>
                                <DataGridTextColumn Header="Avg" Binding="{Binding Average, StringFormat=N3}" IsReadOnly="True" Width="50" Foreground="Blue"/>
                            </DataGrid.Columns>
                        </DataGrid>
                    </Grid>
                </GroupBox>
            </Grid>

        </Grid>
    </Grid>
</Page>

==================================================
FILE_NAME: ProteinBCA.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\ProteinBCA.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;

namespace BioSAK.Pages
{
    public partial class ProteinBCA : Page
    {
        // === 資料模型 ===
        public class StandardPoint : INotifyPropertyChanged
        {
            private double _conc; private double _od1; private double _od2;
            public double Concentration { get => _conc; set { _conc = value; OnPropertyChanged(); } }
            public double OD1 { get => _od1; set { _od1 = value; OnPropertyChanged(); OnPropertyChanged(nameof(Average)); } }
            public double OD2 { get => _od2; set { _od2 = value; OnPropertyChanged(); OnPropertyChanged(nameof(Average)); } }
            public double Average => (OD1 + OD2) / 2.0;

            public event PropertyChangedEventHandler? PropertyChanged;
            protected void OnPropertyChanged([CallerMemberName] string? name = null) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }

        public class SampleData : INotifyPropertyChanged
        {
            public string? ID { get; set; } = "1";
            public double OD1 { get; set; }
            public double OD2 { get; set; }
            // Dilution 已移除，改用 Global Setting

            private double _calcConc;
            public double CalculatedConc { get => _calcConc; set { _calcConc = value; OnPropertyChanged(); } }

            public event PropertyChangedEventHandler? PropertyChanged;
            protected void OnPropertyChanged([CallerMemberName] string? name = null) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }

        public class RecipeData
        {
            public string? SampleID { get; set; }
            public double SampleVol { get; set; }
            public double WaterVol { get; set; }
            public double BufferVol { get; set; }
        }

        // === 變數 ===
        public ObservableCollection<StandardPoint> Standards { get; set; }
        public ObservableCollection<SampleData> Samples { get; set; }
        public ObservableCollection<RecipeData> Recipes { get; set; }

        private double _slope = 0;
        private double _intercept = 0;

        public ProteinBCA()
        {
            InitializeComponent();

            Standards = new ObservableCollection<StandardPoint>
            {
                new StandardPoint { Concentration = 0 },
                new StandardPoint { Concentration = 125 },
                new StandardPoint { Concentration = 250 },
                new StandardPoint { Concentration = 500 },
                new StandardPoint { Concentration = 1000 }
            };
            GridStandards.ItemsSource = Standards;

            Samples = new ObservableCollection<SampleData>
            {
                new SampleData { ID = "1", OD1=0, OD2=0 }
            };
            GridSamples.ItemsSource = Samples;

            Recipes = new ObservableCollection<RecipeData>();
            GridRecipe.ItemsSource = Recipes;
        }

        // === 1. 刪除功能 ===
        private void DeleteStandardRow_Click(object sender, RoutedEventArgs e)
        {
            var list = GridStandards.SelectedItems.OfType<StandardPoint>().ToList();
            foreach (var item in list) Standards.Remove(item);
        }

        private void DeleteSampleRow_Click(object sender, RoutedEventArgs e)
        {
            var list = GridSamples.SelectedItems.OfType<SampleData>().ToList();
            foreach (var item in list) Samples.Remove(item);
        }

        // === 2. 智慧貼上功能 (核心修改) ===
        // 這一段邏輯改為從「滑鼠選取的格子」開始貼上，並正確對應欄位

        private void GridSamples_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.V && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)
            {
                PasteToGrid(GridSamples, Samples);
                e.Handled = true;
            }
        }

        private void GridStandards_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.V && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)
            {
                PasteToGrid(GridStandards, Standards);
                e.Handled = true;
            }
        }

        /// <summary>
        /// 通用的貼上邏輯：偵測目前選取的 Cell (Row/Column) 並貼上資料
        /// </summary>
        private void PasteToGrid<T>(DataGrid grid, ObservableCollection<T> collection) where T : new()
        {
            string clipboardText = Clipboard.GetText();
            if (string.IsNullOrWhiteSpace(clipboardText)) return;

            string[] rows = clipboardText.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            if (rows.Length == 0) return;

            // 1. 取得起始位置
            int startRowIndex = 0;
            int startColIndex = 0;

            // 正確：直接檢查 IsValid 即可
            if (grid.CurrentCell.IsValid)
            {
                // 取得當前 Item 在 Collection 中的 Index
                startRowIndex = grid.Items.IndexOf(grid.CurrentCell.Item);

                // 取得當前 Column 的 DisplayIndex
                if (grid.CurrentColumn != null)
                {
                    startColIndex = grid.CurrentColumn.DisplayIndex;
                }
            }

            // 如果選取位置無效，預設從 0,0 開始
            if (startRowIndex < 0) startRowIndex = 0;

            // 2. 迴圈填入
            for (int r = 0; r < rows.Length; r++)
            {
                string[] cells = rows[r].Split('\t');
                int targetRowIndex = startRowIndex + r;

                // 如果目標行超過目前資料長度，則新增一行
                T dataItem;
                if (targetRowIndex < collection.Count)
                {
                    dataItem = collection[targetRowIndex];
                }
                else
                {
                    dataItem = new T();
                    // 特殊處理：如果是 SampleData，自動生成 ID
                    if (dataItem is SampleData sample)
                    {
                        sample.ID = (targetRowIndex + 1).ToString();
                    }
                    collection.Add(dataItem);
                }

                // 3. 欄位填入 (根據 startColIndex 偏移)
                for (int c = 0; c < cells.Length; c++)
                {
                    int targetColIndex = startColIndex + c;
                    string val = cells[c];

                    if (string.IsNullOrWhiteSpace(val)) continue;
                    if (!double.TryParse(val, out double numVal)) continue; // 這裡假設貼上的都是數字，如果是 ID (字串) 需額外判斷

                    // 根據 Data Type 分配數值
                    if (dataItem is SampleData s)
                    {
                        // GridSamples Columns: [0]=ID, [1]=OD1, [2]=OD2
                        if (targetColIndex == 0) s.ID = val; // ID 是字串
                        else if (targetColIndex == 1) s.OD1 = numVal;
                        else if (targetColIndex == 2) s.OD2 = numVal;
                    }
                    else if (dataItem is StandardPoint std)
                    {
                        // GridStandards Columns: [0]=Conc, [1]=OD1, [2]=OD2
                        if (targetColIndex == 0) std.Concentration = numVal;
                        else if (targetColIndex == 1) std.OD1 = numVal;
                        else if (targetColIndex == 2) std.OD2 = numVal;
                    }
                }
            }
        }

        // === 3. 計算與匯出 ===

        private void CalculateAll_Click(object sender, RoutedEventArgs e)
        {
            PerformRegression();

            // 讀取 Global Settings
            if (!double.TryParse(TxtTargetMass.Text, out double targetMass)) targetMass = 20;
            if (!double.TryParse(TxtTotalVol.Text, out double totalVol)) totalVol = 20;
            if (!double.TryParse(TxtGlobalDilution.Text, out double globalDilution)) globalDilution = 1;

            double bufferFold = 4;
            if (ComboBuffer.SelectedItem is ComboBoxItem item)
            {
                string? content = item.Content?.ToString();
                if (content != null) double.TryParse(content.Replace("x", ""), out bufferFold);
            }

            double reqBufferVol = totalVol / bufferFold;
            Recipes.Clear();

            foreach (var sample in Samples)
            {
                double avgOD = (sample.OD1 + sample.OD2) / 2.0;

                // Conc = Slope * OD + Intercept
                double rawConc_ng_ul = (_slope * avgOD) + _intercept;

                // 使用 Global Dilution 計算
                double finalConc_ug_ul = (rawConc_ng_ul / 1000.0) * globalDilution;

                if (finalConc_ug_ul < 0) finalConc_ug_ul = 0;
                sample.CalculatedConc = finalConc_ug_ul;

                double reqSampleVol = 0;
                double reqWaterVol = 0;

                if (finalConc_ug_ul > 0)
                {
                    reqSampleVol = targetMass / finalConc_ug_ul;
                    reqWaterVol = totalVol - reqBufferVol - reqSampleVol;
                }

                // 數值防呆
                if (reqWaterVol < 0) { reqWaterVol = 0; reqSampleVol = totalVol - reqBufferVol; }

                Recipes.Add(new RecipeData
                {
                    SampleID = sample.ID,
                    SampleVol = reqSampleVol,
                    WaterVol = reqWaterVol,
                    BufferVol = reqBufferVol
                });
            }
        }

        private void CopyRecipe_Click(object sender, RoutedEventArgs e)
        {
            GridRecipe.SelectAllCells();
            GridRecipe.ClipboardCopyMode = DataGridClipboardCopyMode.IncludeHeader;
            ApplicationCommands.Copy.Execute(null, GridRecipe);
            GridRecipe.UnselectAllCells();
        }

        // === 4. 回歸與繪圖 (邏輯保持不變) ===
        private void PerformRegression()
        {
            var points = Standards.Where(p => p.Average > 0 || p.Concentration == 0).ToList();
            if (points.Count < 2) return;

            double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            int n = points.Count;

            foreach (var p in points)
            {
                double x = p.Average; double y = p.Concentration;
                sumX += x; sumY += y; sumXY += x * y; sumX2 += x * x;
            }

            double denominator = (n * sumX2 - sumX * sumX);
            if (Math.Abs(denominator) < 1e-9) return;

            _slope = (n * sumXY - sumX * sumY) / denominator;
            _intercept = (sumY - _slope * sumX) / n;

            double meanY = sumY / n;
            double ssTot = points.Sum(p => Math.Pow(p.Concentration - meanY, 2));
            double ssRes = points.Sum(p => Math.Pow(p.Concentration - (_slope * p.Average + _intercept), 2));
            double r2 = (ssTot != 0) ? 1 - (ssRes / ssTot) : 0;

            EquationText.Text = $"Conc = {_slope:F2} * OD + {_intercept:F2}";
            R2Text.Text = $"R² = {r2:F4}";

            DrawChart(points);
        }

        private void DrawChart(List<StandardPoint> points)
        {
            ChartCanvas.Children.Clear();
            double w = ChartCanvas.ActualWidth; double h = ChartCanvas.ActualHeight;
            if (w == 0 || h == 0) return;

            double maxX = points.Max(p => p.Average);
            double maxY = points.Max(p => p.Concentration);
            maxX = (maxX == 0) ? 1 : maxX * 1.1;
            maxY = (maxY == 0) ? 1 : maxY * 1.1;

            foreach (var p in points)
            {
                double px = (p.Average / maxX) * w;
                double py = h - ((p.Concentration / maxY) * h);
                Ellipse point = new Ellipse { Width = 6, Height = 6, Fill = Brushes.Blue };
                Canvas.SetLeft(point, px - 3); Canvas.SetTop(point, py - 3);
                ChartCanvas.Children.Add(point);
            }

            double x1 = 0, x2 = maxX;
            double y1 = _slope * x1 + _intercept;
            double y2 = _slope * x2 + _intercept;

            Line line = new Line
            {
                X1 = (x1 / maxX) * w,
                Y1 = h - (y1 / maxY) * h,
                X2 = (x2 / maxX) * w,
                Y2 = h - (y2 / maxY) * h,
                Stroke = Brushes.Red,
                StrokeThickness = 1.5
            };
            ChartCanvas.Children.Add(line);
        }
    }
}

==================================================
FILE_NAME: RestrictionEnzymePatternPage.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\RestrictionEnzymePatternPage.xaml
==================================================
<Page x:Class="BioSAK.Pages.RestrictionEnzymePatternPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      xmlns:local="clr-namespace:BioSAK.Pages"
      xmlns:controls="clr-namespace:BioSAK.Controls"
      mc:Ignorable="d" 
      d:DesignHeight="600" d:DesignWidth="900"
      Title="Restriction Enzyme Pattern Predictor"
      Background="WhiteSmoke">

    <Page.Resources>
        <Style x:Key="HeaderStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Margin" Value="0,0,0,5"/>
        </Style>
        
        <Style x:Key="InputBorderStyle" TargetType="Border">
            <Setter Property="BorderBrush" Value="#CCCCCC"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="CornerRadius" Value="3"/>
            <Setter Property="Background" Value="White"/>
        </Style>
    </Page.Resources>

    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="350"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <!-- Title -->
        <TextBlock Grid.Row="0" Grid.ColumnSpan="2" 
                   Text="Restriction Enzyme Pattern Predictor" 
                   FontSize="20" 
                   FontWeight="Bold" 
                   Margin="0,0,0,15"/>

        <!-- Left Panel - Input -->
        <ScrollViewer Grid.Row="1" Grid.Column="0" 
                      VerticalScrollBarVisibility="Auto"
                      Margin="0,0,15,0">
            <StackPanel>
                <!-- Sequence Input -->
                <TextBlock Text="DNA Sequence:" Style="{StaticResource HeaderStyle}"/>
                <Border Style="{StaticResource InputBorderStyle}" Margin="0,0,0,10">
                    <TextBox x:Name="SequenceTextBox" 
                             Height="120" 
                             TextWrapping="Wrap" 
                             AcceptsReturn="True"
                             VerticalScrollBarVisibility="Auto"
                             FontFamily="Consolas"
                             BorderThickness="0"
                             Padding="5"/>
                </Border>

                <!-- Sequence Info -->
                <StackPanel Orientation="Horizontal" Margin="0,0,0,10">
                    <TextBlock Text="Length: "/>
                    <TextBlock x:Name="SequenceLengthText" Text="0 bp" FontWeight="SemiBold"/>
                </StackPanel>

                <!-- Topology Selection -->
                <TextBlock Text="Topology:" Style="{StaticResource HeaderStyle}"/>
                <StackPanel Orientation="Horizontal" Margin="0,0,0,15">
                    <RadioButton x:Name="LinearRadio" 
                                 Content="Linear" 
                                 IsChecked="True" 
                                 Margin="0,0,20,0"/>
                    <RadioButton x:Name="CircularRadio" 
                                 Content="Circular"/>
                </StackPanel>

                <!-- Enzyme Selection -->
                <TextBlock Text="Select Enzyme:" Style="{StaticResource HeaderStyle}"/>
                <Border Style="{StaticResource InputBorderStyle}" Margin="0,0,0,5">
                    <TextBox x:Name="EnzymeSearchBox" 
                             BorderThickness="0"
                             Padding="5"
                             Text=""
                             TextChanged="EnzymeSearchBox_TextChanged">
                        <TextBox.Style>
                            <Style TargetType="TextBox">
                                <Style.Triggers>
                                    <Trigger Property="Text" Value="">
                                        <Setter Property="Background">
                                            <Setter.Value>
                                                <VisualBrush Stretch="None" AlignmentX="Left">
                                                    <VisualBrush.Visual>
                                                        <TextBlock Text="Search enzyme..." 
                                                                   Foreground="Gray" 
                                                                   Margin="5,0,0,0"/>
                                                    </VisualBrush.Visual>
                                                </VisualBrush>
                                            </Setter.Value>
                                        </Setter>
                                    </Trigger>
                                </Style.Triggers>
                            </Style>
                        </TextBox.Style>
                    </TextBox>
                </Border>
                
                <Border Style="{StaticResource InputBorderStyle}" Height="150" Margin="0,0,0,15">
                    <ListBox x:Name="EnzymeListBox" 
                             BorderThickness="0"
                             SelectionMode="Single"
                             SelectionChanged="EnzymeListBox_SelectionChanged">
                        <ListBox.ItemTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="{Binding Name}" 
                                               FontWeight="SemiBold" 
                                               Width="80"/>
                                    <TextBlock Text="{Binding RecognitionSequence}" 
                                               FontFamily="Consolas"
                                               Foreground="Gray"/>
                                </StackPanel>
                            </DataTemplate>
                        </ListBox.ItemTemplate>
                    </ListBox>
                </Border>

                <!-- Selected Enzyme Info -->
                <Border Background="#F0F0F0" 
                        CornerRadius="5" 
                        Padding="10" 
                        Margin="0,0,0,15"
                        Visibility="{Binding ElementName=SelectedEnzymePanel, Path=Visibility}">
                    <StackPanel x:Name="SelectedEnzymePanel" Visibility="Collapsed">
                        <TextBlock Text="Selected Enzyme:" FontWeight="SemiBold"/>
                        <TextBlock x:Name="SelectedEnzymeName" FontSize="16" Foreground="#0066CC"/>
                        <TextBlock x:Name="SelectedEnzymeInfo" Foreground="Gray" TextWrapping="Wrap"/>
                    </StackPanel>
                </Border>

                <!-- Marker Type -->
                <TextBlock Text="Marker Type:" Style="{StaticResource HeaderStyle}"/>
                <ComboBox x:Name="MarkerTypeCombo" 
                          Margin="0,0,0,15"
                          SelectionChanged="MarkerTypeCombo_SelectionChanged">
                    <ComboBoxItem Content="Standard (10K-250bp)" IsSelected="True"/>
                    <ComboBoxItem Content="High Resolution (10K-100bp)"/>
                </ComboBox>

                <!-- Digest Button -->
                <Button x:Name="DigestButton" 
                        Content="Digest" 
                        Height="35" 
                        FontSize="14"
                        Background="#4CAF50"
                        Foreground="White"
                        BorderThickness="0"
                        Cursor="Hand"
                        Click="DigestButton_Click"/>

                <!-- Results Summary -->
                <Border Background="#E3F2FD" 
                        CornerRadius="5" 
                        Padding="10" 
                        Margin="0,15,0,0">
                    <StackPanel x:Name="ResultsPanel" Visibility="Collapsed">
                        <TextBlock Text="Digestion Results:" FontWeight="SemiBold"/>
                        <TextBlock x:Name="CutSitesText"/>
                        <TextBlock x:Name="FragmentsText" TextWrapping="Wrap"/>
                    </StackPanel>
                </Border>

                <!-- Fragments Table -->
                <TextBlock Text="Fragments:" 
                           Style="{StaticResource HeaderStyle}" 
                           Margin="0,15,0,5"/>
                <Border Style="{StaticResource InputBorderStyle}" MaxHeight="200">
                    <DataGrid x:Name="FragmentsDataGrid"
                              AutoGenerateColumns="False"
                              IsReadOnly="True"
                              HeadersVisibility="Column"
                              GridLinesVisibility="Horizontal"
                              BorderThickness="0"
                              CanUserResizeRows="False">
                        <DataGrid.Columns>
                            <DataGridTextColumn Header="Size (bp)" 
                                                Binding="{Binding Size}" 
                                                Width="80"/>
                            <DataGridTextColumn Header="Start" 
                                                Binding="{Binding StartPosition}" 
                                                Width="60"/>
                            <DataGridTextColumn Header="End" 
                                                Binding="{Binding EndPosition}" 
                                                Width="60"/>
                            <DataGridTextColumn Header="5' Enzyme" 
                                                Binding="{Binding Enzyme5End.Name}" 
                                                Width="80"/>
                            <DataGridTextColumn Header="3' Enzyme" 
                                                Binding="{Binding Enzyme3End.Name}" 
                                                Width="80"/>
                        </DataGrid.Columns>
                    </DataGrid>
                </Border>
            </StackPanel>
        </ScrollViewer>

        <!-- Right Panel - Gel Visualization -->
        <Border Grid.Row="1" Grid.Column="1" 
                Background="#1a1a2e" 
                CornerRadius="5"
                Padding="10">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>
                
                <TextBlock Grid.Row="0" 
                           Text="Gel Electrophoresis" 
                           Foreground="White" 
                           FontSize="14" 
                           FontWeight="SemiBold"
                           Margin="0,0,0,10"/>
                
                <controls:ElectrophoresisGelControl x:Name="GelControl" 
                                                    Grid.Row="1"/>
            </Grid>
        </Border>
    </Grid>
</Page>


==================================================
FILE_NAME: RestrictionEnzymePatternPage.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\RestrictionEnzymePatternPage.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Controls;
using BioSAK.Models;
using BioSAK.Services;
using BioSAK.Controls;

namespace BioSAK.Pages
{
    /// <summary>
    /// Restriction Enzyme Pattern Predictor ?
    /// </summary>
    public partial class RestrictionEnzymePatternPage : Page
    {
        private readonly RestrictionEnzymeCutter _cutter;
        private List<RestrictionEnzyme> _allEnzymes;
        private RestrictionEnzyme _selectedEnzyme;

        public RestrictionEnzymePatternPage()
        {
            InitializeComponent();
            
            _cutter = new RestrictionEnzymeCutter();
            LoadEnzymes();
            
            // 蝬?摨?頛詨霈鈭辣
            SequenceTextBox.TextChanged += SequenceTextBox_TextChanged;
        }

        /// <summary>
        /// 頛?嗅?銵?        /// </summary>
        private void LoadEnzymes()
        {
            try
            {
                _allEnzymes = RebaseParser.LoadEnzymes();
                EnzymeListBox.ItemsSource = _allEnzymes;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading enzyme database: {ex.Message}", 
                    "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        /// <summary>
        /// 摨?頛詨霈
        /// </summary>
        private void SequenceTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            string sequence = CleanSequence(SequenceTextBox.Text);
            SequenceLengthText.Text = $"{sequence.Length} bp";
        }

        /// <summary>
        /// ?嗆?撠?        /// </summary>
        private void EnzymeSearchBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            string searchText = EnzymeSearchBox.Text.Trim();
            
            if (string.IsNullOrEmpty(searchText))
            {
                EnzymeListBox.ItemsSource = _allEnzymes;
            }
            else
            {
                var filtered = _allEnzymes
                    .Where(enzyme => 
                        enzyme.Name.IndexOf(searchText, StringComparison.OrdinalIgnoreCase) >= 0 ||
                        enzyme.RecognitionSequence.IndexOf(searchText, StringComparison.OrdinalIgnoreCase) >= 0)
                    .ToList();
                EnzymeListBox.ItemsSource = filtered;
            }
        }

        /// <summary>
        /// ?園????        /// </summary>
        private void EnzymeListBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            _selectedEnzyme = EnzymeListBox.SelectedItem as RestrictionEnzyme;
            
            if (_selectedEnzyme != null)
            {
                SelectedEnzymePanel.Visibility = Visibility.Visible;
                SelectedEnzymeName.Text = _selectedEnzyme.Name;
                
                string overhangInfo = _selectedEnzyme.OverhangType switch
                {
                    OverhangType.FivePrime => $"5' overhang ({_selectedEnzyme.GetOverhangSequence()})",
                    OverhangType.ThreePrime => $"3' overhang ({_selectedEnzyme.GetOverhangSequence()})",
                    OverhangType.Blunt => "Blunt end",
                    _ => "Unknown"
                };
                
                SelectedEnzymeInfo.Text = $"Recognition: {_selectedEnzyme.RecognitionSequence}\n" +
                                         $"Cut site: {_selectedEnzyme.CutPosition5}/{_selectedEnzyme.CutPosition3}\n" +
                                         $"End type: {overhangInfo}\n" +
                                         $"Palindromic: {(_selectedEnzyme.IsPalindromic ? "Yes" : "No")}";
            }
            else
            {
                SelectedEnzymePanel.Visibility = Visibility.Collapsed;
            }
        }

        /// <summary>
        /// Marker 憿?霈
        /// </summary>
        private void MarkerTypeCombo_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (GelControl == null) return;
            
            var markerType = MarkerTypeCombo.SelectedIndex == 0 
                ? ElectrophoresisGelControl.MarkerType.Standard 
                : ElectrophoresisGelControl.MarkerType.HighResolution;
            
            GelControl.SetMarkerType(markerType);
        }

        /// <summary>
        /// ?瑁??
        /// </summary>
        private void DigestButton_Click(object sender, RoutedEventArgs e)
        {
            // 撽?頛詨
            if (_selectedEnzyme == null)
            {
                MessageBox.Show("Please select an enzyme.", "Validation", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            string sequence = CleanSequence(SequenceTextBox.Text);
            if (string.IsNullOrEmpty(sequence))
            {
                MessageBox.Show("Please enter a DNA sequence.", "Validation", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            bool isCircular = CircularRadio.IsChecked == true;

            try
            {
                // ?瑁??
                var fragments = _cutter.DigestSequence(sequence, _selectedEnzyme, isCircular);
                var cutSites = _cutter.FindCutSites(sequence, _selectedEnzyme, isCircular);

                // ?湔蝯??Ｘ
                ResultsPanel.Visibility = Visibility.Visible;
                CutSitesText.Text = $"Cut sites found: {cutSites.Count}";
                
                if (fragments.Count > 0)
                {
                    var sizeList = fragments.Select(f => $"{f.Size} bp").ToList();
                    FragmentsText.Text = $"Fragments: {string.Join(", ", sizeList)}";
                }
                else
                {
                    FragmentsText.Text = "No fragments generated.";
                }

                // ?湔銵冽
                FragmentsDataGrid.ItemsSource = fragments;

                // ?湔?餅陶??                GelControl.SetFragments(fragments);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error during digestion: {ex.Message}", 
                    "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        /// <summary>
        /// 皜?摨?
        /// </summary>
        private string CleanSequence(string input)
        {
            if (string.IsNullOrEmpty(input))
                return string.Empty;

            // 蝘駁??DNA 摮?
            var cleaned = new System.Text.StringBuilder();
            foreach (char c in input.ToUpper())
            {
                if ("ATGCRYKMSWBDHVN".Contains(c))
                {
                    cleaned.Append(c);
                }
            }
            return cleaned.ToString();
        }
    }
}


==================================================
FILE_NAME: RestrictionEnzymePredictorPage.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\RestrictionEnzymePredictorPage.xaml
==================================================
<Page x:Class="BioSAK.Pages.RestrictionEnzymePredictorPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      xmlns:local="clr-namespace:BioSAK.Pages"
      mc:Ignorable="d" 
      d:DesignHeight="600" d:DesignWidth="900"
      Title="Restriction Enzyme Predictor"
      Background="WhiteSmoke">

    <Page.Resources>
        <Style x:Key="HeaderStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Margin" Value="0,0,0,5"/>
        </Style>
        
        <Style x:Key="InputBorderStyle" TargetType="Border">
            <Setter Property="BorderBrush" Value="#CCCCCC"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="CornerRadius" Value="3"/>
            <Setter Property="Background" Value="White"/>
        </Style>
        
        <Style x:Key="FilterButtonStyle" TargetType="ToggleButton">
            <Setter Property="Padding" Value="10,5"/>
            <Setter Property="Margin" Value="0,0,5,5"/>
            <Setter Property="Background" Value="#E0E0E0"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Style.Triggers>
                <Trigger Property="IsChecked" Value="True">
                    <Setter Property="Background" Value="#4CAF50"/>
                    <Setter Property="Foreground" Value="White"/>
                </Trigger>
            </Style.Triggers>
        </Style>
    </Page.Resources>

    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Title -->
        <TextBlock Grid.Row="0" 
                   Text="RE Cutting Site Detcetor" 
                   FontSize="20" 
                   FontWeight="Bold" 
                   Margin="0,0,0,15"/>

        <!-- Input Section -->
        <Grid Grid.Row="1">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="300"/>
            </Grid.ColumnDefinitions>

            <!-- Sequence Input -->
            <StackPanel Grid.Column="0" Margin="0,0,15,0">
                <TextBlock Text="DNA Sequence:" Style="{StaticResource HeaderStyle}"/>
                <Border Style="{StaticResource InputBorderStyle}" Margin="0,0,0,10">
                    <TextBox x:Name="SequenceTextBox" 
                             Height="100" 
                             TextWrapping="Wrap" 
                             AcceptsReturn="True"
                             VerticalScrollBarVisibility="Auto"
                             FontFamily="Consolas"
                             BorderThickness="0"
                             Padding="5"
                             TextChanged="SequenceTextBox_TextChanged"/>
                </Border>
                
                <StackPanel Orientation="Horizontal">
                    <TextBlock Text="Length: "/>
                    <TextBlock x:Name="SequenceLengthText" Text="0 bp" FontWeight="SemiBold"/>
                </StackPanel>
            </StackPanel>

            <!-- Options -->
            <StackPanel Grid.Column="1">
                <!-- Topology -->
                <TextBlock Text="Topology:" Style="{StaticResource HeaderStyle}"/>
                <StackPanel Orientation="Horizontal" Margin="0,0,0,15">
                    <RadioButton x:Name="LinearRadio" 
                                 Content="Linear" 
                                 IsChecked="True" 
                                 Margin="0,0,20,0"/>
                    <RadioButton x:Name="CircularRadio" 
                                 Content="Circular"/>
                </StackPanel>

                <!-- Enzyme Filter -->
                <TextBlock Text="Enzyme Filter:" Style="{StaticResource HeaderStyle}"/>
                <WrapPanel Margin="0,0,0,10">
                    <ToggleButton x:Name="Filter4Cutter" 
                                  Content="4-cutter" 
                                  Style="{StaticResource FilterButtonStyle}"
                                  IsChecked="True"/>
                    <ToggleButton x:Name="Filter6Cutter" 
                                  Content="6-cutter" 
                                  Style="{StaticResource FilterButtonStyle}"
                                  IsChecked="True"/>
                    <ToggleButton x:Name="Filter8Cutter" 
                                  Content="8-cutter" 
                                  Style="{StaticResource FilterButtonStyle}"
                                  IsChecked="True"/>
                    <ToggleButton x:Name="FilterOther" 
                                  Content="Other" 
                                  Style="{StaticResource FilterButtonStyle}"
                                  IsChecked="True"/>
                </WrapPanel>

                <!-- Overhang Filter -->
                <TextBlock Text="End Type Filter:" Style="{StaticResource HeaderStyle}"/>
                <WrapPanel Margin="0,0,0,10">
                    <ToggleButton x:Name="Filter5Prime" 
                                  Content="5' overhang" 
                                  Style="{StaticResource FilterButtonStyle}"
                                  IsChecked="True"/>
                    <ToggleButton x:Name="Filter3Prime" 
                                  Content="3' overhang" 
                                  Style="{StaticResource FilterButtonStyle}"
                                  IsChecked="True"/>
                    <ToggleButton x:Name="FilterBlunt" 
                                  Content="Blunt" 
                                  Style="{StaticResource FilterButtonStyle}"
                                  IsChecked="True"/>
                </WrapPanel>

                <!-- Cut Count Filter -->
                <TextBlock Text="Show enzymes with:" Style="{StaticResource HeaderStyle}"/>
                <StackPanel Orientation="Horizontal" Margin="0,0,0,15">
                    <CheckBox x:Name="ShowNoCutters" 
                              Content="No cuts (0)" 
                              IsChecked="False"
                              Margin="0,0,15,0"/>
                    <CheckBox x:Name="ShowSingleCutters" 
                              Content="Single cut (1)" 
                              IsChecked="True"
                              Margin="0,0,15,0"/>
                    <CheckBox x:Name="ShowMultiCutters" 
                              Content="Multiple cuts (2+)" 
                              IsChecked="True"/>
                </StackPanel>

                <!-- Analyze Button -->
                <Button x:Name="AnalyzeButton" 
                        Content="Analyze All Enzymes" 
                        Height="35" 
                        FontSize="14"
                        Background="#2196F3"
                        Foreground="White"
                        BorderThickness="0"
                        Cursor="Hand"
                        Click="AnalyzeButton_Click"/>
            </StackPanel>
        </Grid>

        <!-- Results Section -->
        <Grid Grid.Row="2" Margin="0,15,0,0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>

            <!-- Summary -->
            <Border Grid.Row="0" 
                    Background="#E3F2FD" 
                    CornerRadius="5" 
                    Padding="10" 
                    Margin="0,0,0,10">
                <StackPanel Orientation="Horizontal">
                    <TextBlock Text="Results: " FontWeight="SemiBold"/>
                    <TextBlock x:Name="ResultsSummaryText" Text="Enter a sequence and click Analyze"/>
                </StackPanel>
            </Border>

            <!-- Results Table -->
            <Border Grid.Row="1" Style="{StaticResource InputBorderStyle}">
                <DataGrid x:Name="ResultsDataGrid"
                          AutoGenerateColumns="False"
                          IsReadOnly="True"
                          HeadersVisibility="Column"
                          GridLinesVisibility="Horizontal"
                          BorderThickness="0"
                          CanUserResizeRows="False"
                          CanUserSortColumns="True"
                          SelectionMode="Single"
                          SelectionChanged="ResultsDataGrid_SelectionChanged">
                    <DataGrid.Columns>
                        <DataGridTextColumn Header="Enzyme" 
                                            Binding="{Binding Enzyme.Name}" 
                                            Width="100"
                                            SortMemberPath="Enzyme.Name"/>
                        <DataGridTextColumn Header="Recognition" 
                                            Binding="{Binding Enzyme.RecognitionSequence}" 
                                            Width="120">
                            <DataGridTextColumn.ElementStyle>
                                <Style TargetType="TextBlock">
                                    <Setter Property="FontFamily" Value="Consolas"/>
                                </Style>
                            </DataGridTextColumn.ElementStyle>
                        </DataGridTextColumn>
                        <DataGridTextColumn Header="Length" 
                                            Binding="{Binding Enzyme.RecognitionSequence.Length}" 
                                            Width="60"/>
                        <DataGridTextColumn Header="Cuts" 
                                            Binding="{Binding CutCount}" 
                                            Width="50"
                                            SortMemberPath="CutCount">
                            <DataGridTextColumn.ElementStyle>
                                <Style TargetType="TextBlock">
                                    <Setter Property="FontWeight" Value="Bold"/>
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding CutCount}" Value="0">
                                            <Setter Property="Foreground" Value="Gray"/>
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding CutCount}" Value="1">
                                            <Setter Property="Foreground" Value="Green"/>
                                        </DataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </DataGridTextColumn.ElementStyle>
                        </DataGridTextColumn>
                        <DataGridTextColumn Header="Cut Positions" 
                                            Binding="{Binding PositionsString}" 
                                            Width="*"/>
                        <DataGridTextColumn Header="End Type" 
                                            Binding="{Binding OverhangDescription}" 
                                            Width="100"/>
                        <DataGridTemplateColumn Header="Palindromic" Width="80">
                            <DataGridTemplateColumn.CellTemplate>
                                <DataTemplate>
                                    <TextBlock Text="{Binding Enzyme.IsPalindromic}" 
                                               HorizontalAlignment="Center">
                                        <TextBlock.Style>
                                            <Style TargetType="TextBlock">
                                                <Style.Triggers>
                                                    <DataTrigger Binding="{Binding Enzyme.IsPalindromic}" Value="True">
                                                        <Setter Property="Text" Value="??/>
                                                        <Setter Property="Foreground" Value="Green"/>
                                                    </DataTrigger>
                                                    <DataTrigger Binding="{Binding Enzyme.IsPalindromic}" Value="False">
                                                        <Setter Property="Text" Value="??/>
                                                        <Setter Property="Foreground" Value="Gray"/>
                                                    </DataTrigger>
                                                </Style.Triggers>
                                            </Style>
                                        </TextBlock.Style>
                                    </TextBlock>
                                </DataTemplate>
                            </DataGridTemplateColumn.CellTemplate>
                        </DataGridTemplateColumn>
                    </DataGrid.Columns>
                </DataGrid>
            </Border>
        </Grid>

        <!-- Detail Panel (Popup) -->
        <Popup x:Name="DetailPopup" 
               PlacementTarget="{Binding ElementName=ResultsDataGrid}"
               Placement="Right"
               StaysOpen="False">
            <Border Background="White" 
                    BorderBrush="#CCCCCC" 
                    BorderThickness="1" 
                    CornerRadius="5"
                    Padding="15"
                    MaxWidth="400">
                <StackPanel x:Name="DetailPanel">
                    <TextBlock x:Name="DetailEnzymeName" 
                               FontSize="18" 
                               FontWeight="Bold" 
                               Foreground="#2196F3"/>
                    <TextBlock x:Name="DetailRecognition" 
                               FontFamily="Consolas" 
                               FontSize="14"
                               Margin="0,5,0,10"/>
                    <TextBlock x:Name="DetailCutInfo" TextWrapping="Wrap"/>
                    <TextBlock x:Name="DetailPositions" 
                               TextWrapping="Wrap" 
                               Margin="0,10,0,0"/>
                </StackPanel>
            </Border>
        </Popup>
    </Grid>
</Page>


==================================================
FILE_NAME: RestrictionEnzymePredictorPage.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\RestrictionEnzymePredictorPage.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using BioSAK.Models;
using BioSAK.Services;

namespace BioSAK.Pages
{
    /// <summary>
    /// Restriction Enzyme Predictor ? - ???????脫?瘜?    /// </summary>
    public partial class RestrictionEnzymePredictorPage : Page
    {
        private readonly RestrictionEnzymeCutter _cutter;
        private List<RestrictionEnzyme> _allEnzymes;
        private List<EnzymeAnalysisResult> _allResults;

        public RestrictionEnzymePredictorPage()
        {
            InitializeComponent();
            
            _cutter = new RestrictionEnzymeCutter();
            LoadEnzymes();
        }

        /// <summary>
        /// 頛?嗅?銵?        /// </summary>
        private void LoadEnzymes()
        {
            try
            {
                _allEnzymes = RebaseParser.LoadEnzymes();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading enzyme database: {ex.Message}", 
                    "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                _allEnzymes = new List<RestrictionEnzyme>();
            }
        }

        /// <summary>
        /// 摨?頛詨霈
        /// </summary>
        private void SequenceTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            string sequence = CleanSequence(SequenceTextBox.Text);
            SequenceLengthText.Text = $"{sequence.Length} bp";
        }

        /// <summary>
        /// ????暺?
        /// </summary>
        private void AnalyzeButton_Click(object sender, RoutedEventArgs e)
        {
            string sequence = CleanSequence(SequenceTextBox.Text);
            
            if (string.IsNullOrEmpty(sequence))
            {
                MessageBox.Show("Please enter a DNA sequence.", "Validation", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            bool isCircular = CircularRadio.IsChecked == true;

            try
            {
                // ????
                _allResults = _cutter.AnalyzeAllEnzymes(sequence, _allEnzymes, isCircular);
                
                // 憟蝭拚
                ApplyFilters();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error during analysis: {ex.Message}", 
                    "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        /// <summary>
        /// 憟蝭拚璇辣
        /// </summary>
        private void ApplyFilters()
        {
            if (_allResults == null || _allResults.Count == 0)
            {
                ResultsDataGrid.ItemsSource = null;
                ResultsSummaryText.Text = "No results to display.";
                return;
            }

            var filtered = _allResults.AsEnumerable();

            // 蝭拚霅摨??瑕漲
            var allowedLengths = new List<int>();
            if (Filter4Cutter.IsChecked == true) allowedLengths.Add(4);
            if (Filter6Cutter.IsChecked == true) allowedLengths.Add(6);
            if (Filter8Cutter.IsChecked == true) allowedLengths.Add(8);

            if (allowedLengths.Count > 0)
            {
                if (FilterOther.IsChecked == true)
                {
                    filtered = filtered.Where(r => 
                        allowedLengths.Contains(r.Enzyme.RecognitionSequence.Length) ||
                        !new[] { 4, 6, 8 }.Contains(r.Enzyme.RecognitionSequence.Length));
                }
                else
                {
                    filtered = filtered.Where(r => 
                        allowedLengths.Contains(r.Enzyme.RecognitionSequence.Length));
                }
            }
            else if (FilterOther.IsChecked == true)
            {
                filtered = filtered.Where(r => 
                    !new[] { 4, 6, 8 }.Contains(r.Enzyme.RecognitionSequence.Length));
            }

            // 蝭拚?怎垢憿?
            var allowedOverhangs = new List<OverhangType>();
            if (Filter5Prime.IsChecked == true) allowedOverhangs.Add(OverhangType.FivePrime);
            if (Filter3Prime.IsChecked == true) allowedOverhangs.Add(OverhangType.ThreePrime);
            if (FilterBlunt.IsChecked == true) allowedOverhangs.Add(OverhangType.Blunt);

            if (allowedOverhangs.Count > 0 && allowedOverhangs.Count < 3)
            {
                filtered = filtered.Where(r => allowedOverhangs.Contains(r.Enzyme.OverhangType));
            }

            // 蝭拚?甈⊥
            filtered = filtered.Where(r =>
            {
                if (r.CutCount == 0) return ShowNoCutters.IsChecked == true;
                if (r.CutCount == 1) return ShowSingleCutters.IsChecked == true;
                return ShowMultiCutters.IsChecked == true;
            });

            var resultList = filtered.ToList();
            ResultsDataGrid.ItemsSource = resultList;

            // ?湔??
            int totalEnzymes = resultList.Count;
            int cutters = resultList.Count(r => r.CutCount > 0);
            int singleCutters = resultList.Count(r => r.CutCount == 1);
            
            ResultsSummaryText.Text = $"{totalEnzymes} enzymes shown | " +
                                      $"{cutters} cut the sequence | " +
                                      $"{singleCutters} single cutters";
        }

        /// <summary>
        /// ?豢?蝯??
        /// </summary>
        private void ResultsDataGrid_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            var selected = ResultsDataGrid.SelectedItem as EnzymeAnalysisResult;
            
            if (selected != null)
            {
                DetailEnzymeName.Text = selected.Enzyme.Name;
                DetailRecognition.Text = $"Recognition: {selected.Enzyme.RecognitionSequence}";
                
                string overhangInfo = selected.Enzyme.OverhangType switch
                {
                    OverhangType.FivePrime => $"5' overhang ({selected.Enzyme.GetOverhangSequence()})",
                    OverhangType.ThreePrime => $"3' overhang ({selected.Enzyme.GetOverhangSequence()})",
                    OverhangType.Blunt => "Blunt end",
                    _ => "Unknown"
                };
                
                DetailCutInfo.Text = $"Cut positions: {selected.Enzyme.CutPosition5}/{selected.Enzyme.CutPosition3}\n" +
                                    $"End type: {overhangInfo}\n" +
                                    $"Palindromic: {(selected.Enzyme.IsPalindromic ? "Yes" : "No")}\n" +
                                    $"Number of cuts: {selected.CutCount}";

                if (selected.CutCount > 0)
                {
                    var positionDetails = selected.CutSites
                        .Select(cs => $"  Position {cs.Position}: " +
                                     $"5' cut at {cs.Cut5Position}, " +
                                     $"3' cut at {cs.Cut3Position}")
                        .ToList();
                    
                    DetailPositions.Text = "Cut site details:\n" + string.Join("\n", positionDetails);
                }
                else
                {
                    DetailPositions.Text = "No cut sites in this sequence.";
                }

                DetailPopup.IsOpen = true;
            }
            else
            {
                DetailPopup.IsOpen = false;
            }
        }

        /// <summary>
        /// 皜?摨?
        /// </summary>
        private string CleanSequence(string input)
        {
            if (string.IsNullOrEmpty(input))
                return string.Empty;

            var cleaned = new System.Text.StringBuilder();
            foreach (char c in input.ToUpper())
            {
                if ("ATGCRYKMSWBDHVN".Contains(c))
                {
                    cleaned.Append(c);
                }
            }
            return cleaned.ToString();
        }
    }
}


==================================================
FILE_NAME: sgRNADesignerPage.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\sgRNADesignerPage.xaml
==================================================
<Page x:Class="BioSAK.Pages.sgRNADesignerPage"

      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"

      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"

      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 

      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 

      mc:Ignorable="d" 

      d:DesignHeight="750" d:DesignWidth="1100"

      Title="sgRNA Designer"

      Background="#F5F5F5">



    <Page.Resources>

        <Style x:Key="PrimaryButtonStyle" TargetType="Button">

            <Setter Property="Background" Value="#2196F3"/>

            <Setter Property="Foreground" Value="White"/>

            <Setter Property="BorderThickness" Value="0"/>

            <Setter Property="Padding" Value="16,10"/>

            <Setter Property="FontSize" Value="13"/>

            <Setter Property="Cursor" Value="Hand"/>

            <Setter Property="Template">

                <Setter.Value>

                    <ControlTemplate TargetType="Button">

                        <Border x:Name="border" Background="{TemplateBinding Background}"

                                CornerRadius="5" Padding="{TemplateBinding Padding}">

                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>

                        </Border>

                        <ControlTemplate.Triggers>

                            <Trigger Property="IsMouseOver" Value="True">

                                <Setter TargetName="border" Property="Background" Value="#1976D2"/>

                            </Trigger>

                            <Trigger Property="IsEnabled" Value="False">

                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>

                            </Trigger>

                        </ControlTemplate.Triggers>

                    </ControlTemplate>

                </Setter.Value>

            </Setter>

        </Style>



        <Style x:Key="SecondaryButtonStyle" TargetType="Button">

            <Setter Property="Background" Value="#4CAF50"/>

            <Setter Property="Foreground" Value="White"/>

            <Setter Property="BorderThickness" Value="0"/>

            <Setter Property="Padding" Value="15,8"/>

            <Setter Property="FontSize" Value="12"/>

            <Setter Property="Cursor" Value="Hand"/>

            <Setter Property="Template">

                <Setter.Value>

                    <ControlTemplate TargetType="Button">

                        <Border x:Name="border" Background="{TemplateBinding Background}"

                                CornerRadius="4" Padding="{TemplateBinding Padding}">

                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>

                        </Border>

                        <ControlTemplate.Triggers>

                            <Trigger Property="IsMouseOver" Value="True">

                                <Setter TargetName="border" Property="Background" Value="#388E3C"/>

                            </Trigger>

                            <Trigger Property="IsEnabled" Value="False">

                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>

                            </Trigger>

                        </ControlTemplate.Triggers>

                    </ControlTemplate>

                </Setter.Value>

            </Setter>

        </Style>



        <Style x:Key="SmallButtonStyle" TargetType="Button">

            <Setter Property="Background" Value="#FF9800"/>

            <Setter Property="Foreground" Value="White"/>

            <Setter Property="BorderThickness" Value="0"/>

            <Setter Property="Padding" Value="10,5"/>

            <Setter Property="FontSize" Value="11"/>

            <Setter Property="Cursor" Value="Hand"/>

            <Setter Property="Template">

                <Setter.Value>

                    <ControlTemplate TargetType="Button">

                        <Border x:Name="border" Background="{TemplateBinding Background}"

                                CornerRadius="3" Padding="{TemplateBinding Padding}">

                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>

                        </Border>

                        <ControlTemplate.Triggers>

                            <Trigger Property="IsMouseOver" Value="True">

                                <Setter TargetName="border" Property="Background" Value="#F57C00"/>

                            </Trigger>

                            <Trigger Property="IsEnabled" Value="False">

                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>

                            </Trigger>

                        </ControlTemplate.Triggers>

                    </ControlTemplate>

                </Setter.Value>

            </Setter>

        </Style>



        <Style x:Key="CardStyle" TargetType="Border">

            <Setter Property="Background" Value="White"/>

            <Setter Property="BorderBrush" Value="#E0E0E0"/>

            <Setter Property="BorderThickness" Value="1"/>

            <Setter Property="CornerRadius" Value="8"/>

            <Setter Property="Padding" Value="15"/>

        </Style>



        <Style x:Key="LabelStyle" TargetType="TextBlock">

            <Setter Property="FontSize" Value="12"/>

            <Setter Property="FontWeight" Value="SemiBold"/>

            <Setter Property="Foreground" Value="#555"/>

            <Setter Property="Margin" Value="0,0,0,5"/>

        </Style>



        <Style x:Key="InputStyle" TargetType="TextBox">

            <Setter Property="Padding" Value="10,8"/>

            <Setter Property="FontSize" Value="13"/>

            <Setter Property="BorderBrush" Value="#DDD"/>

            <Setter Property="BorderThickness" Value="1"/>

            <Setter Property="Background" Value="White"/>

        </Style>



        <Style x:Key="ComboStyle" TargetType="ComboBox">

            <Setter Property="Padding" Value="10,8"/>

            <Setter Property="FontSize" Value="13"/>

            <Setter Property="BorderBrush" Value="#DDD"/>

            <Setter Property="BorderThickness" Value="1"/>

            <Setter Property="Background" Value="White"/>

        </Style>



        <!-- GridSplitter 璅?? -->

        <Style x:Key="HorizontalSplitterStyle" TargetType="GridSplitter">

            <Setter Property="Height" Value="6"/>

            <Setter Property="HorizontalAlignment" Value="Stretch"/>

            <Setter Property="VerticalAlignment" Value="Center"/>

            <Setter Property="Background" Value="Transparent"/>

            <Setter Property="Cursor" Value="SizeNS"/>

            <Setter Property="Template">

                <Setter.Value>

                    <ControlTemplate TargetType="GridSplitter">

                        <Border Background="Transparent" Height="6">

                            <Grid>

                                <Border Height="2" VerticalAlignment="Center" Background="#E0E0E0" CornerRadius="1" Margin="50,0"/>

                                <Border Width="30" Height="4" VerticalAlignment="Center" HorizontalAlignment="Center" Background="#BDBDBD" CornerRadius="2"/>

                            </Grid>

                        </Border>

                    </ControlTemplate>

                </Setter.Value>

            </Setter>

            <Style.Triggers>

                <Trigger Property="IsMouseOver" Value="True">

                    <Setter Property="Background" Value="#E3F2FD"/>

                </Trigger>

            </Style.Triggers>

        </Style>

    </Page.Resources>



    <Grid Margin="15">

        <Grid.RowDefinitions>

            <RowDefinition Height="Auto"/>

            <RowDefinition Height="*"/>

        </Grid.RowDefinitions>



        <!-- ?舀???頛詨? -->

        <Border Grid.Row="0" Background="White" CornerRadius="8" BorderBrush="#E0E0E0" BorderThickness="1" Margin="0,0,0,10">

            <Grid>

                <Grid.RowDefinitions>

                    <RowDefinition Height="Auto"/>

                    <RowDefinition Height="Auto"/>

                </Grid.RowDefinitions>



                <!-- ??璅???-->

                <Border Grid.Row="0" Background="#FAFAFA" CornerRadius="8,8,0,0" Padding="12,10" 

                        MouseLeftButtonDown="InputHeader_Click" Cursor="Hand">

                    <Grid>

                        <StackPanel Orientation="Horizontal">

                            <TextBlock x:Name="CollapseArrow" Text="?? FontSize="12" Foreground="#666" VerticalAlignment="Center" Margin="0,0,8,0"/>

                            <TextBlock Text="sgRNA Designer" FontSize="16" FontWeight="Bold" Foreground="#333" VerticalAlignment="Center"/>

                            <TextBlock x:Name="InputSectionSummary" Text="" FontSize="12" Foreground="#4CAF50" VerticalAlignment="Center" Margin="15,0,0,0" FontWeight="SemiBold"/>

                        </StackPanel>

                        <TextBlock Text="Click to expand/collapse" FontSize="10" Foreground="#999" HorizontalAlignment="Right" VerticalAlignment="Center"/>

                    </Grid>

                </Border>



                <!-- ?舀???頛詨?批捆 -->

                <Border x:Name="InputContentPanel" Grid.Row="1" Padding="15" BorderBrush="#EEEEEE" BorderThickness="0,1,0,0">

                    <Grid>

                        <Grid.ColumnDefinitions>

                            <ColumnDefinition Width="*"/>

                            <ColumnDefinition Width="25"/>

                            <ColumnDefinition Width="*"/>

                        </Grid.ColumnDefinitions>



                        <!-- 撌血嚗earch Gene (蝪∪???- ?芯???蝔望?撠? -->

                        <StackPanel Grid.Column="0">

                            <TextBlock Text="?? Search Gene" FontSize="14" FontWeight="SemiBold" Foreground="#333" Margin="0,0,0,10"/>



                            <Grid>

                                <Grid.ColumnDefinitions>

                                    <ColumnDefinition Width="*"/>

                                    <ColumnDefinition Width="10"/>

                                    <ColumnDefinition Width="Auto"/>

                                </Grid.ColumnDefinitions>



                                <StackPanel Grid.Column="0">

                                    <TextBlock Text="Gene Name / ID" Style="{StaticResource LabelStyle}"/>

                                    <TextBox x:Name="GeneQueryTextBox" Style="{StaticResource InputStyle}" 

                                             Text="ACTB"

                                             ToolTip="Enter gene symbol (ACTB), Ensembl ID (ENSG00000075624), or NCBI Gene ID (60)"/>

                                    <TextBlock Text="Accepts: Symbol, ENSG ID, NCBI ID" FontSize="9" Foreground="#888" Margin="0,3,0,0"/>

                                </StackPanel>



                                <StackPanel Grid.Column="2">

                                    <TextBlock Text="Species" Style="{StaticResource LabelStyle}"/>

                                    <ComboBox x:Name="SpeciesComboBox" Style="{StaticResource ComboStyle}" Width="140">

                                        <ComboBoxItem Content="Homo sapiens" IsSelected="True" Tag="9606"/>

                                        <ComboBoxItem Content="Mus musculus" Tag="10090"/>

                                        <ComboBoxItem Content="Rattus norvegicus" Tag="10116"/>

                                    </ComboBox>

                                </StackPanel>

                            </Grid>



                            <!-- ??蝯??內 -->

                            <TextBlock x:Name="SearchResultHint" Text="" FontSize="10" Foreground="#1565C0" 

                                       Margin="0,8,0,0" TextWrapping="Wrap" FontStyle="Italic"/>



                            <Button x:Name="FetchGeneButton" Content="?? Fetch Gene" 

                                    Style="{StaticResource PrimaryButtonStyle}" Margin="0,10,0,0"

                                    Click="FetchGeneButton_Click"/>

                        </StackPanel>



                        <!-- ??蝺?-->

                        <Rectangle Grid.Column="1" Width="1" Fill="#E0E0E0" Margin="12,0"/>



                        <!-- ?喳嚗nput DNA Sequence -->

                        <StackPanel Grid.Column="2">

                            <TextBlock Text="?? Input DNA Sequence" FontSize="14" FontWeight="SemiBold" Foreground="#333" Margin="0,0,0,10"/>



                            <TextBlock Text="Paste CDS/mRNA sequence (FASTA or plain)" Style="{StaticResource LabelStyle}"/>

                            <TextBox x:Name="SequenceInputTextBox" Style="{StaticResource InputStyle}" 

                                     Height="70" AcceptsReturn="True" TextWrapping="Wrap"

                                     VerticalScrollBarVisibility="Auto" FontFamily="Consolas" FontSize="10"/>

                            <TextBlock Text="Treats entire sequence as one exon for sgRNA design" FontSize="9" Foreground="#888" Margin="0,4,0,0"/>



                            <Button x:Name="AlignSequenceButton" Content="?妞 Find sgRNAs in Sequence" 

                                    Style="{StaticResource PrimaryButtonStyle}" Margin="0,10,0,0"

                                    Click="AlignSequenceButton_Click"/>

                        </StackPanel>

                    </Grid>

                </Border>

            </Grid>

        </Border>



        <!-- 銝餉??批捆? -->

        <Border Grid.Row="1" Style="{StaticResource CardStyle}">

            <Grid>

                <Grid.RowDefinitions>

                    <RowDefinition Height="Auto"/>

                    <RowDefinition Height="Auto"/>

                    <RowDefinition Height="Auto" MinHeight="100"/>

                    <RowDefinition Height="Auto"/>

                    <RowDefinition Height="*" MinHeight="120"/>

                    <RowDefinition Height="Auto"/>

                    <RowDefinition Height="Auto"/>

                </Grid.RowDefinitions>



                <!-- ?批??-->

                <Grid Grid.Row="0" Margin="0,0,0,8">

                    <Grid.ColumnDefinitions>

                        <ColumnDefinition Width="Auto"/>

                        <ColumnDefinition Width="*"/>

                        <ColumnDefinition Width="Auto"/>

                    </Grid.ColumnDefinitions>



                    <Button x:Name="AnalyzeButton" Grid.Column="0" Content="?妞 Find sgRNAs in CDS" 

                            Style="{StaticResource SecondaryButtonStyle}" IsEnabled="False"

                            Click="AnalyzeButton_Click"/>



                    <StackPanel Grid.Column="2" Orientation="Horizontal">

                        <TextBlock Text="PAM:" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="#555" FontSize="12"/>

                        <ComboBox x:Name="PAMComboBox" Width="95" Style="{StaticResource ComboStyle}" FontSize="12">

                            <ComboBoxItem Content="NGG (SpCas9)" IsSelected="True"/>

                            <ComboBoxItem Content="NAG (SpCas9)"/>

                        </ComboBox>

                        <TextBlock Text="Len:" VerticalAlignment="Center" Margin="10,0,5,0" Foreground="#555" FontSize="12"/>

                        <ComboBox x:Name="sgRNALengthComboBox" Width="50" Style="{StaticResource ComboStyle}" FontSize="12">

                            <ComboBoxItem Content="18"/>

                            <ComboBoxItem Content="19"/>

                            <ComboBoxItem Content="20" IsSelected="True"/>

                        </ComboBox>

                    </StackPanel>

                </Grid>



                <!-- ??? -->

                <Border Grid.Row="1" Background="#E3F2FD" CornerRadius="4" Padding="10,6" Margin="0,0,0,8"

                        x:Name="InfoBar" Visibility="Collapsed">

                    <StackPanel Orientation="Horizontal">

                        <TextBlock x:Name="InfoIcon" Text="?對?" Margin="0,0,6,0"/>

                        <TextBlock x:Name="InfoText" Text="" Foreground="#1565C0" TextWrapping="Wrap" FontSize="12"/>

                    </StackPanel>

                </Border>



                <!-- Gene 閬死?? -->

                <Border Grid.Row="2" Background="#FAFAFA" CornerRadius="5" 

                        BorderBrush="#E0E0E0" BorderThickness="1"

                        x:Name="VisualizationBorder" MinHeight="120">

                    <Grid>

                        <Grid.RowDefinitions>

                            <RowDefinition Height="Auto"/>

                            <RowDefinition Height="*"/>

                        </Grid.RowDefinitions>



                        <Border Grid.Row="0" Background="#EEEEEE" Padding="8,4">

                            <Grid>

                                <StackPanel Orientation="Horizontal">

                                    <TextBlock Text="?? Gene Structure" FontWeight="SemiBold" Foreground="#333" FontSize="11"/>

                                    <TextBlock x:Name="GeneInfoLabel" Text="" Foreground="#666" Margin="10,0,0,0" FontSize="10"/>

                                </StackPanel>



                                <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">

                                    <Button x:Name="ZoomOutButton" Content="?? Width="22" Height="20" 

                                            FontSize="14" FontWeight="Bold" Padding="0" Margin="0,0,2,0"

                                            Click="ZoomOutButton_Click" ToolTip="Zoom Out"

                                            Background="#E0E0E0" BorderThickness="0" Cursor="Hand"/>

                                    <Button x:Name="ZoomResetButton" Content="?? Width="22" Height="20" 

                                            FontSize="11" Padding="0" Margin="0,0,2,0"

                                            Click="ZoomResetButton_Click" ToolTip="Reset Zoom"

                                            Background="#E0E0E0" BorderThickness="0" Cursor="Hand"/>

                                    <Button x:Name="ZoomInButton" Content="+" Width="22" Height="20" 

                                            FontSize="14" FontWeight="Bold" Padding="0" Margin="0,0,12,0"

                                            Click="ZoomInButton_Click" ToolTip="Zoom In"

                                            Background="#E0E0E0" BorderThickness="0" Cursor="Hand"/>



                                    <!-- ?? -->

                                    <Rectangle Width="14" Height="8" Fill="#C8E6C9" Stroke="#4CAF50" StrokeThickness="1" RadiusX="2" RadiusY="2" VerticalAlignment="Center"/>

                                    <TextBlock Text="Exon" FontSize="9" Foreground="#666" Margin="3,0,10,0" VerticalAlignment="Center"/>

                                    <Rectangle Width="14" Height="8" Fill="#FFB74D" Stroke="#FF9800" StrokeThickness="1" RadiusX="2" RadiusY="2" VerticalAlignment="Center"/>

                                    <TextBlock Text="CDS" FontSize="9" Foreground="#666" Margin="3,0,10,0" VerticalAlignment="Center"/>

                                    <Ellipse Width="8" Height="8" Fill="#2196F3" VerticalAlignment="Center"/>

                                    <TextBlock Text="sgRNA" FontSize="9" Foreground="#666" Margin="3,0,10,0" VerticalAlignment="Center"/>

                                    <Ellipse Width="8" Height="8" Fill="#FF9800" VerticalAlignment="Center"/>

                                    <TextBlock Text="潃? FontSize="9" Foreground="#666" Margin="3,0,0,0" VerticalAlignment="Center"/>

                                </StackPanel>

                            </Grid>

                        </Border>



                        <ScrollViewer Grid.Row="1" 

                                      x:Name="GeneVisualizationScrollViewer"

                                      HorizontalScrollBarVisibility="Auto" 

                                      VerticalScrollBarVisibility="Disabled"

                                      MinHeight="90"

                                      PreviewMouseWheel="GeneVisualizationScrollViewer_PreviewMouseWheel">

                            <Canvas x:Name="GeneVisualizationCanvas" MinHeight="90" Background="White" ClipToBounds="True"/>

                        </ScrollViewer>



                        <TextBlock x:Name="EmptyVisualizationText" Grid.Row="1"

                                   Text="Fetch gene data to begin" Foreground="#AAA" FontStyle="Italic" FontSize="11"

                                   HorizontalAlignment="Center" VerticalAlignment="Center"/>

                    </Grid>

                </Border>



                <!-- GridSplitter -->

                <GridSplitter Grid.Row="3" Style="{StaticResource HorizontalSplitterStyle}"

                              ResizeDirection="Rows" ResizeBehavior="PreviousAndNext"

                              Margin="0,4"/>



                <!-- sgRNA ?”? -->

                <Border Grid.Row="4" BorderBrush="#E0E0E0" BorderThickness="1" CornerRadius="5" MinHeight="120">

                    <Grid>

                        <Grid.RowDefinitions>

                            <RowDefinition Height="Auto"/>

                            <RowDefinition Height="*"/>

                        </Grid.RowDefinitions>



                        <Border Grid.Row="0" Background="#EEEEEE" Padding="8,4">

                            <Grid>

                                <StackPanel Orientation="Horizontal">

                                    <TextBlock Text="? sgRNA Candidates" FontWeight="SemiBold" Foreground="#333" FontSize="11"/>

                                    <TextBlock x:Name="sgRNACountLabel" Text="" Foreground="#666" Margin="10,0,0,0" FontSize="10"/>

                                </StackPanel>

                                <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">

                                    <TextBlock Text="潃?= Recommended" FontSize="9" Foreground="#FF9800" VerticalAlignment="Center"/>

                                </StackPanel>

                            </Grid>

                        </Border>



                        <DataGrid x:Name="sgRNADataGrid" Grid.Row="1"

                                  AutoGenerateColumns="False"

                                  IsReadOnly="False"

                                  SelectionMode="Extended"

                                  GridLinesVisibility="Horizontal"

                                  HeadersVisibility="Column"

                                  BorderThickness="0"

                                  Background="White"

                                  RowBackground="White"

                                  AlternatingRowBackground="#FAFAFA"

                                  CanUserSortColumns="True"

                                  SelectionChanged="sgRNADataGrid_SelectionChanged"

                                  FontSize="11">

                            <DataGrid.Columns>

                                <!-- ?券?暸獢?Header -->

                                <DataGridTemplateColumn Width="30">

                                    <DataGridTemplateColumn.Header>

                                        <CheckBox x:Name="SelectAllCheckBox" 

                                                  Click="SelectAllCheckBox_Click"

                                                  ToolTip="Select All / Deselect All"/>

                                    </DataGridTemplateColumn.Header>

                                    <DataGridTemplateColumn.CellTemplate>

                                        <DataTemplate>

                                            <CheckBox IsChecked="{Binding IsSelected, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"

                                                      HorizontalAlignment="Center"/>

                                        </DataTemplate>

                                    </DataGridTemplateColumn.CellTemplate>

                                </DataGridTemplateColumn>

                                <DataGridTextColumn Header="#" Binding="{Binding Index}" Width="28" IsReadOnly="True"/>

                                <DataGridTextColumn Header="Position" Binding="{Binding PositionDisplay}" Width="80" IsReadOnly="True"/>

                                <DataGridTextColumn Header="E" Binding="{Binding ExonDisplay}" Width="28" IsReadOnly="True"/>

                                <DataGridTextColumn Header="sgRNA Sequence (5'??')" Binding="{Binding Sequence}" Width="*" IsReadOnly="True">

                                    <DataGridTextColumn.ElementStyle>

                                        <Style TargetType="TextBlock">

                                            <Setter Property="FontFamily" Value="Consolas"/>

                                        </Style>

                                    </DataGridTextColumn.ElementStyle>

                                </DataGridTextColumn>

                                <DataGridTextColumn Header="PAM" Binding="{Binding PAM}" Width="38" IsReadOnly="True">

                                    <DataGridTextColumn.ElementStyle>

                                        <Style TargetType="TextBlock">

                                            <Setter Property="FontFamily" Value="Consolas"/>

                                            <Setter Property="Foreground" Value="#E65100"/>

                                            <Setter Property="FontWeight" Value="SemiBold"/>

                                        </Style>

                                    </DataGridTextColumn.ElementStyle>

                                </DataGridTextColumn>

                                <DataGridTextColumn Header="簣" Binding="{Binding Strand}" Width="22" IsReadOnly="True"/>

                                <DataGridTextColumn Header="GC" Binding="{Binding GCContent}" Width="35" IsReadOnly="True"/>

                                <DataGridTextColumn Header="" Binding="{Binding RecommendDisplay}" Width="20" IsReadOnly="True">

                                    <DataGridTextColumn.ElementStyle>

                                        <Style TargetType="TextBlock">

                                            <Setter Property="HorizontalAlignment" Value="Center"/>

                                        </Style>

                                    </DataGridTextColumn.ElementStyle>

                                </DataGridTextColumn>

                                <DataGridTextColumn Header="+1 ins" Binding="{Binding FrameshiftPlus1}" Width="55" IsReadOnly="True"

                                                    ToolTipService.ToolTip="Protein truncation with +1 nucleotide insertion">

                                    <DataGridTextColumn.ElementStyle>

                                        <Style TargetType="TextBlock">

                                            <Setter Property="Foreground" Value="#D32F2F"/>

                                            <Setter Property="FontSize" Value="10"/>

                                        </Style>

                                    </DataGridTextColumn.ElementStyle>

                                </DataGridTextColumn>

                                <DataGridTextColumn Header="+2 ins" Binding="{Binding FrameshiftPlus2}" Width="55" IsReadOnly="True"

                                                    ToolTipService.ToolTip="Protein truncation with +2 nucleotide insertion">

                                    <DataGridTextColumn.ElementStyle>

                                        <Style TargetType="TextBlock">

                                            <Setter Property="Foreground" Value="#D32F2F"/>

                                            <Setter Property="FontSize" Value="10"/>

                                        </Style>

                                    </DataGridTextColumn.ElementStyle>

                                </DataGridTextColumn>

                                <DataGridTemplateColumn Header="BLAST" Width="65">

                                    <DataGridTemplateColumn.CellTemplate>

                                        <DataTemplate>

                                            <Button Content="BLAST" Style="{StaticResource SmallButtonStyle}"

                                                    Click="BlastSingle_Click" Tag="{Binding}" Padding="5,2" FontSize="10"/>

                                        </DataTemplate>

                                    </DataGridTemplateColumn.CellTemplate>

                                </DataGridTemplateColumn>

                            </DataGrid.Columns>

                            <DataGrid.RowStyle>

                                <Style TargetType="DataGridRow">

                                    <Style.Triggers>

                                        <DataTrigger Binding="{Binding IsRecommended}" Value="True">

                                            <Setter Property="Background" Value="#FFF8E1"/>

                                        </DataTrigger>

                                    </Style.Triggers>

                                </Style>

                            </DataGrid.RowStyle>

                        </DataGrid>



                        <TextBlock x:Name="EmptyListText" Grid.Row="1"

                                   Text="Click 'Find sgRNAs in CDS' after loading gene"

                                   Foreground="#AAA" FontStyle="Italic" FontSize="10"

                                   HorizontalAlignment="Center" VerticalAlignment="Center"/>

                    </Grid>

                </Border>



                <!-- ?刻璇辣隤芣? -->

                <Border Grid.Row="5" Background="#FFFDE7" CornerRadius="4" Padding="10,6" Margin="0,8,0,0"

                        BorderBrush="#FFE082" BorderThickness="1">

                    <StackPanel Orientation="Horizontal">

                        <TextBlock Text="潃? FontSize="12" Margin="0,0,6,0"/>

                        <TextBlock Text="Recommended criteria:" FontWeight="SemiBold" Foreground="#F57F17" FontSize="11" Margin="0,0,8,0"/>

                        <TextBlock Text="Starts with" Foreground="#666" FontSize="11"/>

                        <TextBlock Text=" G " FontFamily="Consolas" FontWeight="Bold" Foreground="#1565C0" FontSize="11"/>

                        <TextBlock Text="+ Ends with" Foreground="#666" FontSize="11"/>

                        <TextBlock Text=" A " FontFamily="Consolas" FontWeight="Bold" Foreground="#1565C0" FontSize="11"/>

                        <TextBlock Text="(before PAM) + GC content" Foreground="#666" FontSize="11"/>

                        <TextBlock Text=" 40-60%" FontWeight="Bold" Foreground="#1565C0" FontSize="11"/>

                    </StackPanel>

                </Border>



                <!-- 摨?? -->

                <Border Grid.Row="6" Padding="0,8,0,0" BorderBrush="#E0E0E0" BorderThickness="0,1,0,0" Margin="0,8,0,0">

                    <Grid>

                        <Grid.ColumnDefinitions>

                            <ColumnDefinition Width="Auto"/>

                            <ColumnDefinition Width="Auto"/>

                            <ColumnDefinition Width="*"/>

                        </Grid.ColumnDefinitions>



                        <StackPanel Grid.Column="0" Orientation="Horizontal">

                            <Button x:Name="ExportButton" Content="? Export" 

                                    Style="{StaticResource SecondaryButtonStyle}"

                                    IsEnabled="False" Click="ExportButton_Click" Padding="12,6"/>

                            <Button x:Name="CopyButton" Content="?? Copy" 

                                    Style="{StaticResource SecondaryButtonStyle}"

                                    Margin="6,0,0,0" IsEnabled="False" Click="CopyButton_Click" Padding="12,6"/>

                            <Button x:Name="BlastAllButton" Content="? BLAST Selected" 

                                    Style="{StaticResource SmallButtonStyle}"

                                    Margin="6,0,0,0" IsEnabled="False" Click="BlastAllButton_Click"/>

                        </StackPanel>



                        <Rectangle Grid.Column="1" Width="1" Fill="#E0E0E0" Margin="15,2"/>



                        <StackPanel Grid.Column="2" Orientation="Horizontal">

                            <Button x:Name="FrameshiftAnalysisButton" Content="?妞 Frameshift Analysis" 

                                    Background="#9C27B0" Foreground="White" BorderThickness="0"

                                    Padding="12,6" FontSize="12" Cursor="Hand"

                                    IsEnabled="False" Click="FrameshiftAnalysisButton_Click"

                                    ToolTip="Analyze protein truncation caused by +1/+2 frameshift after Cas9 cleavage">

                                <Button.Template>

                                    <ControlTemplate TargetType="Button">

                                        <Border x:Name="border" Background="{TemplateBinding Background}"

                                                CornerRadius="4" Padding="{TemplateBinding Padding}">

                                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>

                                        </Border>

                                        <ControlTemplate.Triggers>

                                            <Trigger Property="IsMouseOver" Value="True">

                                                <Setter TargetName="border" Property="Background" Value="#7B1FA2"/>

                                            </Trigger>

                                            <Trigger Property="IsEnabled" Value="False">

                                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>

                                            </Trigger>

                                        </ControlTemplate.Triggers>

                                    </ControlTemplate>

                                </Button.Template>

                            </Button>



                            <StackPanel x:Name="AnalysisProgressPanel" Orientation="Horizontal" 

                                        Margin="10,0,0,0" Visibility="Collapsed" VerticalAlignment="Center">

                                <ProgressBar x:Name="AnalysisProgressBar" Width="100" Height="14" 

                                             Minimum="0" Maximum="100" Value="0" Foreground="#9C27B0"/>

                                <TextBlock x:Name="AnalysisProgressText" Text="0%" 

                                           Margin="6,0,0,0" VerticalAlignment="Center" 

                                           Foreground="#666" FontSize="11" MinWidth="35"/>

                            </StackPanel>



                            <TextBlock x:Name="SelectedCountText" Text="" 

                                       Margin="10,0,0,0" VerticalAlignment="Center"

                                       Foreground="#666" FontSize="11" FontStyle="Italic"/>

                        </StackPanel>

                    </Grid>

                </Border>

            </Grid>

        </Border>



        <!-- Loading Overlay -->

        <Border x:Name="LoadingOverlay" Grid.RowSpan="2" Background="#80FFFFFF" Visibility="Collapsed">

            <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">

                <ProgressBar IsIndeterminate="True" Width="160" Height="16"/>

                <TextBlock x:Name="LoadingText" Text="Connecting..." 

                           Margin="0,10,0,0" FontSize="12" Foreground="#555" HorizontalAlignment="Center"/>

            </StackPanel>

        </Border>

    </Grid>

</Page>



==================================================
FILE_NAME: sgRNADesignerPage.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\sgRNADesignerPage.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using BioSAK.Services;

namespace BioSAK.Pages
{
    public partial class sgRNADesignerPage : Page
    {
        private static readonly HttpClient httpClient;

        static sgRNADesignerPage()
        {
            httpClient = new HttpClient();
            httpClient.Timeout = TimeSpan.FromSeconds(30);
            httpClient.DefaultRequestHeaders.Add("User-Agent", "BioSAK/1.0 (contact@example.com)");
        }

        private ObservableCollection<sgRNACandidate> sgRNACandidates = new ObservableCollection<sgRNACandidate>();
        private List<ExonInfo> exonList = new List<ExonInfo>();
        private List<CDSRegion> cdsList = new List<CDSRegion>();
        private string genomicSequence = "";
        private string currentGeneSymbol = "";
        private string currentAccession = "";
        private string currentTaxId = "9606";
        private bool isInputCollapsed = false;

        private Dictionary<int, Ellipse> sgRNAEllipses = new Dictionary<int, Ellipse>();

        private const string NCBI_ESEARCH_URL = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi";
        private const string NCBI_EFETCH_URL = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi";
        private const string NCBI_ELINK_URL = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/elink.fcgi";

        // GeneIdService ?冽 ID 頧?
        private readonly GeneIdService _geneIdService;

        public sgRNADesignerPage()
        {
            InitializeComponent();
            sgRNADataGrid.ItemsSource = sgRNACandidates;

            // ????GeneIdService
            _geneIdService = new GeneIdService();

            // ?? IsSelected 霈?靘?啣?貊???
            sgRNACandidates.CollectionChanged += (s, e) =>
            {
                if (e.NewItems != null)
                {
                    foreach (sgRNACandidate item in e.NewItems)
                    {
                        item.PropertyChanged += SgRNACandidate_PropertyChanged;
                    }
                }
            };
        }

        private void SgRNACandidate_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "IsSelected")
            {
                UpdateSelectionStatus();
                UpdateSelectAllCheckBoxState();
            }
        }

        #region Select All Checkbox

        private void SelectAllCheckBox_Click(object sender, RoutedEventArgs e)
        {
            if (sender is CheckBox checkBox)
            {
                bool isChecked = checkBox.IsChecked == true;
                foreach (var sg in sgRNACandidates)
                {
                    sg.IsSelected = isChecked;
                }
                UpdateSelectionStatus();
            }
        }

        private void UpdateSelectAllCheckBoxState()
        {
            if (sgRNACandidates.Count == 0)
            {
                SelectAllCheckBox.IsChecked = false;
                return;
            }

            int selectedCount = sgRNACandidates.Count(c => c.IsSelected);
            if (selectedCount == 0)
            {
                SelectAllCheckBox.IsChecked = false;
            }
            else if (selectedCount == sgRNACandidates.Count)
            {
                SelectAllCheckBox.IsChecked = true;
            }
            else
            {
                SelectAllCheckBox.IsChecked = null; // 銝剝????(?典??訾葉)
            }
        }

        #endregion

        #region Collapsible Input Section

        private void InputHeader_Click(object sender, MouseButtonEventArgs e)
        {
            ToggleInputSection();
        }

        private void ToggleInputSection()
        {
            isInputCollapsed = !isInputCollapsed;

            if (isInputCollapsed)
            {
                InputContentPanel.Visibility = Visibility.Collapsed;
                CollapseArrow.Text = "??;
            }
            else
            {
                InputContentPanel.Visibility = Visibility.Visible;
                CollapseArrow.Text = "??;
            }
        }

        private void CollapseInputSection()
        {
            if (!isInputCollapsed)
            {
                isInputCollapsed = true;
                InputContentPanel.Visibility = Visibility.Collapsed;
                CollapseArrow.Text = "??;
            }
        }

        private void ExpandInputSection()
        {
            if (isInputCollapsed)
            {
                isInputCollapsed = false;
                InputContentPanel.Visibility = Visibility.Visible;
                CollapseArrow.Text = "??;
            }
        }

        #endregion

        #region Fetch Gene from NCBI

        private async void FetchGeneButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                ShowLoading(true, "Connecting to NCBI...");
                ClearResults();

                string geneQuery = GeneQueryTextBox.Text.Trim();
                currentTaxId = GetSelectedTaxId();

                if (string.IsNullOrEmpty(geneQuery))
                {
                    ShowInfo("Enter gene name/ID.", true);
                    return;
                }

                ShowLoading(true, $"Searching {geneQuery}...");
                await FetchByGeneQuery(geneQuery, currentTaxId);

                AnalyzeButton.IsEnabled = cdsList.Count > 0 && !string.IsNullOrEmpty(genomicSequence);

                if (AnalyzeButton.IsEnabled)
                {
                    InputSectionSummary.Text = $"??{currentGeneSymbol} ({currentAccession}) loaded";
                }
            }
            catch (Exception ex)
            {
                ShowInfo($"Error: {ex.Message}", true);
            }
            finally
            {
                ShowLoading(false);
            }
        }

        private string GetSelectedTaxId()
        {
            if (SpeciesComboBox.SelectedItem is ComboBoxItem item && item.Tag != null)
                return item.Tag.ToString();
            return "9606";
        }

        private string GetSpeciesNameFromTaxId(string taxId)
        {
            return taxId switch
            {
                "9606" => "human",
                "10090" => "mouse",
                "10116" => "rat",
                _ => "human"
            };
        }

        /// <summary>
        /// ?寥脩??箏??? - ?舀憭車 ID 憿?嚗蝙??GeneIdService 頧?
        /// </summary>
        private async Task FetchByGeneQuery(string query, string taxId)
        {
            string geneId = null;
            string resolvedSymbol = query;

            // 頛 GeneIdService 鞈?摨?
            string speciesName = GetSpeciesNameFromTaxId(taxId);
            bool dbLoaded = false;

            if (_geneIdService.DatabaseExists(speciesName))
            {
                ShowLoading(true, "Loading gene database...");
                dbLoaded = await _geneIdService.LoadDatabaseAsync(speciesName);
            }

            if (dbLoaded && _geneIdService.IsDatabaseLoaded)
            {
                // 雿輻 GeneIdService ??皜砍?頧??
                string detectedType = _geneIdService.DetectIdType(query);
                System.Diagnostics.Debug.WriteLine($"[sgRNA] Detected ID type: {detectedType} for '{query}'");

                // ?岫頧???Symbol
                string convertedSymbol = _geneIdService.ConvertSingleToSymbol(query);

                if (!string.IsNullOrEmpty(convertedSymbol))
                {
                    resolvedSymbol = convertedSymbol;

                    // ??摰???閮?
                    var matches = _geneIdService.Convert(query, detectedType);
                    if (matches.Count > 0)
                    {
                        var bestMatch = matches[0];

                        // 憒???Entrez ID嚗?乩蝙??
                        if (!string.IsNullOrEmpty(bestMatch.EntrezId))
                        {
                            geneId = bestMatch.EntrezId;
                        }

                        // 憿舐內頧?蝯?
                        string hint = "";
                        if (!query.Equals(resolvedSymbol, StringComparison.OrdinalIgnoreCase))
                        {
                            hint = $"'{query}' ??{resolvedSymbol}";
                            if (!string.IsNullOrEmpty(bestMatch.FullName))
                            {
                                hint += $" ({bestMatch.FullName})";
                            }
                        }
                        else if (!string.IsNullOrEmpty(bestMatch.FullName))
                        {
                            hint = bestMatch.FullName;
                        }

                        SearchResultHint.Text = hint;
                        System.Diagnostics.Debug.WriteLine($"[sgRNA] Resolved: {query} ??{resolvedSymbol}, Entrez: {geneId}");
                    }
                }
                else
                {
                    SearchResultHint.Text = $"'{query}' not found in local DB, searching NCBI...";
                    System.Diagnostics.Debug.WriteLine($"[sgRNA] '{query}' not found in local DB");
                }
            }
            else
            {
                SearchResultHint.Text = "Local DB not available, searching NCBI...";
            }

            // NCBI ??
            if (string.IsNullOrEmpty(geneId))
            {
                ShowLoading(true, $"Searching NCBI for {resolvedSymbol}...");

                // 憒??舐??詨?嚗?賣 Entrez ID
                if (int.TryParse(query, out _))
                {
                    geneId = query;
                }
                else
                {
                    string geneSearchUrl = $"{NCBI_ESEARCH_URL}?db=gene&term={Uri.EscapeDataString(resolvedSymbol)}[Gene Name]+AND+{taxId}[Taxonomy ID]&retmode=xml";

                    var geneSearchResponse = await httpClient.GetStringAsync(geneSearchUrl);
                    var geneXml = System.Xml.Linq.XDocument.Parse(geneSearchResponse);
                    var geneIds = geneXml.Descendants("Id").Select(x => x.Value).ToList();

                    if (geneIds.Count == 0)
                    {
                        geneSearchUrl = $"{NCBI_ESEARCH_URL}?db=gene&term={Uri.EscapeDataString(resolvedSymbol)}[sym]+AND+{taxId}[Taxonomy ID]&retmode=xml";
                        geneSearchResponse = await httpClient.GetStringAsync(geneSearchUrl);
                        geneXml = System.Xml.Linq.XDocument.Parse(geneSearchResponse);
                        geneIds = geneXml.Descendants("Id").Select(x => x.Value).ToList();
                    }

                    if (geneIds.Count == 0 && !query.Equals(resolvedSymbol, StringComparison.OrdinalIgnoreCase))
                    {
                        geneSearchUrl = $"{NCBI_ESEARCH_URL}?db=gene&term={Uri.EscapeDataString(query)}[Gene Name]+AND+{taxId}[Taxonomy ID]&retmode=xml";
                        geneSearchResponse = await httpClient.GetStringAsync(geneSearchUrl);
                        geneXml = System.Xml.Linq.XDocument.Parse(geneSearchResponse);
                        geneIds = geneXml.Descendants("Id").Select(x => x.Value).ToList();
                    }

                    if (geneIds.Count == 0)
                    {
                        ShowInfo($"Gene '{query}' not found.", true);
                        return;
                    }

                    geneId = geneIds.First();
                }
            }

            ShowLoading(true, $"Gene ID: {geneId}, finding RefSeqGene...");

            // 雿輻 elink ??RefSeqGene
            string elinkUrl = $"{NCBI_ELINK_URL}?dbfrom=gene&db=nuccore&id={geneId}&linkname=gene_nuccore_refseqgene&retmode=xml";

            var elinkResponse = await httpClient.GetStringAsync(elinkUrl);
            var elinkXml = System.Xml.Linq.XDocument.Parse(elinkResponse);
            var nucIds = elinkXml.Descendants("Link").Select(x => x.Element("Id")?.Value).Where(x => x != null).ToList();

            if (nucIds.Count == 0)
            {
                string nucSearchUrl = $"{NCBI_ESEARCH_URL}?db=nuccore&term=NG_[Accession]+AND+{Uri.EscapeDataString(resolvedSymbol)}[Gene]+AND+{taxId}[Taxonomy ID]+AND+RefSeqGene[Keyword]&retmax=5&retmode=xml";
                var nucSearchResponse = await httpClient.GetStringAsync(nucSearchUrl);
                var nucXml = System.Xml.Linq.XDocument.Parse(nucSearchResponse);
                nucIds = nucXml.Descendants("Id").Select(x => x.Value).ToList();
            }

            if (nucIds.Count == 0)
            {
                ShowInfo($"No RefSeqGene for '{resolvedSymbol}'.", true);
                return;
            }

            await FetchAndParseGenBank(nucIds.First());
        }

        private async Task FetchAndParseGenBank(string nucId)
        {
            string gbUrl = $"{NCBI_EFETCH_URL}?db=nuccore&id={nucId}&rettype=gb&retmode=text";
            ShowLoading(true, "Downloading GenBank...");
            var gbResponse = await httpClient.GetStringAsync(gbUrl);

            string fastaUrl = $"{NCBI_EFETCH_URL}?db=nuccore&id={nucId}&rettype=fasta&retmode=text";
            ShowLoading(true, "Downloading sequence...");
            var fastaResponse = await httpClient.GetStringAsync(fastaUrl);

            genomicSequence = ParseFastaSequence(fastaResponse);

            ShowLoading(true, "Parsing features...");
            ParseGenBankForCDSAndExons(gbResponse);

            UpdateGeneVisualization();

            int cdsLen = cdsList.Sum(c => c.Length);
            ShowInfo($"??{currentGeneSymbol} ({currentAccession}) | {genomicSequence.Length:N0} bp | CDS: {cdsLen:N0} bp", false);
        }

        private string ParseFastaSequence(string input)
        {
            var lines = input.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            var sb = new StringBuilder();
            foreach (var line in lines)
                if (!line.StartsWith(">"))
                    sb.Append(Regex.Replace(line, "[^ATCGatcg]", ""));
            return sb.ToString().ToUpper();
        }

        private void ParseGenBankForCDSAndExons(string gbText)
        {
            exonList.Clear();
            cdsList.Clear();

            var accMatch = Regex.Match(gbText, @"ACCESSION\s+(\S+)");
            if (accMatch.Success) currentAccession = accMatch.Groups[1].Value;

            var geneMatch = Regex.Match(gbText, @"/gene=""([^""]+)""");
            if (geneMatch.Success) currentGeneSymbol = geneMatch.Groups[1].Value;

            var cdsSection = Regex.Match(gbText, @"^\s{5}CDS\s+(join\([\s\S]*?\)|complement\(join\([\s\S]*?\)\)|\d+\.\.\d+)", RegexOptions.Multiline);
            if (cdsSection.Success)
            {
                string cdsContent = Regex.Replace(cdsSection.Groups[1].Value, @"\s+", "");
                var rangeMatches = Regex.Matches(cdsContent, @"(\d+)\.\.(\d+)");
                int cdsNum = 1;
                foreach (Match range in rangeMatches)
                {
                    int start = int.Parse(range.Groups[1].Value);
                    int end = int.Parse(range.Groups[2].Value);
                    cdsList.Add(new CDSRegion { PartNumber = cdsNum++, Start = start, End = end, Length = end - start + 1 });
                }
            }

            var exonMatches = Regex.Matches(gbText, @"^\s{5}exon\s+(?:complement\()?(\d+)\.\.(\d+)\)?", RegexOptions.Multiline);
            int exonNum = 1;
            foreach (Match match in exonMatches)
            {
                int start = int.Parse(match.Groups[1].Value);
                int end = int.Parse(match.Groups[2].Value);
                exonList.Add(new ExonInfo { ExonNumber = exonNum++, Start = start, End = end, Length = end - start + 1 });
            }

            exonList = exonList.OrderBy(e => e.Start).ToList();
            for (int i = 0; i < exonList.Count; i++) exonList[i].ExonNumber = i + 1;
        }

        #endregion

        #region Align DNA Sequence

        private async void AlignSequenceButton_Click(object sender, RoutedEventArgs e)
        {
            string sequence = SequenceInputTextBox.Text.Trim();
            if (sequence.StartsWith(">"))
            {
                int idx = sequence.IndexOf('\n');
                if (idx > 0) sequence = sequence.Substring(idx + 1);
            }
            sequence = Regex.Replace(sequence, @"[^ATCGatcg]", "").ToUpper();

            if (sequence.Length < 50)
            {
                ShowInfo("Enter longer sequence (50+ bp).", true);
                return;
            }

            try
            {
                ShowLoading(true, "Analyzing input sequence...");
                ClearResults();

                // 撠畾萄????箔???exon ????CDS
                genomicSequence = sequence;
                currentGeneSymbol = "InputSeq";
                currentAccession = $"{sequence.Length}bp";
                currentTaxId = GetSelectedTaxId();

                exonList.Clear();
                cdsList.Clear();

                exonList.Add(new ExonInfo
                {
                    ExonNumber = 1,
                    Start = 1,
                    End = sequence.Length,
                    Length = sequence.Length
                });

                cdsList.Add(new CDSRegion
                {
                    PartNumber = 1,
                    Start = 1,
                    End = sequence.Length,
                    Length = sequence.Length
                });

                UpdateGeneVisualization();

                // ?湔?脰? sgRNA ??
                string pamPattern = GetPAMPattern();
                int sgRNALength = GetsgRNALength();

                var candidates = FindsgRNAsInCDS(genomicSequence, pamPattern, sgRNALength);
                foreach (var c in candidates)
                {
                    c.PropertyChanged += SgRNACandidate_PropertyChanged;
                    sgRNACandidates.Add(c);
                }

                UpdateVisualizationWithsgRNAs();

                int recCount = sgRNACandidates.Count(c => c.IsRecommended);
                sgRNACountLabel.Text = $"{sgRNACandidates.Count} found, {recCount} 潃?;
                EmptyListText.Visibility = sgRNACandidates.Count == 0 ? Visibility.Visible : Visibility.Collapsed;

                ExportButton.IsEnabled = CopyButton.IsEnabled = BlastAllButton.IsEnabled = sgRNACandidates.Count > 0;
                AnalyzeButton.IsEnabled = true;
                FrameshiftAnalysisButton.IsEnabled = sgRNACandidates.Count > 0;

                ShowInfo($"Found {sgRNACandidates.Count} sgRNAs in input sequence ({sequence.Length:N0} bp), {recCount} recommended", false);

                CollapseInputSection();
                InputSectionSummary.Text = $"??Input sequence ({sequence.Length:N0} bp) | {sgRNACandidates.Count} sgRNAs";

                UpdateSelectAllCheckBoxState();
            }
            catch (Exception ex)
            {
                ShowInfo($"Error: {ex.Message}", true);
            }
            finally
            {
                ShowLoading(false);
            }
        }

        #endregion

        #region sgRNA Analysis

        private void AnalyzeButton_Click(object sender, RoutedEventArgs e)
        {
            if (string.IsNullOrEmpty(genomicSequence) || cdsList.Count == 0)
            {
                ShowInfo("Fetch gene data first.", true);
                return;
            }

            try
            {
                ShowProgress(true, "Finding PAM sites...");
                sgRNACandidates.Clear();

                string pamPattern = GetPAMPattern();
                int sgRNALength = GetsgRNALength();

                var candidates = FindsgRNAsInCDS(genomicSequence, pamPattern, sgRNALength);
                foreach (var c in candidates)
                {
                    c.PropertyChanged += SgRNACandidate_PropertyChanged;
                    sgRNACandidates.Add(c);
                }

                UpdateVisualizationWithsgRNAs();

                int recCount = sgRNACandidates.Count(c => c.IsRecommended);
                sgRNACountLabel.Text = $"{sgRNACandidates.Count} found, {recCount} 潃?;
                EmptyListText.Visibility = sgRNACandidates.Count == 0 ? Visibility.Visible : Visibility.Collapsed;

                ExportButton.IsEnabled = CopyButton.IsEnabled = BlastAllButton.IsEnabled = sgRNACandidates.Count > 0;

                ShowInfo($"Found {sgRNACandidates.Count} sgRNAs in CDS, {recCount} recommended", false);

                CollapseInputSection();
                InputSectionSummary.Text = $"??{currentGeneSymbol} | {sgRNACandidates.Count} sgRNAs";

                UpdateSelectAllCheckBoxState();
            }
            catch (Exception ex)
            {
                ShowInfo($"Error: {ex.Message}", true);
            }
            finally
            {
                ShowProgress(false);
            }
        }

        private string GetPAMPattern()
        {
            if (PAMComboBox.SelectedItem is ComboBoxItem item)
            {
                if (item.Content.ToString().Contains("NGG")) return "NGG";
                if (item.Content.ToString().Contains("NAG")) return "NAG";
            }
            return "NGG";
        }

        private int GetsgRNALength()
        {
            if (sgRNALengthComboBox.SelectedItem is ComboBoxItem item)
                if (int.TryParse(item.Content.ToString(), out int len)) return len;
            return 20;
        }

        private List<sgRNACandidate> FindsgRNAsInCDS(string sequence, string pamPattern, int sgRNALength)
        {
            var candidates = new List<sgRNACandidate>();
            string pamRegex = pamPattern.Replace("N", "[ATCG]").Replace("R", "[AG]");
            int idx = 1;

            foreach (var cds in cdsList)
            {
                int start = cds.Start - 1;
                int end = Math.Min(cds.End, sequence.Length);
                if (start < 0 || start >= sequence.Length) continue;

                string cdsSeq = sequence.Substring(start, end - start);

                // Forward strand (+)
                var fwdMatches = Regex.Matches(cdsSeq, $"([ATCG]{{{sgRNALength}}})({pamRegex})");
                foreach (Match m in fwdMatches)
                {
                    string sgRNA = m.Groups[1].Value;
                    string pam = m.Groups[2].Value;
                    int pos = start + m.Index + 1;
                    int exonNum = GetExonNumber(pos);
                    double gc = CalculateGC(sgRNA);
                    bool rec = IsRecommended(sgRNA, gc);

                    candidates.Add(new sgRNACandidate
                    {
                        Index = idx++,
                        Sequence = sgRNA,
                        PAM = pam,
                        Position = pos,
                        PositionEnd = pos + sgRNALength + pam.Length - 1,
                        Strand = "+",
                        ExonNumber = exonNum,
                        GCContent = $"{gc:F0}%",
                        IsRecommended = rec
                    });
                }

                // Reverse strand (-)
                string rcSeq = ReverseComplement(cdsSeq);
                var revMatches = Regex.Matches(rcSeq, $"([ATCG]{{{sgRNALength}}})({pamRegex})");
                foreach (Match m in revMatches)
                {
                    string sgRNA = m.Groups[1].Value;
                    string pam = m.Groups[2].Value;
                    int rcPos = m.Index;
                    int originalPos = start + (cdsSeq.Length - rcPos - sgRNALength - pam.Length) + 1;
                    int exonNum = GetExonNumber(originalPos);
                    double gc = CalculateGC(sgRNA);
                    bool rec = IsRecommended(sgRNA, gc);

                    candidates.Add(new sgRNACandidate
                    {
                        Index = idx++,
                        Sequence = sgRNA,
                        PAM = pam,
                        Position = originalPos,
                        PositionEnd = originalPos + sgRNALength + pam.Length - 1,
                        Strand = "??,
                        ExonNumber = exonNum,
                        GCContent = $"{gc:F0}%",
                        IsRecommended = rec
                    });
                }
            }

            return candidates.OrderBy(c => c.Position).ToList();
        }

        private int GetExonNumber(int position)
        {
            foreach (var exon in exonList)
                if (position >= exon.Start && position <= exon.End)
                    return exon.ExonNumber;
            return 0;
        }

        private double CalculateGC(string seq)
        {
            if (string.IsNullOrEmpty(seq)) return 0;
            int gc = seq.Count(c => c == 'G' || c == 'C');
            return 100.0 * gc / seq.Length;
        }

        private bool IsRecommended(string sgRNA, double gc)
        {
            return sgRNA.StartsWith("G") && sgRNA.EndsWith("A") && gc >= 40 && gc <= 60;
        }

        private string ReverseComplement(string seq)
        {
            var complement = new Dictionary<char, char>
            {
                {'A', 'T'}, {'T', 'A'}, {'G', 'C'}, {'C', 'G'}
            };
            var sb = new StringBuilder();
            for (int i = seq.Length - 1; i >= 0; i--)
            {
                sb.Append(complement.TryGetValue(seq[i], out char c) ? c : 'N');
            }
            return sb.ToString();
        }

        #endregion

        #region Visualization

        private double _currentScale = 0.5;
        private const double MIN_SCALE = 0.01;
        private const double MAX_SCALE = 10.0;
        private const double MARGIN = 30;
        private const double GENE_Y = 30;
        private const double SGRNA_Y_PLUS = 55;
        private const double SGRNA_Y_MINUS = 70;
        private const double FIXED_INTRON_WIDTH = 20;

        private List<(int GenomicStart, int GenomicEnd, double VisualStart, double VisualEnd)> _exonMapping
            = new List<(int, int, double, double)>();

        private bool _isInitialDraw = true;

        private void UpdateGeneVisualization()
        {
            GeneVisualizationCanvas.Children.Clear();
            EmptyVisualizationText.Visibility = Visibility.Collapsed;
            _exonMapping.Clear();
            sgRNAEllipses.Clear();

            if (exonList.Count == 0 && cdsList.Count == 0) return;

            double minExonWidth = 30;
            // maxExonWidth ??scale ??隤踵嚗Ⅱ靽?zoom ????
            double maxExonWidth = Math.Max(200, exonList.Max(e => e.Length) * _currentScale);

            // ?芸?活蝜芾ˊ??蝞?scale嚗oom ???蝙?刻身摰? _currentScale
            if (_isInitialDraw)
            {
                int minExonLength = exonList.Count > 0 ? exonList.Min(e => e.Length) : 100;
                _currentScale = minExonWidth / Math.Max(minExonLength, 1);
                _currentScale = Math.Max(MIN_SCALE, Math.Min(MAX_SCALE, _currentScale));
                _defaultScale = _currentScale;
                _isInitialDraw = false;
                maxExonWidth = Math.Max(200, exonList.Max(e => e.Length) * _currentScale);
            }

            double totalExonWidth = exonList.Sum(e => Math.Min(Math.Max(e.Length * _currentScale, minExonWidth), maxExonWidth));
            double totalIntronWidth = Math.Max(0, exonList.Count - 1) * FIXED_INTRON_WIDTH;
            double canvasWidth = 2 * MARGIN + totalExonWidth + totalIntronWidth;

            double viewportWidth = Math.Max(GeneVisualizationScrollViewer?.ViewportWidth ?? 800, 600);
            canvasWidth = Math.Max(canvasWidth, viewportWidth);

            GeneVisualizationCanvas.Width = canvasWidth;
            GeneVisualizationCanvas.Height = 90;

            double currentX = MARGIN;
            var sortedExons = exonList.OrderBy(e => e.Start).ToList();

            for (int i = 0; i < sortedExons.Count; i++)
            {
                var exon = sortedExons[i];
                double exonWidth = Math.Min(Math.Max(exon.Length * _currentScale, minExonWidth), maxExonWidth);

                _exonMapping.Add((exon.Start, exon.End, currentX, currentX + exonWidth));

                if (i > 0)
                {
                    double prevExonEnd = currentX - FIXED_INTRON_WIDTH;
                    double midX = prevExonEnd + FIXED_INTRON_WIDTH / 2;
                    var intronLine1 = new Line { X1 = prevExonEnd, Y1 = GENE_Y, X2 = midX, Y2 = GENE_Y + 8, Stroke = Brushes.Gray, StrokeThickness = 1 };
                    var intronLine2 = new Line { X1 = midX, Y1 = GENE_Y + 8, X2 = currentX, Y2 = GENE_Y, Stroke = Brushes.Gray, StrokeThickness = 1 };
                    GeneVisualizationCanvas.Children.Add(intronLine1);
                    GeneVisualizationCanvas.Children.Add(intronLine2);
                }

                var exonRect = new Rectangle
                {
                    Width = exonWidth,
                    Height = 18,
                    Fill = new SolidColorBrush(Color.FromRgb(200, 230, 201)),
                    Stroke = new SolidColorBrush(Color.FromRgb(76, 175, 80)),
                    StrokeThickness = 1,
                    RadiusX = 2,
                    RadiusY = 2,
                    ToolTip = $"Exon {exon.ExonNumber}: {exon.Start:N0}-{exon.End:N0} ({exon.Length:N0} bp)"
                };
                Canvas.SetLeft(exonRect, currentX);
                Canvas.SetTop(exonRect, GENE_Y - 9);
                GeneVisualizationCanvas.Children.Add(exonRect);

                if (exonWidth > 25)
                {
                    var lbl = new TextBlock { Text = $"E{exon.ExonNumber}", FontSize = 9, Foreground = Brushes.DarkGreen, FontWeight = FontWeights.SemiBold };
                    Canvas.SetLeft(lbl, currentX + 3);
                    Canvas.SetTop(lbl, GENE_Y - 7);
                    GeneVisualizationCanvas.Children.Add(lbl);
                }

                foreach (var cds in cdsList)
                {
                    int overlapStart = Math.Max(cds.Start, exon.Start);
                    int overlapEnd = Math.Min(cds.End, exon.End);

                    if (overlapStart <= overlapEnd)
                    {
                        double cdsRelStart = (double)(overlapStart - exon.Start) / exon.Length;
                        double cdsRelEnd = (double)(overlapEnd - exon.Start + 1) / exon.Length;

                        double cdsVisualStart = currentX + cdsRelStart * exonWidth;
                        double cdsVisualWidth = (cdsRelEnd - cdsRelStart) * exonWidth;
                        cdsVisualWidth = Math.Max(cdsVisualWidth, 3);

                        var cdsRect = new Rectangle
                        {
                            Width = cdsVisualWidth,
                            Height = 10,
                            Fill = new SolidColorBrush(Color.FromRgb(255, 183, 77)),
                            Stroke = new SolidColorBrush(Color.FromRgb(255, 152, 0)),
                            StrokeThickness = 1,
                            RadiusX = 2,
                            RadiusY = 2,
                            ToolTip = $"CDS: {overlapStart:N0}-{overlapEnd:N0}"
                        };
                        Canvas.SetLeft(cdsRect, cdsVisualStart);
                        Canvas.SetTop(cdsRect, GENE_Y - 5);
                        GeneVisualizationCanvas.Children.Add(cdsRect);
                    }
                }

                currentX += exonWidth + FIXED_INTRON_WIDTH;
            }

            GeneInfoLabel.Text = $"{currentGeneSymbol} | {currentAccession} | {genomicSequence.Length:N0} bp | {exonList.Count} exons | CDS: {cdsList.Sum(c => c.Length):N0} bp";
        }

        private double GenomicPosToVisualX(int genomicPos)
        {
            foreach (var mapping in _exonMapping)
            {
                if (genomicPos >= mapping.GenomicStart && genomicPos <= mapping.GenomicEnd)
                {
                    double relativePos = (double)(genomicPos - mapping.GenomicStart) / (mapping.GenomicEnd - mapping.GenomicStart + 1);
                    return mapping.VisualStart + relativePos * (mapping.VisualEnd - mapping.VisualStart);
                }
            }

            for (int i = 0; i < _exonMapping.Count - 1; i++)
            {
                if (genomicPos > _exonMapping[i].GenomicEnd && genomicPos < _exonMapping[i + 1].GenomicStart)
                {
                    return (_exonMapping[i].VisualEnd + _exonMapping[i + 1].VisualStart) / 2;
                }
            }

            return MARGIN;
        }

        private void UpdateVisualizationWithsgRNAs()
        {
            foreach (var el in sgRNAEllipses.Values)
                GeneVisualizationCanvas.Children.Remove(el);
            sgRNAEllipses.Clear();

            if (sgRNACandidates.Count == 0) return;

            var plusLabel = new TextBlock { Text = "+", FontSize = 10, FontWeight = FontWeights.Bold, Foreground = Brushes.Gray };
            Canvas.SetLeft(plusLabel, 8);
            Canvas.SetTop(plusLabel, SGRNA_Y_PLUS - 2);
            GeneVisualizationCanvas.Children.Add(plusLabel);

            var minusLabel = new TextBlock { Text = "??, FontSize = 10, FontWeight = FontWeights.Bold, Foreground = Brushes.Gray };
            Canvas.SetLeft(minusLabel, 8);
            Canvas.SetTop(minusLabel, SGRNA_Y_MINUS - 2);
            GeneVisualizationCanvas.Children.Add(minusLabel);

            foreach (var sg in sgRNACandidates)
            {
                double x = GenomicPosToVisualX(sg.Position);
                double y = sg.Strand == "+" ? SGRNA_Y_PLUS : SGRNA_Y_MINUS;

                var ellipse = new Ellipse
                {
                    Width = 6,
                    Height = 6,
                    Fill = new SolidColorBrush(sg.IsRecommended ? Color.FromRgb(255, 152, 0) : Color.FromRgb(33, 150, 243)),
                    Stroke = Brushes.White,
                    StrokeThickness = 1,
                    Cursor = Cursors.Hand,
                    ToolTip = $"#{sg.Index} | Pos: {sg.Position:N0} | E{sg.ExonNumber} | {sg.Sequence}-{sg.PAM} ({sg.Strand}) | GC: {sg.GCContent}{(sg.IsRecommended ? " 潃? : "")}"
                };

                ellipse.MouseLeftButtonDown += (s, e) =>
                {
                    sgRNADataGrid.SelectedItem = sg;
                    sgRNADataGrid.ScrollIntoView(sg);
                };

                Canvas.SetLeft(ellipse, x - 3);
                Canvas.SetTop(ellipse, y);
                GeneVisualizationCanvas.Children.Add(ellipse);
                sgRNAEllipses[sg.Index] = ellipse;
            }

            UpdateSelectionStatus();
        }

        private void HighlightSgRNAEllipse(int idx)
        {
            foreach (var kvp in sgRNAEllipses)
            {
                var sg = sgRNACandidates.FirstOrDefault(c => c.Index == kvp.Key);
                if (sg != null)
                {
                    kvp.Value.Fill = new SolidColorBrush(sg.IsRecommended ? Color.FromRgb(255, 152, 0) : Color.FromRgb(33, 150, 243));
                    kvp.Value.StrokeThickness = 1;
                    kvp.Value.Width = 6;
                    kvp.Value.Height = 6;
                }
            }
            if (sgRNAEllipses.TryGetValue(idx, out var sel))
            {
                sel.Fill = new SolidColorBrush(Color.FromRgb(244, 67, 54));
                sel.StrokeThickness = 2;
                sel.Width = 10;
                sel.Height = 10;

                var sg = sgRNACandidates.FirstOrDefault(c => c.Index == idx);
                if (sg != null)
                {
                    double x = GenomicPosToVisualX(sg.Position);
                    if (GeneVisualizationScrollViewer != null)
                    {
                        double viewportCenter = GeneVisualizationScrollViewer.ViewportWidth / 2;
                        double targetOffset = Math.Max(0, x - viewportCenter);
                        GeneVisualizationScrollViewer.ScrollToHorizontalOffset(targetOffset);
                    }
                }
            }
        }

        private void sgRNADataGrid_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (sgRNADataGrid.SelectedItem is sgRNACandidate c)
                HighlightSgRNAEllipse(c.Index);
        }

        #region Zoom Controls

        private double _defaultScale = 0.01;

        private void ZoomInButton_Click(object sender, RoutedEventArgs e) => ZoomVisualization(1.5);
        private void ZoomOutButton_Click(object sender, RoutedEventArgs e) => ZoomVisualization(1.0 / 1.5);

        private void ZoomResetButton_Click(object sender, RoutedEventArgs e)
        {
            _currentScale = _defaultScale;
            RedrawVisualization();
        }

        private void GeneVisualizationScrollViewer_PreviewMouseWheel(object sender, MouseWheelEventArgs e)
        {
            if (Keyboard.Modifiers == ModifierKeys.Control)
            {
                ZoomVisualization(e.Delta > 0 ? 1.2 : 1.0 / 1.2);
                e.Handled = true;
            }
            else
            {
                var sv = sender as ScrollViewer;
                sv?.ScrollToHorizontalOffset(sv.HorizontalOffset - e.Delta);
                e.Handled = true;
            }
        }

        private void ZoomVisualization(double factor)
        {
            if (string.IsNullOrEmpty(genomicSequence) || exonList.Count == 0) return;

            double newScale = Math.Max(MIN_SCALE, Math.Min(MAX_SCALE, _currentScale * factor));
            if (Math.Abs(newScale - _currentScale) < 0.001) return;

            double scrollRatio = 0.5;
            if (GeneVisualizationScrollViewer != null && GeneVisualizationCanvas.Width > 0)
            {
                double viewCenter = GeneVisualizationScrollViewer.HorizontalOffset + GeneVisualizationScrollViewer.ViewportWidth / 2;
                scrollRatio = viewCenter / GeneVisualizationCanvas.Width;
            }

            _currentScale = newScale;
            RedrawVisualization();

            if (GeneVisualizationScrollViewer != null && GeneVisualizationCanvas.Width > 0)
            {
                double newCenter = GeneVisualizationCanvas.Width * scrollRatio;
                GeneVisualizationScrollViewer.ScrollToHorizontalOffset(Math.Max(0, newCenter - GeneVisualizationScrollViewer.ViewportWidth / 2));
            }
        }

        private void RedrawVisualization()
        {
            UpdateGeneVisualization();
            UpdateVisualizationWithsgRNAs();
        }

        #endregion

        #endregion

        #region BLAST

        private void BlastSingle_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button btn && btn.Tag is sgRNACandidate c)
                OpenBlastInBrowser(new[] { c });
        }

        private void BlastAllButton_Click(object sender, RoutedEventArgs e)
        {
            var sel = sgRNACandidates.Where(c => c.IsSelected).ToList();
            if (sel.Count == 0) sel = sgRNADataGrid.SelectedItems.Cast<sgRNACandidate>().ToList();
            if (sel.Count == 0) { ShowInfo("Select sgRNAs first.", true); return; }
            OpenBlastInBrowser(sel);
        }

        private void OpenBlastInBrowser(IEnumerable<sgRNACandidate> candidates)
        {
            try
            {
                var sb = new StringBuilder();
                foreach (var c in candidates)
                {
                    sb.AppendLine($">sgRNA_{c.Index}_{currentGeneSymbol}_E{c.ExonNumber}_{c.Strand}");
                    sb.AppendLine(c.Sequence);
                }

                string query = Uri.EscapeDataString(sb.ToString());
                string taxQ = Uri.EscapeDataString($"txid{currentTaxId}[Organism]");
                string blastUrl = $"https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastn&PAGE_TYPE=BlastSearch&DATABASE=refseq_genomes&QUERY={query}&ENTREZ_QUERY={taxQ}&WORD_SIZE=7";

                System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo { FileName = blastUrl, UseShellExecute = true });
                ShowInfo($"BLAST opened for {candidates.Count()} sgRNA(s)", false);
            }
            catch (Exception ex)
            {
                ShowInfo($"Error: {ex.Message}", true);
            }
        }

        #endregion

        #region Export

        private void ExportButton_Click(object sender, RoutedEventArgs e)
        {
            if (sgRNACandidates.Count == 0) return;
            var dlg = new Microsoft.Win32.SaveFileDialog { Filter = "CSV|*.csv", FileName = $"sgRNA_{currentGeneSymbol}_{DateTime.Now:yyyyMMdd}" };
            if (dlg.ShowDialog() == true)
            {
                var sb = new StringBuilder("Index,Position,Exon,Sequence,PAM,Strand,GC%,Recommended,+1_Frameshift,+2_Frameshift\n");
                foreach (var c in sgRNACandidates)
                    sb.AppendLine($"{c.Index},{c.Position}-{c.PositionEnd},{c.ExonNumber},{c.Sequence},{c.PAM},{c.Strand},{c.GCContent},{c.IsRecommended},{c.FrameshiftPlus1 ?? ""},{c.FrameshiftPlus2 ?? ""}");
                System.IO.File.WriteAllText(dlg.FileName, sb.ToString());
                ShowInfo("Exported", false);
            }
        }

        private void CopyButton_Click(object sender, RoutedEventArgs e)
        {
            var sel = sgRNACandidates.Where(c => c.IsSelected).ToList();
            if (sel.Count == 0) sel = sgRNADataGrid.SelectedItems.Cast<sgRNACandidate>().ToList();
            if (sel.Count == 0) { ShowInfo("Select first", true); return; }

            var sb = new StringBuilder("#\tPos\tE\tSequence\tPAM\t簣\t潃t+1 ins\t+2 ins\n");
            foreach (var c in sel)
                sb.AppendLine($"{c.Index}\t{c.Position}-{c.PositionEnd}\t{c.ExonNumber}\t{c.Sequence}\t{c.PAM}\t{c.Strand}\t{(c.IsRecommended ? "潃? : "")}\t{c.FrameshiftPlus1 ?? ""}\t{c.FrameshiftPlus2 ?? ""}");
            Clipboard.SetText(sb.ToString());
            ShowInfo($"Copied {sel.Count}", false);
        }

        #endregion

        #region Frameshift Analysis

        private string _cdsSequence = "";
        private int _originalProteinLength = 0;

        private void BuildCDSSequence()
        {
            if (cdsList.Count == 0 || string.IsNullOrEmpty(genomicSequence))
            {
                _cdsSequence = "";
                _originalProteinLength = 0;
                return;
            }

            var sb = new StringBuilder();
            foreach (var cds in cdsList.OrderBy(c => c.Start))
            {
                int start = cds.Start - 1;
                int length = cds.Length;
                if (start >= 0 && start + length <= genomicSequence.Length)
                    sb.Append(genomicSequence.Substring(start, length));
            }
            _cdsSequence = sb.ToString();
            _originalProteinLength = _cdsSequence.Length / 3;
            if (_originalProteinLength > 0) _originalProteinLength--;
        }

        private int GenomicToCdsPosition(int genomicPos)
        {
            int cdsPos = 0;
            foreach (var cds in cdsList.OrderBy(c => c.Start))
            {
                if (genomicPos < cds.Start) return -1;
                else if (genomicPos <= cds.End) return cdsPos + (genomicPos - cds.Start);
                else cdsPos += cds.Length;
            }
            return -1;
        }

        private static readonly HashSet<string> StopCodons = new HashSet<string> { "TAA", "TAG", "TGA" };

        private int CalculateFrameshiftProteinLength(string cdsSequence, int insertionSite, int insertionCount)
        {
            if (insertionSite < 0 || insertionSite >= cdsSequence.Length) return -1;

            int codonsBefore = insertionSite / 3;
            string insertion = new string('N', insertionCount);
            string mutatedSeq = cdsSequence.Substring(0, insertionSite) + insertion + cdsSequence.Substring(insertionSite);

            int startCodon = codonsBefore;
            int newProteinLength = startCodon;

            for (int i = startCodon * 3; i + 2 < mutatedSeq.Length; i += 3)
            {
                string codon = mutatedSeq.Substring(i, 3).ToUpper();
                if (codon.Contains('N')) { newProteinLength++; continue; }
                if (StopCodons.Contains(codon)) return newProteinLength;
                newProteinLength++;
            }

            return newProteinLength;
        }

        private int CalculateCleavageSiteInCDS(sgRNACandidate sg)
        {
            int pamStart = sg.Strand == "+" ? sg.Position + sg.Sequence.Length - 1 : sg.Position;
            int cleavageSite = sg.Strand == "+" ? pamStart - 3 : pamStart + sg.PAM.Length + 3 - 1;
            return GenomicToCdsPosition(cleavageSite);
        }

        private async void FrameshiftAnalysisButton_Click(object sender, RoutedEventArgs e)
        {
            var selectedSgRNAs = sgRNACandidates.Where(c => c.IsSelected).ToList();
            if (selectedSgRNAs.Count == 0)
            {
                ShowInfo("Please select sgRNAs (check ?? for frameshift analysis.", true);
                return;
            }

            try
            {
                AnalysisProgressPanel.Visibility = Visibility.Visible;
                AnalysisProgressBar.Value = 0;
                AnalysisProgressText.Text = "0%";
                FrameshiftAnalysisButton.IsEnabled = false;

                BuildCDSSequence();

                if (string.IsNullOrEmpty(_cdsSequence))
                {
                    ShowInfo("Cannot build CDS sequence.", true);
                    return;
                }

                int total = selectedSgRNAs.Count;
                int processed = 0;

                await Task.Run(() =>
                {
                    foreach (var sg in selectedSgRNAs)
                    {
                        int cleavageSiteInCDS = CalculateCleavageSiteInCDS(sg);
                        sg.CleavageSite = cleavageSiteInCDS;

                        string plus1Result = "-";
                        string plus2Result = "-";

                        if (cleavageSiteInCDS >= 0 && cleavageSiteInCDS < _cdsSequence.Length)
                        {
                            int newLen1 = CalculateFrameshiftProteinLength(_cdsSequence, cleavageSiteInCDS, 1);
                            if (newLen1 >= 0)
                            {
                                int reduction1 = _originalProteinLength - newLen1;
                                plus1Result = $"-{reduction1}aa ({100.0 * reduction1 / _originalProteinLength:F0}%)";
                            }

                            int newLen2 = CalculateFrameshiftProteinLength(_cdsSequence, cleavageSiteInCDS, 2);
                            if (newLen2 >= 0)
                            {
                                int reduction2 = _originalProteinLength - newLen2;
                                plus2Result = $"-{reduction2}aa ({100.0 * reduction2 / _originalProteinLength:F0}%)";
                            }
                        }

                        Dispatcher.Invoke(() =>
                        {
                            sg.FrameshiftPlus1 = plus1Result;
                            sg.FrameshiftPlus2 = plus2Result;
                            processed++;
                            int percent = (int)(100.0 * processed / total);
                            AnalysisProgressBar.Value = percent;
                            AnalysisProgressText.Text = $"{percent}%";
                        });

                        System.Threading.Thread.Sleep(10);
                    }
                });

                ShowInfo($"Frameshift analysis completed for {selectedSgRNAs.Count} sgRNAs. Original protein: {_originalProteinLength} aa", false);
            }
            catch (Exception ex)
            {
                ShowInfo($"Analysis error: {ex.Message}", true);
            }
            finally
            {
                AnalysisProgressPanel.Visibility = Visibility.Collapsed;
                FrameshiftAnalysisButton.IsEnabled = true;
            }
        }

        private void UpdateSelectionStatus()
        {
            int count = sgRNACandidates.Count(c => c.IsSelected);
            SelectedCountText.Text = count > 0 ? $"({count} selected)" : "";
            FrameshiftAnalysisButton.IsEnabled = sgRNACandidates.Count > 0;
        }

        #endregion

        #region Helpers

        private void ShowLoading(bool show, string msg = "")
        {
            LoadingOverlay.Visibility = show ? Visibility.Visible : Visibility.Collapsed;
            LoadingText.Text = msg;
        }

        private void ShowProgress(bool show, string msg = "")
        {
            AnalysisProgressPanel.Visibility = show ? Visibility.Visible : Visibility.Collapsed;
            AnalysisProgressText.Text = msg;
        }

        private void ShowInfo(string msg, bool err)
        {
            InfoBar.Visibility = Visibility.Visible;
            InfoBar.Background = new SolidColorBrush(err ? Color.FromRgb(255, 235, 238) : Color.FromRgb(227, 242, 253));
            InfoIcon.Text = err ? "??" : "??;
            InfoText.Text = msg;
            InfoText.Foreground = new SolidColorBrush(err ? Color.FromRgb(198, 40, 40) : Color.FromRgb(21, 101, 192));
        }

        private void ClearResults()
        {
            sgRNACandidates.Clear();
            exonList.Clear();
            cdsList.Clear();
            genomicSequence = currentAccession = "";
            sgRNAEllipses.Clear();
            GeneVisualizationCanvas.Children.Clear();
            EmptyVisualizationText.Visibility = EmptyListText.Visibility = Visibility.Visible;
            sgRNACountLabel.Text = GeneInfoLabel.Text = "";
            InputSectionSummary.Text = "";
            SearchResultHint.Text = "";
            InfoBar.Visibility = Visibility.Collapsed;
            AnalyzeButton.IsEnabled = ExportButton.IsEnabled = CopyButton.IsEnabled = BlastAllButton.IsEnabled = false;
            SelectAllCheckBox.IsChecked = false;
            _isInitialDraw = true;
        }

        #endregion
    }

    #region Models

    public class sgRNACandidate : INotifyPropertyChanged
    {
        private bool _isSelected;
        private string _frameshiftPlus1;
        private string _frameshiftPlus2;

        public int Index { get; set; }
        public string Sequence { get; set; }
        public string PAM { get; set; }
        public int Position { get; set; }
        public int PositionEnd { get; set; }
        public string Strand { get; set; }
        public int ExonNumber { get; set; }
        public string GCContent { get; set; }
        public bool IsRecommended { get; set; }
        public int CleavageSite { get; set; }

        public bool IsSelected
        {
            get => _isSelected;
            set { _isSelected = value; OnPropertyChanged(); }
        }

        public string FrameshiftPlus1
        {
            get => _frameshiftPlus1;
            set { _frameshiftPlus1 = value; OnPropertyChanged(); }
        }

        public string FrameshiftPlus2
        {
            get => _frameshiftPlus2;
            set { _frameshiftPlus2 = value; OnPropertyChanged(); }
        }

        public string PositionDisplay => $"{Position:N0}-{PositionEnd:N0}";
        public string ExonDisplay => ExonNumber > 0 ? $"{ExonNumber}" : "-";
        public string RecommendDisplay => IsRecommended ? "潃? : "";

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string n = null) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(n));
    }

    public class ExonInfo
    {
        public int ExonNumber { get; set; }
        public int Start { get; set; }
        public int End { get; set; }
        public int Length { get; set; }
    }

    public class CDSRegion
    {
        public int PartNumber { get; set; }
        public int Start { get; set; }
        public int End { get; set; }
        public int Length { get; set; }
    }

    #endregion
}


==================================================
FILE_NAME: TcgaAnalysisPage.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\TcgaAnalysisPage.xaml
==================================================
<Page x:Class="BioSAK.Pages.TcgaAnalysisPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      mc:Ignorable="d" 
      d:DesignHeight="900" d:DesignWidth="1200"
      Title="TCGA Analysis"
      Background="#F5F5F5">

    <Page.Resources>
        <Style x:Key="SectionTitleStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Foreground" Value="#333"/>
            <Setter Property="Margin" Value="0,0,0,8"/>
        </Style>

        <Style x:Key="ActionButtonStyle" TargetType="Button">
            <Setter Property="Padding" Value="12,6"/>
            <Setter Property="Background" Value="#2196F3"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" 
                                CornerRadius="4" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#1976D2"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <Style x:Key="ExportButtonStyle" TargetType="Button">
            <Setter Property="Padding" Value="10,5"/>
            <Setter Property="Background" Value="#4CAF50"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Margin" Value="5,0,0,0"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" 
                                CornerRadius="4" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#388E3C"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <Style x:Key="CopyButtonStyle" TargetType="Button">
            <Setter Property="Padding" Value="8,4"/>
            <Setter Property="Background" Value="#FF9800"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="FontSize" Value="11"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" 
                                CornerRadius="3" Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#F57C00"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <Style x:Key="SelectableStatsStyle" TargetType="TextBox">
            <Setter Property="IsReadOnly" Value="True"/>
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="TextWrapping" Value="Wrap"/>
            <Setter Property="FontFamily" Value="Consolas"/>
            <Setter Property="FontSize" Value="12"/>
            <Setter Property="Padding" Value="5"/>
        </Style>

        <Style x:Key="SmallButtonStyle" TargetType="Button">
            <Setter Property="Width" Value="40"/>
            <Setter Property="Height" Value="30"/>
            <Setter Property="Margin" Value="2"/>
            <Setter Property="Background" Value="#E0E0E0"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" Background="{TemplateBinding Background}" 
                                CornerRadius="3" Padding="5">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#BDBDBD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <Style x:Key="CancerListItemStyle" TargetType="ListBoxItem">
            <Setter Property="Padding" Value="8,4"/>
            <Setter Property="Margin" Value="2"/>
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="ListBoxItem">
                        <Border x:Name="border" Background="{TemplateBinding Background}" 
                                CornerRadius="3" Padding="{TemplateBinding Padding}">
                            <ContentPresenter/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsSelected" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#BBDEFB"/>
                            </Trigger>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#E3F2FD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <Style TargetType="TabItem">
            <Setter Property="Padding" Value="12,6"/>
            <Setter Property="FontSize" Value="12"/>
        </Style>

        <Style x:Key="ConditionRadioStyle" TargetType="RadioButton">
            <Setter Property="Margin" Value="0,0,15,0"/>
            <Setter Property="VerticalAlignment" Value="Center"/>
        </Style>

        <Style x:Key="DataGridStyle" TargetType="DataGrid">
            <Setter Property="AutoGenerateColumns" Value="False"/>
            <Setter Property="IsReadOnly" Value="True"/>
            <Setter Property="CanUserAddRows" Value="False"/>
            <Setter Property="GridLinesVisibility" Value="Horizontal"/>
            <Setter Property="HorizontalGridLinesBrush" Value="#E0E0E0"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="BorderBrush" Value="#E0E0E0"/>
            <Setter Property="RowHeight" Value="28"/>
            <Setter Property="SelectionMode" Value="Extended"/>
            <Setter Property="SelectionUnit" Value="CellOrRowHeader"/>
            <Setter Property="ClipboardCopyMode" Value="IncludeHeader"/>
        </Style>
    </Page.Resources>

    <Grid>
        <Grid x:Name="ProgressOverlay" Visibility="Collapsed" Panel.ZIndex="100">
            <Border Background="#80000000"/>
            <Border Background="White" CornerRadius="8" Padding="30" 
                    HorizontalAlignment="Center" VerticalAlignment="Center" MinWidth="350">
                <StackPanel>
                    <TextBlock x:Name="ProgressTitle" Text="Loading..." FontSize="16" FontWeight="SemiBold" Margin="0,0,0,15"/>
                    <ProgressBar x:Name="ProgressBar" Height="20" Minimum="0" Maximum="100" Value="0"/>
                    <TextBlock x:Name="ProgressText" Text="0%" HorizontalAlignment="Center" Margin="0,10,0,0" Foreground="#666"/>
                </StackPanel>
            </Border>
        </Grid>

        <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
            <Grid Margin="15">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <TextBlock Grid.Row="0" Text="TCGA Database Analysis" 
                           FontSize="22" FontWeight="Bold" Foreground="#1976D2" Margin="0,0,0,15"/>

                <!-- Cancer Selection -->
                <Border Grid.Row="1" Background="White" CornerRadius="8" Padding="15" Margin="0,0,0,15">
                    <Border.Effect>
                        <DropShadowEffect BlurRadius="10" ShadowDepth="2" Opacity="0.1"/>
                    </Border.Effect>
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="180"/>
                        </Grid.RowDefinitions>

                        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,10">
                            <TextBlock Text="📊 Cancer Type Selection" Style="{StaticResource SectionTitleStyle}" 
                                       VerticalAlignment="Center" Margin="0,0,20,0"/>
                            <RadioButton x:Name="SingleSelectRadio" Content="Single Select" 
                                         IsChecked="True" Margin="0,0,15,0" 
                                         Checked="SelectionMode_Changed" VerticalAlignment="Center"/>
                            <RadioButton x:Name="MultiSelectRadio" Content="Multi Select" 
                                         Checked="SelectionMode_Changed" VerticalAlignment="Center"/>
                        </StackPanel>

                        <Grid x:Name="SingleSelectPanel" Grid.Row="1">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="300"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            <StackPanel Grid.Column="0">
                                <ComboBox x:Name="SingleCancerComboBox" Height="32" 
                                          SelectionChanged="SingleCancerComboBox_SelectionChanged"/>
                                <TextBlock x:Name="SingleCancerInfoText" Margin="0,10,0,0" Foreground="#666" TextWrapping="Wrap"/>
                            </StackPanel>
                        </Grid>

                        <Grid x:Name="MultiSelectPanel" Grid.Row="1" Visibility="Collapsed">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>

                            <StackPanel Grid.Column="0">
                                <TextBlock Text="Available Cancers" FontWeight="SemiBold" Margin="0,0,0,5"/>
                                <ListBox x:Name="AvailableCancerList" Height="140" 
                                         ItemContainerStyle="{StaticResource CancerListItemStyle}"
                                         SelectionMode="Extended" MouseDoubleClick="AvailableCancerList_MouseDoubleClick">
                                    <ListBox.ItemTemplate>
                                        <DataTemplate>
                                            <TextBlock Text="{Binding DisplayName}"/>
                                        </DataTemplate>
                                    </ListBox.ItemTemplate>
                                </ListBox>
                            </StackPanel>

                            <StackPanel Grid.Column="1" VerticalAlignment="Center" Margin="10,20,10,0">
                                <Button Content="▶" Style="{StaticResource SmallButtonStyle}" Click="AddSelectedCancers_Click"/>
                                <Button Content="▶▶" Style="{StaticResource SmallButtonStyle}" Click="AddAllCancers_Click"/>
                                <Button Content="◀" Style="{StaticResource SmallButtonStyle}" Click="RemoveSelectedCancers_Click"/>
                                <Button Content="◀◀" Style="{StaticResource SmallButtonStyle}" Click="RemoveAllCancers_Click"/>
                            </StackPanel>

                            <StackPanel Grid.Column="2">
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="Selected Cancers" FontWeight="SemiBold" Margin="0,0,5,5"/>
                                    <TextBlock x:Name="SelectedCountText" Text=" (0)" Foreground="#666"/>
                                </StackPanel>
                                <ListBox x:Name="SelectedCancerList" Height="140"
                                         ItemContainerStyle="{StaticResource CancerListItemStyle}"
                                         SelectionMode="Extended" MouseDoubleClick="SelectedCancerList_MouseDoubleClick">
                                    <ListBox.ItemTemplate>
                                        <DataTemplate>
                                            <TextBlock Text="{Binding DisplayName}"/>
                                        </DataTemplate>
                                    </ListBox.ItemTemplate>
                                </ListBox>
                            </StackPanel>
                        </Grid>
                    </Grid>
                </Border>

                <!-- Condition Selection -->
                <Border Grid.Row="2" Background="White" CornerRadius="8" Padding="15" Margin="0,0,0,15">
                    <Border.Effect>
                        <DropShadowEffect BlurRadius="10" ShadowDepth="2" Opacity="0.1"/>
                    </Border.Effect>
                    <StackPanel Orientation="Horizontal">
                        <TextBlock Text="🔬 Sample Condition:" VerticalAlignment="Center" FontWeight="SemiBold" Margin="0,0,15,0"/>
                        <RadioButton x:Name="ConditionBoth" Content="Both" IsChecked="True" Style="{StaticResource ConditionRadioStyle}"/>
                        <RadioButton x:Name="ConditionTumorOnly" Content="Tumor Only" Style="{StaticResource ConditionRadioStyle}"/>
                        <RadioButton x:Name="ConditionNormalOnly" Content="Normal Only" Style="{StaticResource ConditionRadioStyle}"/>
                    </StackPanel>
                </Border>

                <!-- Analysis Panel with Tabs -->
                <Border Grid.Row="3" Background="White" CornerRadius="8" Padding="15">
                    <Border.Effect>
                        <DropShadowEffect BlurRadius="10" ShadowDepth="2" Opacity="0.1"/>
                    </Border.Effect>

                    <TabControl>
                        <!-- Tab 1: Box Plot -->
                        <TabItem Header="📊 Box Plot">
                            <Grid Margin="15">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                </Grid.RowDefinitions>

                                <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,15">
                                    <TextBlock Text="Gene ID:" VerticalAlignment="Center" Margin="0,0,10,0"/>
                                    <TextBox x:Name="BoxPlotGeneIdTextBox" Width="150" Height="30" 
                                             VerticalContentAlignment="Center" Padding="5"/>
                                    <Button Content="Analyze" Style="{StaticResource ActionButtonStyle}" Margin="10,0,0,0"
                                            Click="AnalyzeGeneExpression_Click"/>
                                    <Button Content="📷 Export PNG" Style="{StaticResource ExportButtonStyle}" 
                                            Click="ExportBoxPlotImage_Click"/>
                                    <Button Content="📄 Export CSV" Style="{StaticResource ExportButtonStyle}" 
                                            Click="ExportBoxPlotCsv_Click"/>
                                </StackPanel>

                                <Border Grid.Row="1" BorderBrush="#E0E0E0" BorderThickness="1" CornerRadius="4" HorizontalAlignment="Left">
                                    <ScrollViewer HorizontalScrollBarVisibility="Auto" VerticalScrollBarVisibility="Disabled">
                                        <Canvas x:Name="BoxPlotCanvas" Width="800" Height="500" Background="White" ClipToBounds="True"/>
                                    </ScrollViewer>
                                </Border>

                                <StackPanel Grid.Row="2" Margin="0,15,0,0">
                                    <StackPanel Orientation="Horizontal" Margin="0,0,0,8">
                                        <TextBlock Text="📋 Statistics Table" FontWeight="SemiBold" VerticalAlignment="Center"/>
                                        <Button Content="📋 Copy Table" Style="{StaticResource CopyButtonStyle}" 
                                                Margin="15,0,0,0" Click="CopyBoxPlotStats_Click"/>
                                    </StackPanel>
                                    <DataGrid x:Name="BoxPlotStatsGrid" Style="{StaticResource DataGridStyle}" MaxHeight="250">
                                        <DataGrid.Columns>
                                            <DataGridTextColumn Header="Cancer" Binding="{Binding CancerCode}" Width="80"/>
                                            <DataGridTextColumn Header="Gene" Binding="{Binding GeneName}" Width="100"/>
                                            <DataGridTextColumn Header="Tumor N" Binding="{Binding TumorN}" Width="70"/>
                                            <DataGridTextColumn Header="Tumor Mean" Binding="{Binding TumorMean, StringFormat=F3}" Width="90"/>
                                            <DataGridTextColumn Header="Tumor SD" Binding="{Binding TumorSd, StringFormat=F3}" Width="80"/>
                                            <DataGridTextColumn Header="Normal N" Binding="{Binding NormalN}" Width="70"/>
                                            <DataGridTextColumn Header="Normal Mean" Binding="{Binding NormalMean, StringFormat=F3}" Width="95"/>
                                            <DataGridTextColumn Header="Normal SD" Binding="{Binding NormalSd, StringFormat=F3}" Width="80"/>
                                            <DataGridTextColumn Header="P-value" Binding="{Binding PValueDisplay}" Width="100"/>
                                            <DataGridTextColumn Header="FDR" Binding="{Binding FdrDisplay}" Width="100"/>
                                        </DataGrid.Columns>
                                    </DataGrid>
                                </StackPanel>

                                <TextBlock Grid.Row="3" x:Name="BoxPlotResultText" TextWrapping="Wrap" Foreground="#666" Margin="0,10,0,0"/>
                            </Grid>
                        </TabItem>

                        <!-- Tab 2: Correlation Heatmap -->
                        <TabItem Header="🔗 Heatmap">
                            <Grid Margin="15">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                </Grid.RowDefinitions>

                                <Grid Grid.Row="0" Margin="0,0,0,15">
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="Auto"/>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="Auto"/>
                                    </Grid.ColumnDefinitions>

                                    <StackPanel Grid.Column="0">
                                        <TextBlock Text="Gene IDs (one per line):" Margin="0,0,0,5"/>
                                        <TextBox x:Name="CorrelationGenesTextBox" Width="250" Height="120"
                                                 AcceptsReturn="True" TextWrapping="Wrap" VerticalScrollBarVisibility="Auto"/>
                                    </StackPanel>

                                    <StackPanel Grid.Column="2" VerticalAlignment="Bottom">
                                        <Button Content="Generate Heatmap" Style="{StaticResource ActionButtonStyle}"
                                                Click="CalculateCorrelation_Click"/>
                                        <Button Content="📷 Export PNG" Style="{StaticResource ExportButtonStyle}" Margin="0,10,0,0"
                                                Click="ExportHeatmapImage_Click"/>
                                        <Button Content="📄 Export CSV" Style="{StaticResource ExportButtonStyle}" Margin="0,5,0,0"
                                                Click="ExportHeatmapCsv_Click"/>
                                    </StackPanel>
                                </Grid>

                                <Border Grid.Row="1" BorderBrush="#E0E0E0" BorderThickness="1" CornerRadius="4" HorizontalAlignment="Left">
                                    <Canvas x:Name="HeatmapCanvas" Width="600" Height="600" Background="White" ClipToBounds="True"/>
                                </Border>

                                <TextBlock Grid.Row="2" x:Name="HeatmapResultText" TextWrapping="Wrap" Foreground="#666" Margin="0,10,0,0"/>
                            </Grid>
                        </TabItem>

                        <!-- Tab 3: Scatter Plot -->
                        <TabItem Header="📈 Scatter">
                            <Grid Margin="15">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                </Grid.RowDefinitions>

                                <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,15">
                                    <TextBlock Text="Gene X:" VerticalAlignment="Center" Margin="0,0,5,0"/>
                                    <TextBox x:Name="ScatterGeneXTextBox" Width="150" Height="30" VerticalContentAlignment="Center" Padding="5"/>
                                    <TextBlock Text="Gene Y:" VerticalAlignment="Center" Margin="20,0,5,0"/>
                                    <TextBox x:Name="ScatterGeneYTextBox" Width="150" Height="30" VerticalContentAlignment="Center" Padding="5"/>
                                    <Button Content="Plot" Style="{StaticResource ActionButtonStyle}" Margin="15,0,0,0" Click="PlotScatter_Click"/>
                                    <Button Content="📷 Export PNG" Style="{StaticResource ExportButtonStyle}" Click="ExportScatterImage_Click"/>
                                    <Button Content="📄 Export CSV" Style="{StaticResource ExportButtonStyle}" Click="ExportScatterCsv_Click"/>
                                </StackPanel>

                                <Border Grid.Row="1" BorderBrush="#E0E0E0" BorderThickness="1" CornerRadius="4" HorizontalAlignment="Left">
                                    <Canvas x:Name="ScatterPlotCanvas" Width="700" Height="600" Background="White" ClipToBounds="True"/>
                                </Border>

                                <Border Grid.Row="2" Background="#F5F5F5" CornerRadius="4" Padding="10" Margin="0,10,0,0">
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="Auto"/>
                                        </Grid.ColumnDefinitions>
                                        <TextBox x:Name="ScatterResultText" Style="{StaticResource SelectableStatsStyle}" Grid.Column="0"/>
                                        <StackPanel Grid.Column="1" VerticalAlignment="Top" Margin="10,0,0,0">
                                            <Button Content="📋 Copy Stats" Style="{StaticResource CopyButtonStyle}" Click="CopyScatterStats_Click"/>
                                            <Button Content="📋 Copy R²" Style="{StaticResource CopyButtonStyle}" Margin="0,5,0,0" Click="CopyScatterR2_Click"/>
                                            <Button Content="📋 Copy Eq" Style="{StaticResource CopyButtonStyle}" Margin="0,5,0,0" Click="CopyScatterEquation_Click"/>
                                        </StackPanel>
                                    </Grid>
                                </Border>
                            </Grid>
                        </TabItem>

                        <!-- Tab 4: Kaplan-Meier Survival Analysis (NEW) -->
                        <TabItem Header="📉 Survival (KM)">
                            <Grid Margin="15">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                </Grid.RowDefinitions>

                                <!-- Control Panel -->
                                <StackPanel Grid.Row="0" Margin="0,0,0,15">
                                    <StackPanel Orientation="Horizontal" Margin="0,0,0,10">
                                        <TextBlock Text="Gene ID:" VerticalAlignment="Center" Margin="0,0,10,0"/>
                                        <TextBox x:Name="KMGeneIdTextBox" Width="150" Height="30" 
                                                 VerticalContentAlignment="Center" Padding="5"/>
                                        <Button Content="Load Data" Style="{StaticResource ActionButtonStyle}" 
                                                Margin="10,0,0,0" Click="LoadSurvivalData_Click"/>
                                        <Button Content="📷 Export PNG" Style="{StaticResource ExportButtonStyle}"
                                                Click="ExportKMImage_Click"/>
                                        <Button Content="📄 Export CSV" Style="{StaticResource ExportButtonStyle}"
                                                Click="ExportKMCsv_Click"/>
                                    </StackPanel>

                                    <!-- Percentile Slider - REAL-TIME UPDATE -->
                                    <Border Background="#F0F0F0" CornerRadius="4" Padding="15" Margin="0,5,0,0">
                                        <StackPanel>
                                            <StackPanel Orientation="Horizontal" Margin="0,0,0,10">
                                                <TextBlock Text="Expression Cutoff Percentile: " VerticalAlignment="Center"/>
                                                <TextBlock x:Name="KMPercentileText" Text="50%" FontWeight="Bold" 
                                                           Foreground="#1976D2" VerticalAlignment="Center" Width="50"/>
                                                <TextBlock Text="  |  High: top " VerticalAlignment="Center" Margin="10,0,0,0"/>
                                                <TextBlock x:Name="KMHighPercentText" Text="50%" VerticalAlignment="Center" Foreground="#e74c3c" FontWeight="Bold"/>
                                                <TextBlock Text=" , Low: bottom " VerticalAlignment="Center"/>
                                                <TextBlock x:Name="KMLowPercentText" Text="50%" VerticalAlignment="Center" Foreground="#3498db" FontWeight="Bold"/>
                                            </StackPanel>
                                            <Slider x:Name="KMPercentileSlider" Minimum="10" Maximum="90" Value="50" 
                                                    TickFrequency="5" IsSnapToTickEnabled="True" Width="600"
                                                    ValueChanged="KMPercentileSlider_ValueChanged"/>
                                            <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                                                <TextBlock Text="10%" Foreground="#888" FontSize="10"/>
                                                <TextBlock Text="90%" Foreground="#888" FontSize="10" Margin="555,0,0,0"/>
                                            </StackPanel>
                                            <TextBlock Text="⚠️ Note: Adjusting cutoff to optimize P-value may inflate false positive rate. Use Median (50%) for unbiased analysis." 
                                                       Foreground="#FF9800" FontSize="10" FontStyle="Italic" Margin="0,5,0,0" TextWrapping="Wrap"/>
                                        </StackPanel>
                                    </Border>
                                </StackPanel>

                                <!-- Chart Area -->
                                <Border Grid.Row="1" BorderBrush="#E0E0E0" BorderThickness="1" CornerRadius="4" HorizontalAlignment="Left">
                                    <Canvas x:Name="KMPlotCanvas" Width="800" Height="500" Background="White" ClipToBounds="True"/>
                                </Border>

                                <!-- Statistics -->
                                <Border Grid.Row="2" Background="#F5F5F5" CornerRadius="4" Padding="15" Margin="0,15,0,0">
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="Auto"/>
                                        </Grid.ColumnDefinitions>

                                        <StackPanel Grid.Column="0">
                                            <TextBlock Text="🔴 High Expression Group" FontWeight="Bold" Foreground="#e74c3c" Margin="0,0,0,5"/>
                                            <TextBlock x:Name="KMHighGroupStats" FontFamily="Consolas" FontSize="11"/>
                                        </StackPanel>

                                        <StackPanel Grid.Column="1">
                                            <TextBlock Text="🔵 Low Expression Group" FontWeight="Bold" Foreground="#3498db" Margin="0,0,0,5"/>
                                            <TextBlock x:Name="KMLowGroupStats" FontFamily="Consolas" FontSize="11"/>
                                        </StackPanel>

                                        <StackPanel Grid.Column="2" VerticalAlignment="Top">
                                            <Button Content="📋 Copy Stats" Style="{StaticResource CopyButtonStyle}" Click="CopyKMStats_Click"/>
                                        </StackPanel>
                                    </Grid>
                                </Border>

                                <!-- Log-Rank Test Result -->
                                <Border Grid.Row="3" Background="#E3F2FD" CornerRadius="4" Padding="10" Margin="0,10,0,0">
                                    <TextBlock x:Name="KMLogRankText" FontSize="14" FontWeight="SemiBold"/>
                                </Border>
                            </Grid>
                        </TabItem>

                        <!-- Tab 5: Volcano Plot (NEW) -->
                        <TabItem Header="🌋 Volcano">
                            <Grid Margin="15">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                </Grid.RowDefinitions>

                                <!-- Control Panel -->
                                <StackPanel Grid.Row="0" Margin="0,0,0,15">
                                    <StackPanel Orientation="Horizontal" Margin="0,0,0,10">
                                        <Button Content="Generate Volcano Plot" Style="{StaticResource ActionButtonStyle}"
                        Click="GenerateVolcano_Click"/>
                                        <Button Content="📷 Export PNG" Style="{StaticResource ExportButtonStyle}"
                        Click="ExportVolcanoImage_Click"/>
                                        <Button Content="📄 Export CSV" Style="{StaticResource ExportButtonStyle}"
                        Click="ExportVolcanoCsv_Click"/>
                                        <TextBlock Text="  (Compares Tumor vs Normal)" Foreground="#666" 
                           VerticalAlignment="Center" Margin="10,0,0,0"/>
                                    </StackPanel>

                                    <!-- Threshold Settings -->
                                    <Border Background="#F0F0F0" CornerRadius="4" Padding="15">
                                        <StackPanel Orientation="Horizontal">
                                            <TextBlock Text="FDR Threshold:" VerticalAlignment="Center" Margin="0,0,5,0"/>
                                            <TextBox x:Name="VolcanoFdrTextBox" Width="60" Height="25" Text="0.05" 
                             VerticalContentAlignment="Center" TextAlignment="Center"
                             TextChanged="VolcanoThreshold_Changed"/>

                                            <TextBlock Text="Log2 FC Threshold:" VerticalAlignment="Center" Margin="20,0,5,0"/>
                                            <TextBox x:Name="VolcanoFcTextBox" Width="60" Height="25" Text="1.0"
                             VerticalContentAlignment="Center" TextAlignment="Center"
                             TextChanged="VolcanoThreshold_Changed"/>

                                            <TextBlock Text="  |  " Foreground="#CCC" VerticalAlignment="Center" Margin="10,0"/>
                                            <TextBlock x:Name="VolcanoSummaryText" VerticalAlignment="Center" FontWeight="SemiBold"/>
                                        </StackPanel>
                                    </Border>
                                </StackPanel>

                                <!-- Chart -->
                                <Border Grid.Row="1" BorderBrush="#E0E0E0" BorderThickness="1" CornerRadius="4" HorizontalAlignment="Left">
                                    <Canvas x:Name="VolcanoPlotCanvas" Width="900" Height="600" Background="White" ClipToBounds="True"/>
                                </Border>

                                <!-- Significant Genes Table with Search and Checkbox -->
                                <StackPanel Grid.Row="2" Margin="0,15,0,0">
                                    <!-- Header with Search -->
                                    <Grid Margin="0,0,0,8">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="Auto"/>
                                        </Grid.ColumnDefinitions>

                                        <TextBlock Grid.Column="0" Text="📋 Significant Genes" FontWeight="SemiBold" VerticalAlignment="Center"/>
                                        <TextBlock Grid.Column="1" x:Name="VolcanoGeneCountText" Text=" (0 genes)" Foreground="#666" VerticalAlignment="Center"/>

                                        <!-- Search Box -->
                                        <StackPanel Grid.Column="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,0,15,0">
                                            <TextBlock Text="🔍 Search Gene:" VerticalAlignment="Center" Margin="0,0,8,0"/>
                                            <TextBox x:Name="VolcanoSearchTextBox" Width="150" Height="25" 
                             VerticalContentAlignment="Center" Padding="5,0"
                             TextChanged="VolcanoSearch_TextChanged"/>
                                            <Button Content="Clear" Padding="8,3" Margin="5,0,0,0" 
                            Click="VolcanoSearchClear_Click"/>
                                            <Button Content="Highlight Selected" Padding="8,3" Margin="10,0,0,0"
                            Background="#FF9800" Foreground="White"
                            Click="VolcanoHighlightSelected_Click"/>
                                        </StackPanel>

                                        <Button Grid.Column="3" Content="📋 Copy Table" Style="{StaticResource CopyButtonStyle}" 
                        Click="CopyVolcanoStats_Click"/>
                                    </Grid>

                                    <!-- DataGrid with Checkbox Column -->
                                    <DataGrid x:Name="VolcanoStatsGrid" Style="{StaticResource DataGridStyle}" MaxHeight="300"
                      SelectionMode="Extended" CanUserSortColumns="True">
                                        <DataGrid.Columns>
                                            <!-- Highlight Checkbox Column -->
                                            <DataGridTemplateColumn Header="📍" Width="40">
                                                <DataGridTemplateColumn.CellTemplate>
                                                    <DataTemplate>
                                                        <CheckBox IsChecked="{Binding IsHighlighted, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                                          HorizontalAlignment="Center" VerticalAlignment="Center"
                                          Click="VolcanoHighlightCheckbox_Click"/>
                                                    </DataTemplate>
                                                </DataGridTemplateColumn.CellTemplate>
                                            </DataGridTemplateColumn>

                                            <DataGridTextColumn Header="Gene" Binding="{Binding GeneName}" Width="100"/>
                                            <DataGridTextColumn Header="Gene ID" Binding="{Binding GeneId}" Width="120"/>
                                            <DataGridTextColumn Header="Log2 FC" Binding="{Binding Log2FoldChange, StringFormat=F3}" Width="80"/>
                                            <DataGridTextColumn Header="P-value" Binding="{Binding PValueDisplay}" Width="100"/>
                                            <DataGridTextColumn Header="FDR" Binding="{Binding FDRDisplay}" Width="100"/>
                                            <DataGridTextColumn Header="Regulation" Binding="{Binding Regulation}" Width="80"/>
                                            <DataGridTextColumn Header="Tumor Mean" Binding="{Binding TumorMean, StringFormat=F3}" Width="90"/>
                                            <DataGridTextColumn Header="Normal Mean" Binding="{Binding NormalMean, StringFormat=F3}" Width="95"/>
                                        </DataGrid.Columns>
                                    </DataGrid>

                                    <!-- Highlighted Genes Info -->
                                    <StackPanel Orientation="Horizontal" Margin="0,8,0,0">
                                        <TextBlock Text="📌 Highlighted genes: " Foreground="#666"/>
                                        <TextBlock x:Name="VolcanoHighlightedCountText" Text="0" FontWeight="SemiBold" Foreground="#FF9800"/>
                                        <Button Content="Clear All Highlights" Padding="8,2" Margin="15,0,0,0" FontSize="11"
                        Click="VolcanoClearHighlights_Click"/>
                                    </StackPanel>
                                </StackPanel>

                                <TextBlock Grid.Row="3" x:Name="VolcanoResultText" TextWrapping="Wrap" Foreground="#666" Margin="0,10,0,0"/>
                            </Grid>
                        </TabItem>
                    </TabControl>
                </Border>
            </Grid>
        </ScrollViewer>
    </Grid>
</Page>


==================================================
FILE_NAME: TcgaAnalysisPage.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\TcgaAnalysisPage.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using Microsoft.Win32;
using BioSAK.Services;

namespace BioSAK.Pages
{
    public partial class TcgaAnalysisPage : Page
    {
        private TcgaGeneHelper _geneHelper;
        private readonly TcgaDataService _dataService;
        private ObservableCollection<TcgaProjectIndex> _availableCancers;
        private ObservableCollection<TcgaProjectIndex> _selectedCancers;
        private List<TcgaProjectIndex> _allProjects;

        // Box Plot data
        private List<BoxPlotStatsRow> _currentBoxPlotStats;
        // Correlation data
        private double[,] _currentCorrelationMatrix;
        private List<string> _currentCorrelationGenes;
        // Scatter data
        private List<ScatterDataPoint> _currentScatterPoints;
        private string _currentGeneX, _currentGeneY, _currentCancer;
        private bool _geneHelperReady = false;
        private double _scatterR, _scatterR2, _scatterPValue, _scatterSlope, _scatterIntercept;
        private int _scatterN;

        // Kaplan-Meier data
        private GeneSurvivalResult _currentSurvivalData;
        private KMComparisonResult _currentKMResult;
        private string _currentKMGene, _currentKMCancer;


        // Volcano data
        private VolcanoPlotResult _currentVolcanoData;
        private string _currentVolcanoCancer;
        private WriteableBitmap _volcanoBitmap;  // 效能優化用
        private Image _volcanoImage;  // 重用 Image 控制項，避免每次重建

        // Colors
        private static readonly Color NormalColor = Color.FromRgb(52, 152, 219);
        private static readonly Color TumorColor = Color.FromRgb(231, 76, 60);
        private static readonly Brush NormalBrush = new SolidColorBrush(NormalColor);
        private static readonly Brush TumorBrush = new SolidColorBrush(TumorColor);
        private static readonly Color HighExprColor = Color.FromRgb(231, 76, 60);
        private static readonly Color LowExprColor = Color.FromRgb(52, 152, 219);
        private static readonly Brush HighExprBrush = new SolidColorBrush(HighExprColor);
        private static readonly Brush LowExprBrush = new SolidColorBrush(LowExprColor);

        public TcgaAnalysisPage()
        {
            InitializeComponent();
            _dataService = new TcgaDataService();
            _availableCancers = new ObservableCollection<TcgaProjectIndex>();
            _selectedCancers = new ObservableCollection<TcgaProjectIndex>();

            AvailableCancerList.ItemsSource = _availableCancers;
            SelectedCancerList.ItemsSource = _selectedCancers;
            _geneHelper = new TcgaGeneHelper();
            Loaded += TcgaAnalysisPage_Loaded;
        }

        #region Progress Bar
        private void ShowProgress(string title, int value = 0)
        {
            ProgressTitle.Text = title;
            ProgressBar.Value = value;
            ProgressText.Text = $"{value}%";
            ProgressOverlay.Visibility = Visibility.Visible;
        }

        private async void TcgaAnalysisPage_Loaded(object sender, RoutedEventArgs e)
        {
            await LoadProjectsAsync();
            try
            {
                _geneHelperReady = await _geneHelper.InitializeAsync();
            }
            catch { }
        }

        private void UpdateProgress(int value, string message = null)
        {
            ProgressBar.Value = value;
            ProgressText.Text = message ?? $"{value}%";
            Dispatcher.Invoke(() => { }, System.Windows.Threading.DispatcherPriority.Render);
        }

        private void HideProgress() => ProgressOverlay.Visibility = Visibility.Collapsed;
        #endregion

        #region Initialization
        private async Task LoadProjectsAsync()
        {
            try
            {
                ShowProgress("Loading TCGA projects...");
                if (!_dataService.IsDataAvailable())
                {
                    HideProgress();
                    MessageBox.Show("TCGA data not found.\nPlease ensure data files are in Data/TCGA folder.",
                        "Data Not Found", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                _allProjects = await _dataService.GetProjectIndexAsync();
                _allProjects = _allProjects.OrderBy(p => p.CancerCode).ToList();

                _availableCancers.Clear();
                foreach (var p in _allProjects) _availableCancers.Add(p);

                SingleCancerComboBox.ItemsSource = _allProjects;
                SingleCancerComboBox.DisplayMemberPath = "DisplayName";
                if (_allProjects.Count > 0) SingleCancerComboBox.SelectedIndex = 0;

                HideProgress();
            }
            catch (Exception ex)
            {
                HideProgress();
                MessageBox.Show($"Error loading data: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private string GetSelectedCondition()
        {
            if (ConditionTumorOnly.IsChecked == true) return "Tumor";
            if (ConditionNormalOnly.IsChecked == true) return "Normal";
            return "Both";
        }

        private List<TcgaProjectIndex> GetSelectedProjects()
        {
            if (SingleSelectRadio.IsChecked == true)
            {
                if (SingleCancerComboBox.SelectedItem is TcgaProjectIndex p)
                    return new List<TcgaProjectIndex> { p };
                return new List<TcgaProjectIndex>();
            }
            return _selectedCancers.ToList();
        }

        /// <summary>
        /// 用於只支援單一癌症的分析 Tab (Heatmap, Scatter, Survival, Volcano)。
        /// Multi-select 模式下會提示使用者僅使用第一個選取的癌症。
        /// </summary>
        private TcgaProjectIndex GetSingleProject(string analysisName)
        {
            var projects = GetSelectedProjects();
            if (projects.Count == 0) return null;

            if (MultiSelectRadio.IsChecked == true && projects.Count > 1)
            {
                MessageBox.Show(
                    $"{analysisName} only supports single cancer type analysis.\n" +
                    $"Using: {projects.First().CancerCode} ({projects.First().DisplayName})\n\n" +
                    $"Tip: Switch to Single Select mode, or use Box Plot for multi-cancer comparison.",
                    "Single Cancer Mode", MessageBoxButton.OK, MessageBoxImage.Information);
            }

            return projects.First();
        }
        #endregion

        #region Cancer Selection
        private void SelectionMode_Changed(object sender, RoutedEventArgs e)
        {
            if (SingleSelectRadio == null || SingleSelectPanel == null || MultiSelectPanel == null) return;
            SingleSelectPanel.Visibility = SingleSelectRadio.IsChecked == true ? Visibility.Visible : Visibility.Collapsed;
            MultiSelectPanel.Visibility = SingleSelectRadio.IsChecked == true ? Visibility.Collapsed : Visibility.Visible;
        }

        private void SingleCancerComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (SingleCancerComboBox.SelectedItem is TcgaProjectIndex p)
            {
                string survivalInfo = p.HasSurvivalData ? $"\nSurvival data: {p.n_survival_available} (Alive: {p.n_alive}, Dead: {p.n_dead})" : "";
                SingleCancerInfoText.Text = $"Samples: {p.n_samples} (Tumor: {p.n_tumor}, Normal: {p.n_normal})\nGenes: {p.n_genes:N0}{survivalInfo}";
            }
        }

        private void AvailableCancerList_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (AvailableCancerList.SelectedItem is TcgaProjectIndex item)
            {
                _selectedCancers.Add(item);
                _availableCancers.Remove(item);
                UpdateSelectedCount();
            }
        }

        private void SelectedCancerList_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (SelectedCancerList.SelectedItem is TcgaProjectIndex item)
            {
                _selectedCancers.Remove(item);
                int idx = _allProjects.IndexOf(item);
                int insert = _availableCancers.Count;
                for (int i = 0; i < _availableCancers.Count; i++)
                {
                    if (_allProjects.IndexOf(_availableCancers[i]) > idx) { insert = i; break; }
                }
                _availableCancers.Insert(insert, item);
                UpdateSelectedCount();
            }
        }

        private void AddSelectedCancers_Click(object sender, RoutedEventArgs e)
        {
            foreach (var item in AvailableCancerList.SelectedItems.Cast<TcgaProjectIndex>().ToList())
            {
                _selectedCancers.Add(item);
                _availableCancers.Remove(item);
            }
            UpdateSelectedCount();
        }

        private void RemoveSelectedCancers_Click(object sender, RoutedEventArgs e)
        {
            foreach (var item in SelectedCancerList.SelectedItems.Cast<TcgaProjectIndex>().ToList())
            {
                _selectedCancers.Remove(item);
                int idx = _allProjects.IndexOf(item);
                int insert = _availableCancers.Count;
                for (int i = 0; i < _availableCancers.Count; i++)
                {
                    if (_allProjects.IndexOf(_availableCancers[i]) > idx) { insert = i; break; }
                }
                _availableCancers.Insert(insert, item);
            }
            UpdateSelectedCount();
        }

        private void AddAllCancers_Click(object sender, RoutedEventArgs e)
        {
            foreach (var item in _availableCancers.ToList()) _selectedCancers.Add(item);
            _availableCancers.Clear();
            UpdateSelectedCount();
        }

        private void RemoveAllCancers_Click(object sender, RoutedEventArgs e)
        {
            _selectedCancers.Clear();
            _availableCancers.Clear();
            foreach (var p in _allProjects) _availableCancers.Add(p);
            UpdateSelectedCount();
        }

        private void UpdateSelectedCount() => SelectedCountText.Text = $" ({_selectedCancers.Count})";
        #endregion

        #region Box Plot Analysis (Tab 1) - FIXED

        private async void AnalyzeGeneExpression_Click(object sender, RoutedEventArgs e)
        {
            var geneId = BoxPlotGeneIdTextBox.Text.Trim();
            if (string.IsNullOrEmpty(geneId))
            {
                MessageBox.Show("Please enter a gene ID.");
                return;
            }

            var projects = GetSelectedProjects();
            if (projects.Count == 0)
            {
                MessageBox.Show("Please select at least one cancer type.");
                return;
            }

            // 使用 GeneHelper 轉換基因 ID
            if (_geneHelperReady)
            {
                geneId = _geneHelper.ToSymbol(geneId);
            }

            string condition = GetSelectedCondition();

            var btn = sender as Button;
            if (btn != null) btn.IsEnabled = false;
            try
            {
                ShowProgress("Analyzing gene expression...", 0);

                var stats = new List<BoxPlotStatsRow>();
                var allTumorValues = new Dictionary<string, List<double>>();
                var allNormalValues = new Dictionary<string, List<double>>();

                int total = projects.Count;
                int processed = 0;

                foreach (var project in projects)
                {
                    processed++;
                    UpdateProgress(processed * 80 / total, $"Loading {project.CancerCode}...");

                    var expr = await _dataService.GetGeneExpressionAsync(project.project_id, geneId);
                    if (expr == null) continue;

                    var row = new BoxPlotStatsRow
                    {
                        CancerCode = project.CancerCode,
                        GeneId = expr.GeneId,
                        GeneName = expr.GeneName ?? geneId,
                        TumorN = expr.TumorValues.Count,
                        NormalN = expr.NormalValues.Count
                    };

                    if (expr.TumorValues.Count > 0)
                    {
                        row.TumorMean = expr.TumorValues.Average();
                        row.TumorSd = StatisticsService.StandardDeviation(expr.TumorValues);
                        var q = StatisticsService.Quartiles(expr.TumorValues);
                        row.TumorQ1 = q.Q1;
                        row.TumorMedian = q.Median;
                        row.TumorQ3 = q.Q3;
                        allTumorValues[project.CancerCode] = expr.TumorValues;
                    }

                    if (expr.NormalValues.Count > 0)
                    {
                        row.NormalMean = expr.NormalValues.Average();
                        row.NormalSd = StatisticsService.StandardDeviation(expr.NormalValues);
                        var q = StatisticsService.Quartiles(expr.NormalValues);
                        row.NormalQ1 = q.Q1;
                        row.NormalMedian = q.Median;
                        row.NormalQ3 = q.Q3;
                        allNormalValues[project.CancerCode] = expr.NormalValues;
                    }

                    // Calculate p-value if both groups have data
                    if (expr.TumorValues.Count >= 3 && expr.NormalValues.Count >= 3)
                    {
                        row.PValue = StatisticsService.WelchTTest(expr.TumorValues, expr.NormalValues);
                    }
                    else
                    {
                        row.PValue = 1.0;
                    }

                    stats.Add(row);
                }

                if (stats.Count == 0)
                {
                    HideProgress();
                    BoxPlotResultText.Text = $"Gene '{geneId}' not found in selected cancer types.";
                    return;
                }

                // FDR correction
                UpdateProgress(85, "Calculating FDR...");
                var pValues = stats.Select(s => s.PValue).ToList();
                var fdrs = StatisticsService.BenjaminiHochbergFDR(pValues);
                for (int i = 0; i < stats.Count; i++)
                {
                    stats[i].FDR = fdrs[i];
                }

                _currentBoxPlotStats = stats;

                // Draw box plot
                UpdateProgress(90, "Drawing plot...");
                bool showTumor = condition != "Normal";
                bool showNormal = condition != "Tumor";
                DrawBoxPlot(stats, allTumorValues, allNormalValues, geneId, showTumor, showNormal);

                // Update stats grid
                BoxPlotStatsGrid.ItemsSource = stats.OrderBy(s => s.PValue).ToList();

                HideProgress();
                BoxPlotResultText.Text = $"Gene: {stats.First().GeneName} | {stats.Count} cancer types analyzed";
            }
            catch (Exception ex)
            {
                HideProgress();
                MessageBox.Show($"Error: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                if (btn != null) btn.IsEnabled = true;
            }
        }

        private void CopyBoxPlotStats_Click(object sender, RoutedEventArgs e)
        {
            if (_currentBoxPlotStats == null || _currentBoxPlotStats.Count == 0)
            {
                MessageBox.Show("No data to copy.");
                return;
            }

            var sb = new StringBuilder();
            sb.AppendLine("Cancer\tGene\tTumor_N\tTumor_Mean\tTumor_SD\tNormal_N\tNormal_Mean\tNormal_SD\tP-value\tFDR");
            foreach (var row in _currentBoxPlotStats.OrderBy(s => s.PValue))
            {
                sb.AppendLine($"{row.CancerCode}\t{row.GeneName}\t{row.TumorN}\t{row.TumorMean:F4}\t{row.TumorSd:F4}\t{row.NormalN}\t{row.NormalMean:F4}\t{row.NormalSd:F4}\t{row.PValue:E2}\t{row.FDR:E2}");
            }

            Clipboard.SetText(sb.ToString());
            MessageBox.Show("Statistics copied to clipboard!");
        }

        private void DrawBoxPlot(List<BoxPlotStatsRow> stats,
            Dictionary<string, List<double>> tumorVals,
            Dictionary<string, List<double>> normalVals,
            string geneId, bool showTumor, bool showNormal)
        {
            BoxPlotCanvas.Children.Clear();

            int nCancers = stats.Count;
            int groupsPerCancer = (showTumor ? 1 : 0) + (showNormal ? 1 : 0);
            if (groupsPerCancer == 0) return;

            double boxWidth = 30;
            double groupSpacing = 20;
            double cancerSpacing = 50;
            double groupWidth = groupsPerCancer * boxWidth + (groupsPerCancer - 1) * groupSpacing;

            double marginLeft = 70, marginRight = 100, marginTop = 50, marginBottom = 80;
            double plotWidth = nCancers * groupWidth + (nCancers - 1) * cancerSpacing;
            double chartWidth = Math.Max(800, plotWidth + marginLeft + marginRight);
            double chartHeight = 500;
            double plotHeight = chartHeight - marginTop - marginBottom;

            BoxPlotCanvas.Width = chartWidth;
            BoxPlotCanvas.Height = chartHeight;

            // Find Y range
            var allValues = new List<double>();
            foreach (var kv in tumorVals) if (showTumor) allValues.AddRange(kv.Value);
            foreach (var kv in normalVals) if (showNormal) allValues.AddRange(kv.Value);

            if (allValues.Count == 0) return;

            double minY = allValues.Min();
            double maxY = allValues.Max();
            double padding = (maxY - minY) * 0.1;
            minY -= padding;
            maxY += padding;

            // Background
            AddRect(BoxPlotCanvas, marginLeft, marginTop, plotWidth, plotHeight, Brushes.White, Brushes.LightGray);

            // Y-axis grid lines
            for (int i = 0; i <= 5; i++)
            {
                double yVal = minY + (maxY - minY) * i / 5;
                double y = marginTop + plotHeight - plotHeight * i / 5;
                AddLine(BoxPlotCanvas, marginLeft, y, marginLeft + plotWidth, y, Brushes.LightGray, 0.5, true);
                AddText(BoxPlotCanvas, yVal.ToString("F1"), marginLeft - 45, y - 8, 9, Brushes.Gray);
            }

            // Draw boxes for each cancer
            double currentX = marginLeft + groupWidth / 2;
            foreach (var stat in stats)
            {
                double boxX = currentX - groupWidth / 2;

                if (showNormal && normalVals.ContainsKey(stat.CancerCode))
                {
                    DrawSingleBox(BoxPlotCanvas, boxX + boxWidth / 2, normalVals[stat.CancerCode],
                        minY, maxY, marginTop, plotHeight, boxWidth, NormalBrush);
                    boxX += boxWidth + groupSpacing;
                }

                if (showTumor && tumorVals.ContainsKey(stat.CancerCode))
                {
                    DrawSingleBox(BoxPlotCanvas, boxX + boxWidth / 2, tumorVals[stat.CancerCode],
                        minY, maxY, marginTop, plotHeight, boxWidth, TumorBrush);
                }

                // Cancer label
                AddText(BoxPlotCanvas, stat.CancerCode, currentX - 15, marginTop + plotHeight + 10, 10, Brushes.Black);

                // P-value annotation
                if (stat.PValue < 0.05)
                {
                    string sig = stat.PValue < 0.001 ? "***" : (stat.PValue < 0.01 ? "**" : "*");
                    AddText(BoxPlotCanvas, sig, currentX - 5, marginTop - 15, 12, Brushes.Red, FontWeights.Bold);
                }

                currentX += groupWidth + cancerSpacing;
            }

            // Y-axis label
            AddRotatedText(BoxPlotCanvas, "Expression (log2)", 15, chartHeight / 2 + 50, -90, 13);

            // Legend
            DrawLegend(BoxPlotCanvas, chartWidth - 95, marginTop + 10, showTumor, showNormal);

            // Title
            var geneName = stats.FirstOrDefault()?.GeneName ?? geneId;
            AddText(BoxPlotCanvas, $"Gene Expression: {geneName}", marginLeft, 15, 16, Brushes.Black, FontWeights.Bold);
        }

        private void DrawSingleBox(Canvas c, double cx, List<double> vals, double minY, double maxY,
            double marginTop, double plotH, double boxW, Brush color)
        {
            if (vals.Count == 0) return;
            var sorted = vals.OrderBy(v => v).ToList();
            int n = sorted.Count;
            double median = n % 2 == 0 ? (sorted[n / 2 - 1] + sorted[n / 2]) / 2 : sorted[n / 2];
            double q1 = sorted[Math.Max(0, (int)(n * 0.25))];
            double q3 = sorted[Math.Min(n - 1, (int)(n * 0.75))];
            double iqr = q3 - q1;
            double wLo = sorted.Where(v => v >= q1 - 1.5 * iqr).DefaultIfEmpty(q1).Min();
            double wHi = sorted.Where(v => v <= q3 + 1.5 * iqr).DefaultIfEmpty(q3).Max();

            Func<double, double> toY = v => marginTop + plotH - (v - minY) / (maxY - minY) * plotH;

            // 固定種子確保每次繪製結果一致 (Deterministic jitter)
            var rnd = new Random(42);
            var dotColor = ((SolidColorBrush)color).Color;

            // 大量樣本時隨機抽樣以維持效能（統計值已用全部數據計算）
            var jitterVals = vals;
            const int maxJitterPoints = 500;
            if (vals.Count > maxJitterPoints)
            {
                var sampleRnd = new Random(vals.Count);
                jitterVals = vals.OrderBy(_ => sampleRnd.Next()).Take(maxJitterPoints).ToList();
            }

            foreach (var v in jitterVals)
            {
                double y = toY(v);
                double jitter = (rnd.NextDouble() - 0.5) * boxW * 0.7;
                var dot = new Ellipse { Width = 4, Height = 4, Fill = new SolidColorBrush(dotColor) { Opacity = 0.4 } };
                Canvas.SetLeft(dot, cx + jitter - 2);
                Canvas.SetTop(dot, y - 2);
                c.Children.Add(dot);
            }

            double yQ1 = toY(q1), yQ3 = toY(q3), yMed = toY(median), yLo = toY(wLo), yHi = toY(wHi);
            AddRect(c, cx - boxW / 2, Math.Min(yQ1, yQ3), boxW, Math.Abs(yQ1 - yQ3), Brushes.Transparent, color, 2);
            AddLine(c, cx - boxW / 2, yMed, cx + boxW / 2, yMed, color, 3);
            AddLine(c, cx, yQ3, cx, yHi, color, 1.5);
            AddLine(c, cx, yQ1, cx, yLo, color, 1.5);
            AddLine(c, cx - boxW / 4, yHi, cx + boxW / 4, yHi, color, 1.5);
            AddLine(c, cx - boxW / 4, yLo, cx + boxW / 4, yLo, color, 1.5);
        }

        private void DrawLegend(Canvas c, double x, double y, bool showT, bool showN)
        {
            int items = (showN ? 1 : 0) + (showT ? 1 : 0);
            AddRect(c, x, y, 80, 20 + items * 20, Brushes.White, Brushes.LightGray);
            int i = 0;
            if (showN) { AddRect(c, x + 8, y + 10 + i * 20, 14, 12, NormalBrush, NormalBrush); AddText(c, "Normal", x + 28, y + 8 + i * 20, 11); i++; }
            if (showT) { AddRect(c, x + 8, y + 10 + i * 20, 14, 12, TumorBrush, TumorBrush); AddText(c, "Tumor", x + 28, y + 8 + i * 20, 11); }
        }

        private void ExportBoxPlotImage_Click(object sender, RoutedEventArgs e) => ExportCanvasToPng(BoxPlotCanvas, "BoxPlot");

        private void ExportBoxPlotCsv_Click(object sender, RoutedEventArgs e)
        {
            if (_currentBoxPlotStats == null || _currentBoxPlotStats.Count == 0) { MessageBox.Show("No data."); return; }
            var dialog = new SaveFileDialog { Filter = "CSV files (*.csv)|*.csv", FileName = $"BoxPlot_Stats_{DateTime.Now:yyyyMMdd_HHmmss}.csv" };
            if (dialog.ShowDialog() == true)
            {
                var sb = new StringBuilder();
                sb.AppendLine("Cancer,Gene,Tumor_N,Tumor_Mean,Tumor_SD,Normal_N,Normal_Mean,Normal_SD,PValue,FDR");
                foreach (var row in _currentBoxPlotStats.OrderBy(s => s.PValue))
                    sb.AppendLine($"{row.CancerCode},{row.GeneName},{row.TumorN},{row.TumorMean:F4},{row.TumorSd:F4},{row.NormalN},{row.NormalMean:F4},{row.NormalSd:F4},{row.PValue:E4},{row.FDR:E4}");
                File.WriteAllText(dialog.FileName, sb.ToString());
                MessageBox.Show($"Exported to:\n{dialog.FileName}");
            }
        }
        #endregion
        #region Correlation Heatmap (Tab 2)
        private async void CalculateCorrelation_Click(object sender, RoutedEventArgs e)
        {
            var genes = CorrelationGenesTextBox.Text.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(g => g.Trim()).Where(g => !string.IsNullOrEmpty(g)).Distinct().ToList();
            if (genes.Count < 2) { MessageBox.Show("Enter at least 2 genes."); return; }

            var project = GetSingleProject("Correlation Heatmap");
            if (project == null) { MessageBox.Show("Select a cancer type."); return; }

            string condition = GetSelectedCondition();

            var btn = sender as Button;
            if (btn != null) btn.IsEnabled = false;
            try
            {
                ShowProgress("Calculating correlations...", 0);
                UpdateProgress(20, $"Loading {project.CancerCode} data...");

                var multiExpr = await _dataService.GetMultiGeneExpressionAsync(project.project_id, genes, condition);
                if (multiExpr == null || multiExpr.GeneNames.Count < 2) { HideProgress(); HeatmapResultText.Text = "Not enough genes found."; return; }

                int n = multiExpr.GeneNames.Count;
                double[,] corrMatrix = new double[n, n];

                UpdateProgress(50, "Computing correlation matrix...");
                for (int i = 0; i < n; i++)
                    for (int j = 0; j < n; j++)
                        corrMatrix[i, j] = i == j ? 1.0 : StatisticsService.PearsonCorrelation(multiExpr.Expressions[i], multiExpr.Expressions[j]).r;

                UpdateProgress(80, "Drawing heatmap...");
                _currentCorrelationMatrix = corrMatrix;
                _currentCorrelationGenes = multiExpr.GeneNames;

                DrawHeatmap(corrMatrix, multiExpr.GeneNames, project.CancerCode);
                HideProgress();
                HeatmapResultText.Text = $"{project.CancerCode} | {n} genes | {multiExpr.Expressions[0].Count} samples | {condition}";
            }
            catch (Exception ex) { HideProgress(); MessageBox.Show($"Error: {ex.Message}"); }
            finally { if (btn != null) btn.IsEnabled = true; }
        }

        private void DrawHeatmap(double[,] matrix, List<string> names, string cancer)
        {
            HeatmapCanvas.Children.Clear();
            int n = names.Count;
            double cellSize = 50;
            double plotSize = Math.Max(400, Math.Min(800, n * cellSize));
            double marginL = 100, marginT = 80, marginR = 80, marginB = 50;
            double chartWidth = plotSize + marginL + marginR;
            double chartHeight = plotSize + marginT + marginB;

            HeatmapCanvas.Width = chartWidth;
            HeatmapCanvas.Height = chartHeight;

            double cell = plotSize / n;
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    double v = matrix[i, j];
                    var rect = new Rectangle { Width = cell - 1, Height = cell - 1, Fill = new SolidColorBrush(HeatColor(v)) };
                    Canvas.SetLeft(rect, marginL + j * cell);
                    Canvas.SetTop(rect, marginT + i * cell);
                    HeatmapCanvas.Children.Add(rect);
                    if (cell > 30) AddText(HeatmapCanvas, v.ToString("F2"), marginL + j * cell + cell / 2 - 12, marginT + i * cell + cell / 2 - 7, Math.Min(cell / 4, 10), Math.Abs(v) > 0.5 ? Brushes.White : Brushes.Black, FontWeights.SemiBold);
                }
            }

            for (int i = 0; i < n; i++)
            {
                AddText(HeatmapCanvas, names[i], marginL + i * cell + 5, marginT - 20, 10, Brushes.Black, FontWeights.Normal);
                AddText(HeatmapCanvas, names[i], 5, marginT + i * cell + cell / 2 - 7, 10, Brushes.Black, FontWeights.Normal);
            }
            AddText(HeatmapCanvas, $"{cancer}: Gene Correlation", marginL, 15, 16, Brushes.Black, FontWeights.Bold);
        }

        private Color HeatColor(double v)
        {
            v = Math.Max(-1, Math.Min(1, v));
            if (v >= 0) return Color.FromRgb((byte)(255 * (1 - v)), (byte)(255 * (1 - v)), 255);
            else return Color.FromRgb(255, (byte)(255 * (1 + v)), (byte)(255 * (1 + v)));
        }

        private void ExportHeatmapImage_Click(object sender, RoutedEventArgs e) => ExportCanvasToPng(HeatmapCanvas, "Heatmap");
        private void ExportHeatmapCsv_Click(object sender, RoutedEventArgs e)
        {
            if (_currentCorrelationMatrix == null) { MessageBox.Show("No data."); return; }
            var dialog = new SaveFileDialog { Filter = "CSV files (*.csv)|*.csv", FileName = $"Correlation_{DateTime.Now:yyyyMMdd_HHmmss}.csv" };
            if (dialog.ShowDialog() == true)
            {
                var sb = new StringBuilder();
                sb.Append("Gene");
                foreach (var g in _currentCorrelationGenes) sb.Append($",{g}");
                sb.AppendLine();
                for (int i = 0; i < _currentCorrelationGenes.Count; i++)
                {
                    sb.Append(_currentCorrelationGenes[i]);
                    for (int j = 0; j < _currentCorrelationGenes.Count; j++) sb.Append($",{_currentCorrelationMatrix[i, j]:F4}");
                    sb.AppendLine();
                }
                File.WriteAllText(dialog.FileName, sb.ToString());
                MessageBox.Show($"Exported to:\n{dialog.FileName}");
            }
        }
        #endregion

        #region Scatter Plot (Tab 3)
        public class ScatterDataPoint
        {
            public double X { get; set; }
            public double Y { get; set; }
            public string Condition { get; set; }
            public string SampleId { get; set; }
            public string CancerCode { get; set; }
        }

        // Multi-cancer scatter 的每個癌症統計
        private class ScatterCancerStats
        {
            public string CancerCode { get; set; }
            public int N { get; set; }
            public double R { get; set; }
            public double R2 { get; set; }
            public double PValue { get; set; }
            public double Slope { get; set; }
            public double Intercept { get; set; }
        }

        private List<ScatterCancerStats> _scatterPerCancerStats;
        private bool _isMultiCancerScatter;

        // 多癌症色票
        private static readonly Color[] CancerPalette = new[]
        {
            Color.FromRgb(231, 76, 60),    // Red
            Color.FromRgb(52, 152, 219),   // Blue
            Color.FromRgb(46, 204, 113),   // Green
            Color.FromRgb(155, 89, 182),   // Purple
            Color.FromRgb(243, 156, 18),   // Orange
            Color.FromRgb(26, 188, 156),   // Teal
            Color.FromRgb(241, 196, 15),   // Yellow
            Color.FromRgb(52, 73, 94),     // Dark Blue
            Color.FromRgb(230, 126, 34),   // Dark Orange
            Color.FromRgb(142, 68, 173),   // Dark Purple
            Color.FromRgb(39, 174, 96),    // Dark Green
            Color.FromRgb(192, 57, 43),    // Dark Red
            Color.FromRgb(41, 128, 185),   // Steel Blue
            Color.FromRgb(22, 160, 133),   // Dark Teal
            Color.FromRgb(211, 84, 0),     // Burnt Orange
            Color.FromRgb(127, 140, 141),  // Gray
        };

        private void CopyScatterStats_Click(object sender, RoutedEventArgs e)
        {
            if (string.IsNullOrEmpty(_currentGeneX)) { MessageBox.Show("No data."); return; }

            var sb = new StringBuilder();
            if (_isMultiCancerScatter && _scatterPerCancerStats != null)
            {
                sb.AppendLine($"Gene X\t{_currentGeneX}");
                sb.AppendLine($"Gene Y\t{_currentGeneY}");
                sb.AppendLine();
                sb.AppendLine("Cancer\tN\tR\tR²\tP-value\tSlope\tIntercept");
                foreach (var cs in _scatterPerCancerStats.OrderBy(s => s.PValue))
                    sb.AppendLine($"{cs.CancerCode}\t{cs.N}\t{cs.R:F4}\t{cs.R2:F4}\t{cs.PValue:E2}\t{cs.Slope:F4}\t{cs.Intercept:F4}");
                sb.AppendLine();
                sb.AppendLine($"All\t{_scatterN}\t{_scatterR:F4}\t{_scatterR2:F4}\t{_scatterPValue:E2}\t{_scatterSlope:F4}\t{_scatterIntercept:F4}");
            }
            else
            {
                sb.Append($"Cancer\t{_currentCancer}\nGene X\t{_currentGeneX}\nGene Y\t{_currentGeneY}\nN\t{_scatterN}\nPearson R\t{_scatterR:F4}\nR²\t{_scatterR2:F4}\nP-value\t{_scatterPValue:E2}\nSlope\t{_scatterSlope:F4}\nIntercept\t{_scatterIntercept:F4}");
            }

            Clipboard.SetText(sb.ToString());
            MessageBox.Show("Copied!");
        }

        private void CopyScatterR2_Click(object sender, RoutedEventArgs e) { Clipboard.SetText($"{_scatterR2:F4}"); MessageBox.Show($"R² = {_scatterR2:F4} copied!"); }
        private void CopyScatterEquation_Click(object sender, RoutedEventArgs e) { Clipboard.SetText($"Y = {_scatterSlope:F4}X + {_scatterIntercept:F4}"); MessageBox.Show("Equation copied!"); }

        private async void PlotScatter_Click(object sender, RoutedEventArgs e)
        {
            var geneX = ScatterGeneXTextBox.Text.Trim();
            var geneY = ScatterGeneYTextBox.Text.Trim();
            if (string.IsNullOrEmpty(geneX) || string.IsNullOrEmpty(geneY)) { MessageBox.Show("Enter both genes."); return; }

            var projects = GetSelectedProjects();
            if (projects.Count == 0) { MessageBox.Show("Select a cancer type."); return; }

            string condition = GetSelectedCondition();
            _isMultiCancerScatter = projects.Count > 1;

            var btn = sender as Button;
            if (btn != null) btn.IsEnabled = false;
            try
            {
                ShowProgress("Creating scatter plot...", 0);

                var allPoints = new List<ScatterDataPoint>();
                var perCancerStats = new List<ScatterCancerStats>();
                string resolvedGeneX = geneX, resolvedGeneY = geneY;
                int processed = 0;

                foreach (var project in projects)
                {
                    processed++;
                    UpdateProgress(processed * 70 / projects.Count, $"Loading {project.CancerCode}...");

                    var twoGene = await _dataService.GetTwoGeneExpressionAsync(project.project_id, geneX, geneY);
                    if (twoGene == null) continue;

                    resolvedGeneX = twoGene.Gene1Name ?? geneX;
                    resolvedGeneY = twoGene.Gene2Name ?? geneY;

                    bool showT = condition != "Normal", showN = condition != "Tumor";
                    var cancerPoints = new List<ScatterDataPoint>();

                    if (showT)
                        foreach (var p in twoGene.TumorPairs)
                            cancerPoints.Add(new ScatterDataPoint { X = p.X, Y = p.Y, Condition = "Tumor", SampleId = p.SampleId, CancerCode = project.CancerCode });
                    if (showN)
                        foreach (var p in twoGene.NormalPairs)
                            cancerPoints.Add(new ScatterDataPoint { X = p.X, Y = p.Y, Condition = "Normal", SampleId = p.SampleId, CancerCode = project.CancerCode });

                    if (cancerPoints.Count >= 3)
                    {
                        var xs = cancerPoints.Select(p => p.X).ToList();
                        var ys = cancerPoints.Select(p => p.Y).ToList();
                        var (r, pval, n) = StatisticsService.PearsonCorrelation(xs, ys);
                        var (slope, intercept, r2) = StatisticsService.LinearRegression(xs, ys);

                        perCancerStats.Add(new ScatterCancerStats
                        {
                            CancerCode = project.CancerCode,
                            N = n,
                            R = r,
                            R2 = r2,
                            PValue = pval,
                            Slope = slope,
                            Intercept = intercept
                        });
                    }

                    allPoints.AddRange(cancerPoints);
                }

                if (allPoints.Count == 0) { HideProgress(); ScatterResultText.Text = "No data found."; return; }

                UpdateProgress(80, "Drawing plot...");
                _currentScatterPoints = allPoints;
                _currentGeneX = resolvedGeneX;
                _currentGeneY = resolvedGeneY;
                _scatterPerCancerStats = perCancerStats;

                // 全域統計（所有點合併）
                var allXs = allPoints.Select(p => p.X).ToList();
                var allYs = allPoints.Select(p => p.Y).ToList();
                var (globalR, globalPval, globalN) = StatisticsService.PearsonCorrelation(allXs, allYs);
                var (globalSlope, globalIntercept, globalR2) = StatisticsService.LinearRegression(allXs, allYs);

                _scatterR = globalR; _scatterR2 = globalR2; _scatterPValue = globalPval;
                _scatterSlope = globalSlope; _scatterIntercept = globalIntercept; _scatterN = globalN;

                if (_isMultiCancerScatter)
                {
                    _currentCancer = string.Join(", ", perCancerStats.Select(s => s.CancerCode));
                    DrawMultiCancerScatter(allPoints, perCancerStats, resolvedGeneX, resolvedGeneY, globalSlope, globalIntercept);
                }
                else
                {
                    _currentCancer = projects.First().CancerCode;
                    bool showT2 = condition != "Normal", showN2 = condition != "Tumor";
                    DrawScatter(allPoints, resolvedGeneX, resolvedGeneY, globalSlope, globalIntercept, _currentCancer, showT2, showN2);
                }

                HideProgress();

                // 組裝統計文字
                var statsSb = new StringBuilder();
                if (_isMultiCancerScatter)
                {
                    statsSb.AppendLine($"Gene X: {_currentGeneX}    Gene Y: {_currentGeneY}");
                    statsSb.AppendLine($"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
                    statsSb.AppendLine($"{"Cancer",-8} {"N",6} {"R",8} {"R²",8} {"P-value",12} {"Regression",20}");
                    statsSb.AppendLine($"{"─────",-8} {"───",6} {"──",8} {"──",8} {"───────",12} {"──────────",20}");
                    foreach (var cs in perCancerStats.OrderBy(s => s.PValue))
                        statsSb.AppendLine($"{cs.CancerCode,-8} {cs.N,6} {cs.R,8:F4} {cs.R2,8:F4} {cs.PValue,12:E2} Y={cs.Slope:F3}X+{cs.Intercept:F3}");
                    statsSb.AppendLine($"{"─────",-8} {"───",6} {"──",8} {"──",8} {"───────",12} {"──────────",20}");
                    statsSb.AppendLine($"{"All",-8} {globalN,6} {globalR,8:F4} {globalR2,8:F4} {globalPval,12:E2} Y={globalSlope:F3}X+{globalIntercept:F3}");
                }
                else
                {
                    statsSb.AppendLine($"Cancer: {_currentCancer}");
                    statsSb.AppendLine($"Gene X: {_currentGeneX}    Gene Y: {_currentGeneY}");
                    statsSb.AppendLine($"━━━━━━━━━━━━━━━━━━━━");
                    statsSb.AppendLine($"N = {globalN}");
                    statsSb.AppendLine($"Pearson R = {globalR:F4}");
                    statsSb.AppendLine($"R² = {globalR2:F4}");
                    statsSb.AppendLine($"P-value = {globalPval:E2}");
                    statsSb.AppendLine($"━━━━━━━━━━━━━━━━━━━━");
                    statsSb.AppendLine($"Regression: Y = {globalSlope:F4}X + {globalIntercept:F4}");
                }
                ScatterResultText.Text = statsSb.ToString();
            }
            catch (Exception ex) { HideProgress(); MessageBox.Show($"Error: {ex.Message}"); }
            finally { if (btn != null) btn.IsEnabled = true; }
        }

        private void DrawScatter(List<ScatterDataPoint> pts, string gX, string gY, double slope, double intercept, string cancer, bool showT, bool showN)
        {
            ScatterPlotCanvas.Children.Clear();
            double chartWidth = Math.Max(600, Math.Min(900, 500 + pts.Count * 0.5));
            double chartHeight = chartWidth * 0.85;
            ScatterPlotCanvas.Width = chartWidth;
            ScatterPlotCanvas.Height = chartHeight;

            double marginL = 70, marginR = 100, marginT = 50, marginB = 70;
            double plotW = chartWidth - marginL - marginR;
            double plotH = chartHeight - marginT - marginB;

            double minX = pts.Min(p => p.X), maxX = pts.Max(p => p.X);
            double minY = pts.Min(p => p.Y), maxY = pts.Max(p => p.Y);
            double padX = (maxX - minX) * 0.1, padY = (maxY - minY) * 0.1;
            minX -= padX; maxX += padX; minY -= padY; maxY += padY;

            AddRect(ScatterPlotCanvas, marginL, marginT, plotW, plotH, Brushes.White, Brushes.LightGray);

            for (int i = 0; i <= 5; i++)
            {
                double xv = minX + (maxX - minX) * i / 5;
                double x = marginL + (xv - minX) / (maxX - minX) * plotW;
                AddLine(ScatterPlotCanvas, x, marginT, x, marginT + plotH, Brushes.LightGray, 0.5, true);
                AddText(ScatterPlotCanvas, xv.ToString("F1"), x - 12, marginT + plotH + 8, 9, Brushes.Gray);

                double yv = minY + (maxY - minY) * i / 5;
                double y = marginT + plotH - (yv - minY) / (maxY - minY) * plotH;
                AddLine(ScatterPlotCanvas, marginL, y, marginL + plotW, y, Brushes.LightGray, 0.5, true);
                AddText(ScatterPlotCanvas, yv.ToString("F1"), marginL - 40, y - 8, 9, Brushes.Gray);
            }

            double ly1 = slope * minX + intercept, ly2 = slope * maxX + intercept;
            double sy1 = marginT + plotH - (ly1 - minY) / (maxY - minY) * plotH;
            double sy2 = marginT + plotH - (ly2 - minY) / (maxY - minY) * plotH;
            AddLine(ScatterPlotCanvas, marginL, sy1, marginL + plotW, sy2, Brushes.Red, 2, true);

            // 大量樣本時隨機抽樣以維持效能（統計值已用全部數據計算）
            const int maxScatterPoints = 2000;
            var displayPts = pts;
            if (pts.Count > maxScatterPoints)
            {
                var sampleRnd = new Random(pts.Count);
                displayPts = pts.OrderBy(_ => sampleRnd.Next()).Take(maxScatterPoints).ToList();
            }

            foreach (var pt in displayPts)
            {
                double x = marginL + (pt.X - minX) / (maxX - minX) * plotW;
                double y = marginT + plotH - (pt.Y - minY) / (maxY - minY) * plotH;
                var color = pt.Condition == "Normal" ? Color.FromArgb(180, NormalColor.R, NormalColor.G, NormalColor.B) : Color.FromArgb(180, TumorColor.R, TumorColor.G, TumorColor.B);
                var dot = new Ellipse { Width = 8, Height = 8, Fill = new SolidColorBrush(color) };
                Canvas.SetLeft(dot, x - 4); Canvas.SetTop(dot, y - 4);
                ScatterPlotCanvas.Children.Add(dot);
            }

            // 大量樣本時顯示抽樣提示
            if (pts.Count > displayPts.Count)
            {
                AddText(ScatterPlotCanvas, $"(Showing {displayPts.Count}/{pts.Count} points)", marginL, chartHeight - 45, 9, Brushes.Gray);
            }

            AddText(ScatterPlotCanvas, $"{gX} (log2)", marginL + plotW / 2 - 40, chartHeight - 25, 13, Brushes.Black, FontWeights.SemiBold);
            AddRotatedText(ScatterPlotCanvas, $"{gY} (log2)", 15, chartHeight / 2 + 40, -90, 13);
            AddText(ScatterPlotCanvas, $"{cancer}: {gX} vs {gY}", marginL, 15, 16, Brushes.Black, FontWeights.Bold);

            int items = (showN ? 1 : 0) + (showT ? 1 : 0);
            AddRect(ScatterPlotCanvas, chartWidth - 95, marginT + 10, 85, 15 + items * 20, Brushes.White, Brushes.LightGray);
            int li = 0;
            if (showN) { AddEllipse(ScatterPlotCanvas, chartWidth - 85, marginT + 18 + li * 20, 10, NormalBrush); AddText(ScatterPlotCanvas, "Normal", chartWidth - 70, marginT + 15 + li * 20, 11); li++; }
            if (showT) { AddEllipse(ScatterPlotCanvas, chartWidth - 85, marginT + 18 + li * 20, 10, TumorBrush); AddText(ScatterPlotCanvas, "Tumor", chartWidth - 70, marginT + 15 + li * 20, 11); }
        }

        private void DrawMultiCancerScatter(List<ScatterDataPoint> pts, List<ScatterCancerStats> perCancerStats,
            string gX, string gY, double globalSlope, double globalIntercept)
        {
            ScatterPlotCanvas.Children.Clear();

            double chartWidth = Math.Max(700, Math.Min(1000, 500 + pts.Count * 0.3));
            double chartHeight = chartWidth * 0.85;
            ScatterPlotCanvas.Width = chartWidth;
            ScatterPlotCanvas.Height = chartHeight;

            double marginL = 70, marginR = 160, marginT = 50, marginB = 70;
            double plotW = chartWidth - marginL - marginR;
            double plotH = chartHeight - marginT - marginB;

            double minX = pts.Min(p => p.X), maxX = pts.Max(p => p.X);
            double minY = pts.Min(p => p.Y), maxY = pts.Max(p => p.Y);
            double padX = (maxX - minX) * 0.1, padY = (maxY - minY) * 0.1;
            minX -= padX; maxX += padX; minY -= padY; maxY += padY;

            // Background & grid
            AddRect(ScatterPlotCanvas, marginL, marginT, plotW, plotH, Brushes.White, Brushes.LightGray);
            for (int i = 0; i <= 5; i++)
            {
                double xv = minX + (maxX - minX) * i / 5;
                double x = marginL + (xv - minX) / (maxX - minX) * plotW;
                AddLine(ScatterPlotCanvas, x, marginT, x, marginT + plotH, Brushes.LightGray, 0.5, true);
                AddText(ScatterPlotCanvas, xv.ToString("F1"), x - 12, marginT + plotH + 8, 9, Brushes.Gray);

                double yv = minY + (maxY - minY) * i / 5;
                double y = marginT + plotH - (yv - minY) / (maxY - minY) * plotH;
                AddLine(ScatterPlotCanvas, marginL, y, marginL + plotW, y, Brushes.LightGray, 0.5, true);
                AddText(ScatterPlotCanvas, yv.ToString("F1"), marginL - 40, y - 8, 9, Brushes.Gray);
            }

            // 全域回歸線 (灰虛線)
            double ly1 = globalSlope * minX + globalIntercept, ly2 = globalSlope * maxX + globalIntercept;
            double sy1 = marginT + plotH - (ly1 - minY) / (maxY - minY) * plotH;
            double sy2 = marginT + plotH - (ly2 - minY) / (maxY - minY) * plotH;
            AddLine(ScatterPlotCanvas, marginL, sy1, marginL + plotW, sy2, Brushes.Gray, 1.5, true);

            // 建立癌症→顏色映射
            var cancerCodes = perCancerStats.Select(s => s.CancerCode).ToList();
            var cancerColorMap = new Dictionary<string, Color>();
            for (int i = 0; i < cancerCodes.Count; i++)
                cancerColorMap[cancerCodes[i]] = CancerPalette[i % CancerPalette.Length];

            // 抽樣
            const int maxScatterPoints = 3000;
            var displayPts = pts;
            if (pts.Count > maxScatterPoints)
            {
                var sampleRnd = new Random(pts.Count);
                displayPts = pts.OrderBy(_ => sampleRnd.Next()).Take(maxScatterPoints).ToList();
            }

            // 畫點
            foreach (var pt in displayPts)
            {
                double x = marginL + (pt.X - minX) / (maxX - minX) * plotW;
                double y = marginT + plotH - (pt.Y - minY) / (maxY - minY) * plotH;

                Color baseColor = cancerColorMap.ContainsKey(pt.CancerCode) ? cancerColorMap[pt.CancerCode] : Color.FromRgb(128, 128, 128);
                var color = Color.FromArgb(160, baseColor.R, baseColor.G, baseColor.B);
                var dot = new Ellipse { Width = 7, Height = 7, Fill = new SolidColorBrush(color) };
                Canvas.SetLeft(dot, x - 3.5); Canvas.SetTop(dot, y - 3.5);
                ScatterPlotCanvas.Children.Add(dot);
            }

            if (pts.Count > displayPts.Count)
                AddText(ScatterPlotCanvas, $"(Showing {displayPts.Count}/{pts.Count} points)", marginL, chartHeight - 45, 9, Brushes.Gray);

            // 每個癌症的回歸線 (對應顏色，細實線)
            foreach (var cs in perCancerStats)
            {
                var c = cancerColorMap[cs.CancerCode];
                double rl1 = cs.Slope * minX + cs.Intercept, rl2 = cs.Slope * maxX + cs.Intercept;
                double rs1 = marginT + plotH - (rl1 - minY) / (maxY - minY) * plotH;
                double rs2 = marginT + plotH - (rl2 - minY) / (maxY - minY) * plotH;
                AddLine(ScatterPlotCanvas, marginL, rs1, marginL + plotW, rs2, new SolidColorBrush(c), 1.5);
            }

            // 軸標題
            AddText(ScatterPlotCanvas, $"{gX} (log2)", marginL + plotW / 2 - 40, chartHeight - 25, 13, Brushes.Black, FontWeights.SemiBold);
            AddRotatedText(ScatterPlotCanvas, $"{gY} (log2)", 15, chartHeight / 2 + 40, -90, 13);
            AddText(ScatterPlotCanvas, $"Multi-Cancer: {gX} vs {gY}", marginL, 15, 16, Brushes.Black, FontWeights.Bold);

            // 圖例
            double legX = chartWidth - 150, legY = marginT + 10;
            int legItems = cancerCodes.Count;
            AddRect(ScatterPlotCanvas, legX, legY, 140, 15 + legItems * 18, Brushes.White, Brushes.LightGray);
            for (int i = 0; i < cancerCodes.Count; i++)
            {
                var c = cancerColorMap[cancerCodes[i]];
                var cs = perCancerStats[i];
                AddEllipse(ScatterPlotCanvas, legX + 10, legY + 10 + i * 18, 8, new SolidColorBrush(c));
                AddText(ScatterPlotCanvas, $"{cancerCodes[i]} (R={cs.R:F2})", legX + 24, legY + 6 + i * 18, 10);
            }
        }

        private void ExportScatterImage_Click(object sender, RoutedEventArgs e) => ExportCanvasToPng(ScatterPlotCanvas, "ScatterPlot");
        private void ExportScatterCsv_Click(object sender, RoutedEventArgs e)
        {
            if (_currentScatterPoints == null || _currentScatterPoints.Count == 0) { MessageBox.Show("No data."); return; }
            var dialog = new SaveFileDialog { Filter = "CSV files (*.csv)|*.csv", FileName = $"Scatter_{_currentGeneX}_vs_{_currentGeneY}_{DateTime.Now:yyyyMMdd_HHmmss}.csv" };
            if (dialog.ShowDialog() == true)
            {
                var sb = new StringBuilder();
                sb.AppendLine($"SampleID,Cancer,{_currentGeneX},{_currentGeneY},Condition");
                foreach (var pt in _currentScatterPoints) sb.AppendLine($"{pt.SampleId},{pt.CancerCode},{pt.X:F4},{pt.Y:F4},{pt.Condition}");
                File.WriteAllText(dialog.FileName, sb.ToString());
                MessageBox.Show($"Exported to:\n{dialog.FileName}");
            }
        }
        #endregion

        #region Kaplan-Meier Survival Analysis (Tab 4) - NEW

        private async void LoadSurvivalData_Click(object sender, RoutedEventArgs e)
        {
            var geneId = KMGeneIdTextBox.Text.Trim();
            if (string.IsNullOrEmpty(geneId)) { MessageBox.Show("Please enter a gene ID."); return; }

            var project = GetSingleProject("Kaplan-Meier Survival");
            if (project == null) { MessageBox.Show("Please select a cancer type."); return; }

            var btn = sender as Button;
            if (btn != null) btn.IsEnabled = false;
            try
            {
                ShowProgress("Loading survival data...", 0);
                UpdateProgress(30, "Checking survival data availability...");

                bool hasSurvival = await _dataService.HasSurvivalDataAsync(project.project_id);
                if (!hasSurvival)
                {
                    HideProgress();
                    MessageBox.Show($"No survival data available for {project.CancerCode}.\nPlease regenerate the TCGA data with survival information.",
                        "No Survival Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                UpdateProgress(50, $"Loading {project.CancerCode} survival data...");
                var survivalData = await _dataService.GetGeneSurvivalDataAsync(project.project_id, geneId);

                if (survivalData == null || survivalData.TotalSamples < 10)
                {
                    HideProgress();
                    MessageBox.Show($"Insufficient survival data for gene '{geneId}' in {project.CancerCode}.",
                        "Insufficient Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                _currentSurvivalData = survivalData;
                _currentKMGene = survivalData.GeneName;
                _currentKMCancer = project.CancerCode;

                UpdateProgress(80, "Generating Kaplan-Meier plot...");

                // Draw with current slider value
                double percentile = KMPercentileSlider.Value;
                UpdateKaplanMeierPlot(percentile);

                HideProgress();
            }
            catch (Exception ex)
            {
                HideProgress();
                MessageBox.Show($"Error: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                if (btn != null) btn.IsEnabled = true;
            }
        }

        // REAL-TIME slider update
        private void KMPercentileSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (KMPercentileText == null) return;

            double percentile = e.NewValue;
            KMPercentileText.Text = $"{percentile:F0}%";
            KMHighPercentText.Text = $"{100 - percentile:F0}%";
            KMLowPercentText.Text = $"{percentile:F0}%";

            // If we have data loaded, update the plot in real-time
            if (_currentSurvivalData != null && _currentSurvivalData.TotalSamples > 0)
            {
                UpdateKaplanMeierPlot(percentile);
            }
        }

        private void UpdateKaplanMeierPlot(double percentile)
        {
            if (_currentSurvivalData == null) return;

            // Sort samples by expression
            var sorted = _currentSurvivalData.Samples.OrderBy(s => s.Expression).ToList();
            int n = sorted.Count;
            int cutoffIndex = (int)Math.Round(n * percentile / 100.0);
            cutoffIndex = Math.Max(1, Math.Min(n - 1, cutoffIndex));

            double cutoffValue = sorted[cutoffIndex].Expression;

            // Split into low and high expression groups
            var lowGroup = sorted.Take(cutoffIndex).Select(s => (s.SurvivalDays, s.IsEvent)).ToList();
            var highGroup = sorted.Skip(cutoffIndex).Select(s => (s.SurvivalDays, s.IsEvent)).ToList();

            // Calculate Kaplan-Meier curves
            var lowCurve = KaplanMeierService.CalculateSurvivalCurve(lowGroup);
            var highCurve = KaplanMeierService.CalculateSurvivalCurve(highGroup);

            // Calculate statistics
            var lowMedian = KaplanMeierService.CalculateMedianSurvival(lowCurve);
            var highMedian = KaplanMeierService.CalculateMedianSurvival(highCurve);
            var lowMean = KaplanMeierService.CalculateMeanSurvival(lowCurve);
            var highMean = KaplanMeierService.CalculateMeanSurvival(highCurve);

            // Log-Rank test
            var (chiSq, pValue) = KaplanMeierService.LogRankTest(lowGroup, highGroup);

            // Store result
            _currentKMResult = new KMComparisonResult
            {
                LowExpression = new KMAnalysisResult
                {
                    GroupName = "Low Expression",
                    Curve = lowCurve,
                    TotalSamples = lowGroup.Count,
                    Events = lowGroup.Count(s => s.IsEvent),
                    Censored = lowGroup.Count(s => !s.IsEvent),
                    MedianSurvival = lowMedian,
                    MeanSurvival = lowMean
                },
                HighExpression = new KMAnalysisResult
                {
                    GroupName = "High Expression",
                    Curve = highCurve,
                    TotalSamples = highGroup.Count,
                    Events = highGroup.Count(s => s.IsEvent),
                    Censored = highGroup.Count(s => !s.IsEvent),
                    MedianSurvival = highMedian,
                    MeanSurvival = highMean
                },
                LogRankChiSquare = chiSq,
                LogRankPValue = pValue,
                CutoffPercentile = percentile,
                CutoffValue = cutoffValue
            };

            // Draw the plot
            DrawKaplanMeierPlot(_currentKMResult);

            // Update statistics text
            KMHighGroupStats.Text = $"N = {_currentKMResult.HighExpression.TotalSamples}\n" +
                                    $"Events = {_currentKMResult.HighExpression.Events}\n" +
                                    $"Censored = {_currentKMResult.HighExpression.Censored}\n" +
                                    $"Median: {(_currentKMResult.HighExpression.MedianSurvivalMonths?.ToString("F1") ?? "N/A")} months\n" +
                                    $"Mean: {_currentKMResult.HighExpression.MeanSurvivalMonths:F1} months";

            KMLowGroupStats.Text = $"N = {_currentKMResult.LowExpression.TotalSamples}\n" +
                                   $"Events = {_currentKMResult.LowExpression.Events}\n" +
                                   $"Censored = {_currentKMResult.LowExpression.Censored}\n" +
                                   $"Median: {(_currentKMResult.LowExpression.MedianSurvivalMonths?.ToString("F1") ?? "N/A")} months\n" +
                                   $"Mean: {_currentKMResult.LowExpression.MeanSurvivalMonths:F1} months";

            // Log-Rank test result
            string sigText = pValue < 0.05 ? "✅ Significant" : "⚪ Not Significant";
            KMLogRankText.Text = $"Log-Rank Test:  χ² = {chiSq:F3}  |  P-value = {_currentKMResult.PValueDisplay}  |  {sigText}";
            KMLogRankText.Foreground = pValue < 0.05 ? Brushes.Green : Brushes.Gray;
        }

        private void DrawKaplanMeierPlot(KMComparisonResult result)
        {
            KMPlotCanvas.Children.Clear();

            double chartWidth = 800, chartHeight = 500;
            double marginL = 70, marginR = 150, marginT = 50, marginB = 70;
            double plotW = chartWidth - marginL - marginR;
            double plotH = chartHeight - marginT - marginB;

            // Find max time
            int maxTime = Math.Max(
                result.HighExpression.Curve.Max(p => p.Time),
                result.LowExpression.Curve.Max(p => p.Time));
            maxTime = (int)(Math.Ceiling(maxTime / 365.0) * 365); // Round to years

            // Background
            AddRect(KMPlotCanvas, marginL, marginT, plotW, plotH, Brushes.White, Brushes.LightGray);

            // Grid lines
            for (int i = 0; i <= 5; i++)
            {
                double y = marginT + plotH - plotH * i / 5;
                AddLine(KMPlotCanvas, marginL, y, marginL + plotW, y, Brushes.LightGray, 0.5, true);
                AddText(KMPlotCanvas, $"{i * 20}%", marginL - 40, y - 8, 10, Brushes.Gray);
            }

            int yearMax = maxTime / 365;
            for (int yr = 0; yr <= yearMax; yr++)
            {
                double x = marginL + plotW * yr / yearMax;
                AddLine(KMPlotCanvas, x, marginT, x, marginT + plotH, Brushes.LightGray, 0.5, true);
                AddText(KMPlotCanvas, $"{yr}", x - 5, marginT + plotH + 10, 10, Brushes.Gray);
            }

            // Draw curves (step function)
            DrawKMCurve(KMPlotCanvas, result.HighExpression.Curve, maxTime, marginL, marginT, plotW, plotH, HighExprBrush, true);
            DrawKMCurve(KMPlotCanvas, result.LowExpression.Curve, maxTime, marginL, marginT, plotW, plotH, LowExprBrush, true);

            // Axis labels
            AddText(KMPlotCanvas, "Time (years)", marginL + plotW / 2 - 40, chartHeight - 25, 13, Brushes.Black, FontWeights.SemiBold);
            AddRotatedText(KMPlotCanvas, "Survival Probability", 15, chartHeight / 2 + 60, -90, 13);

            // Title
            AddText(KMPlotCanvas, $"{_currentKMCancer}: {_currentKMGene} Survival Analysis", marginL, 15, 16, Brushes.Black, FontWeights.Bold);

            // Legend
            double legX = chartWidth - 140, legY = marginT + 10;
            AddRect(KMPlotCanvas, legX, legY, 130, 80, Brushes.White, Brushes.LightGray);
            AddRect(KMPlotCanvas, legX + 10, legY + 15, 20, 3, HighExprBrush, HighExprBrush);
            AddText(KMPlotCanvas, $"High (n={result.HighExpression.TotalSamples})", legX + 35, legY + 10, 10, Brushes.Black);
            AddRect(KMPlotCanvas, legX + 10, legY + 40, 20, 3, LowExprBrush, LowExprBrush);
            AddText(KMPlotCanvas, $"Low (n={result.LowExpression.TotalSamples})", legX + 35, legY + 35, 10, Brushes.Black);
            AddText(KMPlotCanvas, $"p = {result.PValueDisplay}", legX + 10, legY + 58, 10, result.IsSignificant ? Brushes.Green : Brushes.Gray, FontWeights.Bold);
        }

        private void DrawKMCurve(Canvas c, List<KMPoint> curve, int maxTime, double marginL, double marginT, double plotW, double plotH, Brush color, bool showCensored)
        {
            if (curve.Count < 2) return;

            for (int i = 1; i < curve.Count; i++)
            {
                double x1 = marginL + plotW * curve[i - 1].Time / maxTime;
                double x2 = marginL + plotW * curve[i].Time / maxTime;
                double y1 = marginT + plotH - plotH * curve[i - 1].Survival;
                double y2 = marginT + plotH - plotH * curve[i].Survival;

                // Horizontal line (step)
                AddLine(c, x1, y1, x2, y1, color, 2.5);
                // Vertical line (drop)
                if (Math.Abs(y1 - y2) > 0.5)
                    AddLine(c, x2, y1, x2, y2, color, 2.5);

                // Censored mark (tick mark)
                if (showCensored && curve[i].Censored > 0)
                {
                    AddLine(c, x2, y2 - 5, x2, y2 + 5, color, 1.5);
                }
            }
        }

        private void CopyKMStats_Click(object sender, RoutedEventArgs e)
        {
            if (_currentKMResult == null) { MessageBox.Show("No data."); return; }

            var sb = new StringBuilder();
            sb.AppendLine($"Gene\t{_currentKMGene}");
            sb.AppendLine($"Cancer\t{_currentKMCancer}");
            sb.AppendLine($"Cutoff Percentile\t{_currentKMResult.CutoffPercentile:F0}%");
            sb.AppendLine($"Cutoff Value\t{_currentKMResult.CutoffValue:F3}");
            sb.AppendLine();
            sb.AppendLine($"High Expression Group");
            sb.AppendLine($"  N\t{_currentKMResult.HighExpression.TotalSamples}");
            sb.AppendLine($"  Events\t{_currentKMResult.HighExpression.Events}");
            sb.AppendLine($"  Median Survival (months)\t{_currentKMResult.HighExpression.MedianSurvivalMonths?.ToString("F1") ?? "N/A"}");
            sb.AppendLine($"  Mean Survival (months)\t{_currentKMResult.HighExpression.MeanSurvivalMonths:F1}");
            sb.AppendLine();
            sb.AppendLine($"Low Expression Group");
            sb.AppendLine($"  N\t{_currentKMResult.LowExpression.TotalSamples}");
            sb.AppendLine($"  Events\t{_currentKMResult.LowExpression.Events}");
            sb.AppendLine($"  Median Survival (months)\t{_currentKMResult.LowExpression.MedianSurvivalMonths?.ToString("F1") ?? "N/A"}");
            sb.AppendLine($"  Mean Survival (months)\t{_currentKMResult.LowExpression.MeanSurvivalMonths:F1}");
            sb.AppendLine();
            sb.AppendLine($"Log-Rank Test");
            sb.AppendLine($"  Chi-Square\t{_currentKMResult.LogRankChiSquare:F3}");
            sb.AppendLine($"  P-value\t{_currentKMResult.PValueDisplay}");

            Clipboard.SetText(sb.ToString());
            MessageBox.Show("Statistics copied!");
        }

        private void ExportKMImage_Click(object sender, RoutedEventArgs e) => ExportCanvasToPng(KMPlotCanvas, "KaplanMeier");

        private void ExportKMCsv_Click(object sender, RoutedEventArgs e)
        {
            if (_currentKMResult == null) { MessageBox.Show("No data."); return; }

            var dialog = new SaveFileDialog { Filter = "CSV files (*.csv)|*.csv", FileName = $"KM_{_currentKMCancer}_{_currentKMGene}_{DateTime.Now:yyyyMMdd_HHmmss}.csv" };
            if (dialog.ShowDialog() == true)
            {
                var sb = new StringBuilder();
                sb.AppendLine("Group,Time_Days,Time_Months,Survival_Probability,At_Risk,Events,Censored");

                foreach (var pt in _currentKMResult.HighExpression.Curve)
                    sb.AppendLine($"High,{pt.Time},{pt.TimeMonths:F1},{pt.Survival:F4},{pt.AtRisk},{pt.Events},{pt.Censored}");

                foreach (var pt in _currentKMResult.LowExpression.Curve)
                    sb.AppendLine($"Low,{pt.Time},{pt.TimeMonths:F1},{pt.Survival:F4},{pt.AtRisk},{pt.Events},{pt.Censored}");

                File.WriteAllText(dialog.FileName, sb.ToString());
                MessageBox.Show($"Exported to:\n{dialog.FileName}");
            }
        }
        #endregion

        #region Volcano Plot (Tab 5) - NEW

        private List<VolcanoPointViewModel> _volcanoDisplayList;
        private List<VolcanoPointViewModel> _volcanoFullList;

        /// <summary>
        /// Volcano Point 的 ViewModel，新增 IsHighlighted 屬性
        /// </summary>
        public class VolcanoPointViewModel : System.ComponentModel.INotifyPropertyChanged
        {
            private bool _isHighlighted;

            public string GeneId { get; set; }
            public string GeneName { get; set; }
            public double Log2FoldChange { get; set; }
            public double PValue { get; set; }
            public double NegLog10PValue { get; set; }
            public double FDR { get; set; }
            public double TumorMean { get; set; }
            public double NormalMean { get; set; }

            public bool IsHighlighted
            {
                get => _isHighlighted;
                set
                {
                    if (_isHighlighted != value)
                    {
                        _isHighlighted = value;
                        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(IsHighlighted)));
                    }
                }
            }

            public string PValueDisplay => PValue < 0.001 ? $"{PValue:E2}" : $"{PValue:F4}";
            public string FDRDisplay => FDR < 0.001 ? $"{FDR:E2}" : $"{FDR:F4}";

            public bool IsSignificant(double fdrThreshold = 0.05, double fcThreshold = 1.0)
                => FDR < fdrThreshold && Math.Abs(Log2FoldChange) > fcThreshold;

            public string Regulation
            {
                get
                {
                    if (!IsSignificant()) return "NS";
                    return Log2FoldChange > 0 ? "Up" : "Down";
                }
            }

            public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

            // 從 VolcanoPoint 轉換
            public static VolcanoPointViewModel FromVolcanoPoint(VolcanoPoint p)
            {
                return new VolcanoPointViewModel
                {
                    GeneId = p.GeneId,
                    GeneName = p.GeneName,
                    Log2FoldChange = p.Log2FoldChange,
                    PValue = p.PValue,
                    NegLog10PValue = p.NegLog10PValue,
                    FDR = p.FDR,
                    TumorMean = p.TumorMean,
                    NormalMean = p.NormalMean,
                    IsHighlighted = false
                };
            }
        }

        private async void GenerateVolcano_Click(object sender, RoutedEventArgs e)
        {
            var project = GetSingleProject("Volcano Plot");
            if (project == null) { MessageBox.Show("Please select a cancer type."); return; }

            if (project.n_tumor < 3 || project.n_normal < 3)
            {
                MessageBox.Show($"{project.CancerCode} doesn't have enough Tumor/Normal samples for comparison.\n(Need at least 3 each)",
                    "Insufficient Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var btn = sender as Button;
            if (btn != null) btn.IsEnabled = false;
            try
            {
                ShowProgress("Generating Volcano Plot...", 0);
                UpdateProgress(5, "Loading data from TCGA database...");

                var progress = new Progress<int>(p => UpdateProgress(p, $"Processing genes... {p}%"));
                var volcanoData = await _dataService.GetVolcanoDataAsync(project.project_id, progress);

                if (volcanoData == null || volcanoData.Points.Count == 0)
                {
                    HideProgress();
                    MessageBox.Show("Failed to generate volcano plot data.");
                    return;
                }

                _currentVolcanoData = volcanoData;
                _currentVolcanoCancer = project.CancerCode;

                // 轉換為 ViewModel
                UpdateProgress(95, "Preparing display data...");
                _volcanoFullList = volcanoData.Points
                    .Select(p => VolcanoPointViewModel.FromVolcanoPoint(p))
                    .ToList();

                _volcanoDisplayList = _volcanoFullList;

                UpdateProgress(98, "Drawing plot...");
                UpdateVolcanoPlot();

                HideProgress();

                // 顯示資料來源資訊
                VolcanoResultText.Text = $"📊 Data Source: {project.project_id}\n" +
                                          $"Cancer: {project.CancerCode} | " +
                                          $"Genes analyzed: {volcanoData.Points.Count:N0} | " +
                                          $"Tumor samples: {project.n_tumor} | " +
                                          $"Normal samples: {project.n_normal}\n" +
                                          $"⚠️ Data loaded from TCGA binary files (real clinical data)";
            }
            catch (Exception ex)
            {
                HideProgress();
                MessageBox.Show($"Error: {ex.Message}");
            }
            finally
            {
                if (btn != null) btn.IsEnabled = true;
            }
        }

        private void VolcanoThreshold_Changed(object sender, TextChangedEventArgs e)
        {
            if (_currentVolcanoData != null)
                UpdateVolcanoPlot();
        }

        // 搜尋功能
        private void VolcanoSearch_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (_volcanoFullList == null) return;

            string searchText = VolcanoSearchTextBox.Text?.Trim().ToUpper() ?? "";

            if (string.IsNullOrEmpty(searchText))
            {
                _volcanoDisplayList = _volcanoFullList;
            }
            else
            {
                _volcanoDisplayList = _volcanoFullList
                    .Where(p => p.GeneName.ToUpper().Contains(searchText) ||
                               p.GeneId.ToUpper().Contains(searchText))
                    .ToList();
            }

            UpdateVolcanoTable();
        }

        private void VolcanoSearchClear_Click(object sender, RoutedEventArgs e)
        {
            VolcanoSearchTextBox.Text = "";
            _volcanoDisplayList = _volcanoFullList;
            UpdateVolcanoTable();
        }

        // 勾選高亮功能
        private void VolcanoHighlightCheckbox_Click(object sender, RoutedEventArgs e)
        {
            // 重新繪製圖表以顯示高亮
            UpdateVolcanoPlotWithHighlights();
            UpdateHighlightedCount();
        }

        private void VolcanoHighlightSelected_Click(object sender, RoutedEventArgs e)
        {
            // 將目前選中的列設為高亮
            foreach (var item in VolcanoStatsGrid.SelectedItems)
            {
                if (item is VolcanoPointViewModel vm)
                {
                    vm.IsHighlighted = true;
                }
            }

            UpdateVolcanoPlotWithHighlights();
            UpdateHighlightedCount();
        }

        private void VolcanoClearHighlights_Click(object sender, RoutedEventArgs e)
        {
            if (_volcanoFullList == null) return;

            foreach (var p in _volcanoFullList)
            {
                p.IsHighlighted = false;
            }

            UpdateVolcanoPlotWithHighlights();
            UpdateHighlightedCount();
        }

        private void UpdateHighlightedCount()
        {
            if (_volcanoFullList == null)
            {
                VolcanoHighlightedCountText.Text = "0";
                return;
            }

            int count = _volcanoFullList.Count(p => p.IsHighlighted);
            VolcanoHighlightedCountText.Text = count.ToString();
        }

        private void UpdateVolcanoPlot()
        {
            if (_currentVolcanoData == null) return;

            if (!double.TryParse(VolcanoFdrTextBox.Text, out double fdrThreshold)) fdrThreshold = 0.05;
            if (!double.TryParse(VolcanoFcTextBox.Text, out double fcThreshold)) fcThreshold = 1.0;

            fdrThreshold = Math.Max(0.001, Math.Min(0.5, fdrThreshold));
            fcThreshold = Math.Max(0, Math.Min(5, fcThreshold));

            DrawVolcanoPlotWithHighlights(_volcanoFullList, fdrThreshold, fcThreshold);
            UpdateVolcanoTable();
        }

        private void UpdateVolcanoPlotWithHighlights()
        {
            if (_volcanoFullList == null) return;

            if (!double.TryParse(VolcanoFdrTextBox.Text, out double fdrThreshold)) fdrThreshold = 0.05;
            if (!double.TryParse(VolcanoFcTextBox.Text, out double fcThreshold)) fcThreshold = 1.0;

            DrawVolcanoPlotWithHighlights(_volcanoFullList, fdrThreshold, fcThreshold);
        }

        private void UpdateVolcanoTable()
        {
            if (_volcanoDisplayList == null) return;

            if (!double.TryParse(VolcanoFdrTextBox.Text, out double fdrThreshold)) fdrThreshold = 0.05;
            if (!double.TryParse(VolcanoFcTextBox.Text, out double fcThreshold)) fcThreshold = 1.0;

            List<VolcanoPointViewModel> displayGenes;
            string searchText = VolcanoSearchTextBox?.Text?.Trim().ToUpper() ?? "";

            if (!string.IsNullOrEmpty(searchText))
            {
                // 搜尋模式：顯示所有符合搜尋的基因（不論是否顯著）
                displayGenes = _volcanoDisplayList
                    .OrderByDescending(p => p.FDR < fdrThreshold && Math.Abs(p.Log2FoldChange) > fcThreshold) // 顯著的排前面
                    .ThenBy(p => p.PValue)
                    .ToList();
            }
            else
            {
                // 一般模式：只顯示顯著基因（無上限）
                displayGenes = _volcanoDisplayList
                    .Where(p => p.FDR < fdrThreshold && Math.Abs(p.Log2FoldChange) > fcThreshold)
                    .OrderBy(p => p.PValue)
                    .ToList();
            }

            VolcanoStatsGrid.ItemsSource = displayGenes;

            int upCount = _volcanoFullList?.Count(p => p.FDR < fdrThreshold && p.Log2FoldChange > fcThreshold) ?? 0;
            int downCount = _volcanoFullList?.Count(p => p.FDR < fdrThreshold && p.Log2FoldChange < -fcThreshold) ?? 0;
            int totalGenes = _volcanoFullList?.Count ?? 0;
            int sigInDisplay = displayGenes.Count(p => p.FDR < fdrThreshold && Math.Abs(p.Log2FoldChange) > fcThreshold);

            if (!string.IsNullOrEmpty(searchText))
            {
                VolcanoGeneCountText.Text = $" (Found: {displayGenes.Count}, Significant: {sigInDisplay})";
            }
            else
            {
                VolcanoGeneCountText.Text = $" (Significant: {displayGenes.Count}, Up: {upCount}, Down: {downCount})";
            }
            VolcanoSummaryText.Text = $"🔴 Up: {upCount}  |  🔵 Down: {downCount}  |  ⚪ NS: {totalGenes - upCount - downCount}";
        }



        private void DrawVolcanoPlotWithHighlights(List<VolcanoPointViewModel> data, double fdrThreshold, double fcThreshold)
        {
            VolcanoPlotCanvas.Children.Clear();

            if (data == null || data.Count == 0) return;

            int width = (int)VolcanoPlotCanvas.Width;   // 900
            int height = (int)VolcanoPlotCanvas.Height; // 600
            int marginL = 70, marginR = 50, marginT = 50, marginB = 70;
            int plotW = width - marginL - marginR;
            int plotH = height - marginT - marginB;

            // 計算軸範圍
            double maxFC = data.Max(p => Math.Abs(p.Log2FoldChange));
            maxFC = Math.Ceiling(Math.Min(maxFC, 10));

            // Y軸：根據實際數據的最大值，取整到合適的上限
            double rawMaxP = data.Max(p => p.NegLog10PValue);
            double maxNegLogP;
            if (rawMaxP <= 10) maxNegLogP = Math.Ceiling(rawMaxP / 2) * 2;        // 取整到 2 的倍數
            else if (rawMaxP <= 30) maxNegLogP = Math.Ceiling(rawMaxP / 5) * 5;   // 取整到 5 的倍數
            else if (rawMaxP <= 100) maxNegLogP = Math.Ceiling(rawMaxP / 10) * 10; // 取整到 10 的倍數
            else maxNegLogP = Math.Ceiling(rawMaxP / 20) * 20;                     // 取整到 20 的倍數

            // 使用 WriteableBitmap 繪製所有點 (效能優化)
            if (_volcanoBitmap == null || _volcanoBitmap.PixelWidth != width || _volcanoBitmap.PixelHeight != height)
            {
                _volcanoBitmap = new WriteableBitmap(width, height, 96, 96, PixelFormats.Bgra32, null);
            }

            int stride = width * 4;
            byte[] pixels = new byte[height * stride];

            // 填充白色背景
            for (int i = 0; i < pixels.Length; i += 4)
            {
                pixels[i] = 255;     // B
                pixels[i + 1] = 255; // G
                pixels[i + 2] = 255; // R
                pixels[i + 3] = 255; // A
            }

            // 繪製繪圖區邊框
            DrawPixelRect(pixels, stride, width, height, marginL, marginT, plotW, plotH, 200, 200, 200);

            // 計算格線間隔 - Y軸 (根據maxNegLogP決定)
            double yGridInterval;
            if (maxNegLogP <= 10) yGridInterval = 2;
            else if (maxNegLogP <= 30) yGridInterval = 5;
            else if (maxNegLogP <= 100) yGridInterval = 10;
            else yGridInterval = 20;

            // 計算格線間隔 - X軸
            double xGridInterval;
            if (maxFC <= 4) xGridInterval = 1;
            else if (maxFC <= 8) xGridInterval = 2;
            else xGridInterval = 4;

            // 繪製 Y 軸格線
            for (double yVal = 0; yVal <= maxNegLogP; yVal += yGridInterval)
            {
                int y = marginT + plotH - (int)(plotH * yVal / maxNegLogP);
                DrawPixelHLine(pixels, stride, width, marginL, marginL + plotW, y, 230, 230, 230);
            }

            // 繪製 X 軸格線
            for (double fc = -maxFC; fc <= maxFC; fc += xGridInterval)
            {
                int x = marginL + (int)(plotW * (fc + maxFC) / (2 * maxFC));
                DrawPixelVLine(pixels, stride, height, x, marginT, marginT + plotH, 230, 230, 230);
            }

            // 繪製閾值線
            int fdrLineY = marginT + plotH - (int)(plotH * (-Math.Log10(fdrThreshold)) / maxNegLogP);
            if (fdrLineY > marginT && fdrLineY < marginT + plotH)
                DrawPixelDashedHLine(pixels, stride, width, marginL, marginL + plotW, fdrLineY, 128, 128, 128);

            int fcLeftX = marginL + (int)(plotW * (-fcThreshold + maxFC) / (2 * maxFC));
            int fcRightX = marginL + (int)(plotW * (fcThreshold + maxFC) / (2 * maxFC));
            DrawPixelDashedVLine(pixels, stride, height, fcLeftX, marginT, marginT + plotH, 128, 128, 128);
            DrawPixelDashedVLine(pixels, stride, height, fcRightX, marginT, marginT + plotH, 128, 128, 128);

            // 繪製所有數據點 (直接操作像素)
            int upCount = 0, downCount = 0;

            foreach (var pt in data.Where(p => !p.IsHighlighted))
            {
                int x = marginL + (int)(plotW * (pt.Log2FoldChange + maxFC) / (2 * maxFC));
                int y = marginT + plotH - (int)(plotH * Math.Min(pt.NegLog10PValue, maxNegLogP) / maxNegLogP);

                if (x < marginL || x >= marginL + plotW || y < marginT || y >= marginT + plotH)
                    continue;

                byte r, g, b, a;
                int radius;

                if (pt.FDR < fdrThreshold && pt.Log2FoldChange > fcThreshold)
                {
                    r = 231; g = 76; b = 60; a = 200;  // 紅色
                    radius = 3;
                    upCount++;
                }
                else if (pt.FDR < fdrThreshold && pt.Log2FoldChange < -fcThreshold)
                {
                    r = 52; g = 152; b = 219; a = 200;  // 藍色
                    radius = 3;
                    downCount++;
                }
                else
                {
                    r = 160; g = 160; b = 160; a = 100;  // 灰色
                    radius = 2;
                }

                DrawPixelCircle(pixels, stride, width, height, x, y, radius, r, g, b, a);
            }

            // 寫入 bitmap
            _volcanoBitmap.WritePixels(new Int32Rect(0, 0, width, height), pixels, stride, 0);

            // 重用 Image 控制項 (只建立一次)
            if (_volcanoImage == null)
            {
                _volcanoImage = new Image
                {
                    Source = _volcanoBitmap,
                    Width = width,
                    Height = height
                };
            }
            else
            {
                _volcanoImage.Source = _volcanoBitmap;
                _volcanoImage.Width = width;
                _volcanoImage.Height = height;
            }
            VolcanoPlotCanvas.Children.Add(_volcanoImage);

            // Y 軸刻度標籤
            for (double yVal = 0; yVal <= maxNegLogP; yVal += yGridInterval)
            {
                double y = marginT + plotH - plotH * yVal / maxNegLogP;
                AddText(VolcanoPlotCanvas, yVal.ToString("F0"), marginL - 35, y - 8, 9, Brushes.Gray);
            }

            // X 軸刻度標籤
            for (double fc = -maxFC; fc <= maxFC; fc += xGridInterval)
            {
                double x = marginL + plotW * (fc + maxFC) / (2 * maxFC);
                AddText(VolcanoPlotCanvas, fc.ToString("F0"), x - 8, marginT + plotH + 10, 9, Brushes.Gray);
            }

            // 軸標題
            AddText(VolcanoPlotCanvas, "log2(Fold Change)", marginL + plotW / 2 - 60, height - 25, 13, Brushes.Black, FontWeights.SemiBold);
            AddRotatedText(VolcanoPlotCanvas, "-log10(P-value)", 15, height / 2 + 50, -90, 13);

            // 圖表標題
            AddText(VolcanoPlotCanvas, $"{_currentVolcanoCancer}: Tumor vs Normal", marginL, 15, 16, Brushes.Black, FontWeights.Bold);

            // 圖例
            double legX = marginL + plotW - 120, legY = marginT + 10;
            AddRect(VolcanoPlotCanvas, legX, legY, 115, 95, Brushes.White, Brushes.LightGray);
            AddEllipse(VolcanoPlotCanvas, legX + 10, legY + 14, 8, new SolidColorBrush(Color.FromRgb(231, 76, 60)));
            AddText(VolcanoPlotCanvas, $"Up ({upCount:N0})", legX + 25, legY + 8, 10);
            AddEllipse(VolcanoPlotCanvas, legX + 10, legY + 34, 8, new SolidColorBrush(Color.FromRgb(52, 152, 219)));
            AddText(VolcanoPlotCanvas, $"Down ({downCount:N0})", legX + 25, legY + 28, 10);
            AddEllipse(VolcanoPlotCanvas, legX + 10, legY + 54, 8, new SolidColorBrush(Color.FromRgb(160, 160, 160)));
            AddText(VolcanoPlotCanvas, $"NS ({data.Count - upCount - downCount:N0})", legX + 25, legY + 48, 10);

            // Highlighted legend
            var highlightDot = new Ellipse
            {
                Width = 10,
                Height = 10,
                Fill = new SolidColorBrush(Color.FromRgb(255, 152, 0)),
                Stroke = Brushes.Black,
                StrokeThickness = 1.5
            };
            Canvas.SetLeft(highlightDot, legX + 8);
            Canvas.SetTop(highlightDot, legY + 72);
            VolcanoPlotCanvas.Children.Add(highlightDot);
            AddText(VolcanoPlotCanvas, "Highlighted", legX + 25, legY + 68, 10);

            // 繪製高亮的點 (用傳統 Ellipse，因為數量少)
            foreach (var pt in data.Where(p => p.IsHighlighted))
            {
                double x = marginL + plotW * (pt.Log2FoldChange + maxFC) / (2 * maxFC);
                double y = marginT + plotH - plotH * Math.Min(pt.NegLog10PValue, maxNegLogP) / maxNegLogP;

                if (x < marginL || x > marginL + plotW) continue;

                Color fillColor;
                if (pt.FDR < fdrThreshold && pt.Log2FoldChange > fcThreshold)
                    fillColor = Color.FromRgb(231, 76, 60);
                else if (pt.FDR < fdrThreshold && pt.Log2FoldChange < -fcThreshold)
                    fillColor = Color.FromRgb(52, 152, 219);
                else
                    fillColor = Color.FromRgb(255, 152, 0);

                var dot = new Ellipse
                {
                    Width = 14,
                    Height = 14,
                    Fill = new SolidColorBrush(fillColor),
                    Stroke = Brushes.Black,
                    StrokeThickness = 2
                };
                Canvas.SetLeft(dot, x - 7);
                Canvas.SetTop(dot, y - 7);
                VolcanoPlotCanvas.Children.Add(dot);

                var label = new TextBlock
                {
                    Text = pt.GeneName,
                    FontSize = 10,
                    FontWeight = FontWeights.Bold,
                    Background = new SolidColorBrush(Color.FromArgb(220, 255, 255, 255)),
                    Padding = new Thickness(2)
                };
                double labelX = x + 8;
                if (labelX + 60 > marginL + plotW) labelX = x - 60;
                Canvas.SetLeft(label, labelX);
                Canvas.SetTop(label, y - 10);
                VolcanoPlotCanvas.Children.Add(label);
            }

            // 更新統計
            VolcanoSummaryText.Text = $"🔴 Up: {upCount:N0}  |  🔵 Down: {downCount:N0}  |  ⚪ NS: {data.Count - upCount - downCount:N0}";
        }

        // 像素繪圖輔助方法
        private void DrawPixelCircle(byte[] pixels, int stride, int width, int height,
            int cx, int cy, int radius, byte r, byte g, byte b, byte a)
        {
            int r2 = radius * radius;
            for (int dy = -radius; dy <= radius; dy++)
            {
                for (int dx = -radius; dx <= radius; dx++)
                {
                    if (dx * dx + dy * dy <= r2)
                    {
                        int x = cx + dx;
                        int y = cy + dy;
                        if (x >= 0 && x < width && y >= 0 && y < height)
                        {
                            int idx = y * stride + x * 4;
                            float alpha = a / 255f;
                            pixels[idx] = (byte)(b * alpha + pixels[idx] * (1 - alpha));
                            pixels[idx + 1] = (byte)(g * alpha + pixels[idx + 1] * (1 - alpha));
                            pixels[idx + 2] = (byte)(r * alpha + pixels[idx + 2] * (1 - alpha));
                            pixels[idx + 3] = 255;
                        }
                    }
                }
            }
        }

        private void DrawPixelRect(byte[] pixels, int stride, int width, int height,
            int rx, int ry, int rw, int rh, byte r, byte g, byte b)
        {
            for (int x = rx; x < rx + rw && x < width; x++)
            {
                SetPixelSafe(pixels, stride, width, height, x, ry, r, g, b);
                SetPixelSafe(pixels, stride, width, height, x, ry + rh - 1, r, g, b);
            }
            for (int y = ry; y < ry + rh && y < height; y++)
            {
                SetPixelSafe(pixels, stride, width, height, rx, y, r, g, b);
                SetPixelSafe(pixels, stride, width, height, rx + rw - 1, y, r, g, b);
            }
        }

        private void DrawPixelHLine(byte[] pixels, int stride, int width, int x1, int x2, int y, byte r, byte g, byte b)
        {
            for (int x = x1; x <= x2; x++)
                SetPixelSafe(pixels, stride, width, 600, x, y, r, g, b);
        }

        private void DrawPixelVLine(byte[] pixels, int stride, int height, int x, int y1, int y2, byte r, byte g, byte b)
        {
            for (int y = y1; y <= y2; y++)
                SetPixelSafe(pixels, stride, 900, height, x, y, r, g, b);
        }

        private void DrawPixelDashedHLine(byte[] pixels, int stride, int width, int x1, int x2, int y, byte r, byte g, byte b)
        {
            for (int x = x1; x <= x2; x++)
                if ((x / 4) % 2 == 0)
                    SetPixelSafe(pixels, stride, width, 600, x, y, r, g, b);
        }

        private void DrawPixelDashedVLine(byte[] pixels, int stride, int height, int x, int y1, int y2, byte r, byte g, byte b)
        {
            for (int y = y1; y <= y2; y++)
                if ((y / 4) % 2 == 0)
                    SetPixelSafe(pixels, stride, 900, height, x, y, r, g, b);
        }

        private void SetPixelSafe(byte[] pixels, int stride, int width, int height, int x, int y, byte r, byte g, byte b)
        {
            if (x >= 0 && x < width && y >= 0 && y < height)
            {
                int idx = y * stride + x * 4;
                pixels[idx] = b;
                pixels[idx + 1] = g;
                pixels[idx + 2] = r;
                pixels[idx + 3] = 255;
            }
        }


        private void CopyVolcanoStats_Click(object sender, RoutedEventArgs e)
        {
            if (_currentVolcanoData == null) { MessageBox.Show("No data."); return; }

            if (!double.TryParse(VolcanoFdrTextBox.Text, out double fdrThreshold)) fdrThreshold = 0.05;
            if (!double.TryParse(VolcanoFcTextBox.Text, out double fcThreshold)) fcThreshold = 1.0;

            var sigGenes = _currentVolcanoData.Points
                .Where(p => p.FDR < fdrThreshold && Math.Abs(p.Log2FoldChange) > fcThreshold)
                .OrderBy(p => p.PValue)
                .ToList();

            var sb = new StringBuilder();
            sb.AppendLine("Gene\tGeneID\tLog2FC\tP-value\tFDR\tRegulation\tTumorMean\tNormalMean");
            foreach (var g in sigGenes)
                sb.AppendLine($"{g.GeneName}\t{g.GeneId}\t{g.Log2FoldChange:F3}\t{g.PValue:E2}\t{g.FDR:E2}\t{g.Regulation}\t{g.TumorMean:F3}\t{g.NormalMean:F3}");

            Clipboard.SetText(sb.ToString());
            MessageBox.Show($"Copied {sigGenes.Count} significant genes!");
        }

        private void ExportVolcanoImage_Click(object sender, RoutedEventArgs e) => ExportCanvasToPng(VolcanoPlotCanvas, "VolcanoPlot");

        private void ExportVolcanoCsv_Click(object sender, RoutedEventArgs e)
        {
            if (_currentVolcanoData == null) { MessageBox.Show("No data."); return; }

            var dialog = new SaveFileDialog { Filter = "CSV files (*.csv)|*.csv", FileName = $"Volcano_{_currentVolcanoCancer}_{DateTime.Now:yyyyMMdd_HHmmss}.csv" };
            if (dialog.ShowDialog() == true)
            {
                var sb = new StringBuilder();
                sb.AppendLine("Gene,GeneID,Log2FC,PValue,NegLog10P,FDR,Regulation,TumorMean,NormalMean,IsHighlighted");
                foreach (var g in _volcanoFullList?.OrderBy(p => p.PValue) ?? _currentVolcanoData.Points.Select(VolcanoPointViewModel.FromVolcanoPoint).OrderBy(p => p.PValue))
                    sb.AppendLine($"{g.GeneName},{g.GeneId},{g.Log2FoldChange:F4},{g.PValue:E4},{g.NegLog10PValue:F4},{g.FDR:E4},{g.Regulation},{g.TumorMean:F4},{g.NormalMean:F4},{g.IsHighlighted}");

                File.WriteAllText(dialog.FileName, sb.ToString());
                MessageBox.Show($"Exported to:\n{dialog.FileName}");
            }
        }

        #endregion
        #region Helper Methods
        private void AddRect(Canvas c, double x, double y, double w, double h, Brush fill, Brush stroke, double strokeW = 1)
        {
            var r = new Rectangle { Width = w, Height = h, Fill = fill, Stroke = stroke, StrokeThickness = strokeW };
            Canvas.SetLeft(r, x); Canvas.SetTop(r, y); c.Children.Add(r);
        }

        private void AddLine(Canvas c, double x1, double y1, double x2, double y2, Brush stroke, double w, bool dash = false)
        {
            var l = new Line { X1 = x1, Y1 = y1, X2 = x2, Y2 = y2, Stroke = stroke, StrokeThickness = w };
            if (dash) l.StrokeDashArray = new DoubleCollection { 2, 2 };
            c.Children.Add(l);
        }

        private void AddText(Canvas c, string text, double x, double y, double size, Brush fg = null, FontWeight? weight = null)
        {
            var t = new TextBlock { Text = text, FontSize = size, Foreground = fg ?? Brushes.Black };
            if (weight.HasValue) t.FontWeight = weight.Value;
            Canvas.SetLeft(t, x); Canvas.SetTop(t, y); c.Children.Add(t);
        }

        private void AddRotatedText(Canvas c, string text, double x, double y, double angle, double size)
        {
            var t = new TextBlock { Text = text, FontSize = size, FontWeight = FontWeights.SemiBold, RenderTransform = new RotateTransform(angle) };
            Canvas.SetLeft(t, x); Canvas.SetTop(t, y); c.Children.Add(t);
        }

        private void AddEllipse(Canvas c, double x, double y, double size, Brush fill)
        {
            var e = new Ellipse { Width = size, Height = size, Fill = fill };
            Canvas.SetLeft(e, x); Canvas.SetTop(e, y); c.Children.Add(e);
        }

        private void ExportCanvasToPng(Canvas canvas, string prefix)
        {
            if (canvas.Children.Count == 0) { MessageBox.Show("No chart to export."); return; }

            var dialog = new SaveFileDialog { Filter = "PNG files (*.png)|*.png", FileName = $"{prefix}_{DateTime.Now:yyyyMMdd_HHmmss}.png" };
            if (dialog.ShowDialog() == true)
            {
                canvas.Measure(new Size(canvas.Width, canvas.Height));
                canvas.Arrange(new Rect(new Size(canvas.Width, canvas.Height)));

                var renderBitmap = new RenderTargetBitmap((int)canvas.Width, (int)canvas.Height, 96, 96, PixelFormats.Pbgra32);
                renderBitmap.Render(canvas);

                var encoder = new PngBitmapEncoder();
                encoder.Frames.Add(BitmapFrame.Create(renderBitmap));

                using (var stream = File.Create(dialog.FileName))
                    encoder.Save(stream);

                MessageBox.Show($"Exported to:\n{dialog.FileName}");
            }
        }

        private void CopyHeatmapStats_Click(object sender, RoutedEventArgs e)
        {
            if (_currentCorrelationMatrix == null) { MessageBox.Show("No data."); return; }
            var sb = new StringBuilder();
            sb.Append("Gene");
            foreach (var g in _currentCorrelationGenes) sb.Append($"\t{g}");
            sb.AppendLine();
            for (int i = 0; i < _currentCorrelationGenes.Count; i++)
            {
                sb.Append(_currentCorrelationGenes[i]);
                for (int j = 0; j < _currentCorrelationGenes.Count; j++) sb.Append($"\t{_currentCorrelationMatrix[i, j]:F4}");
                sb.AppendLine();
            }
            Clipboard.SetText(sb.ToString());
            MessageBox.Show("Copied!");
        }
        #endregion
    }
}

==================================================
FILE_NAME: WelcomePage.xaml
PATH: D:\programming\BioSAK\BioSAK\Pages\WelcomePage.xaml
==================================================
<Page x:Class="BioSAK.Pages.WelcomePage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      mc:Ignorable="d" 
      d:DesignHeight="650" d:DesignWidth="950"
      Background="#F5F5F5">

    <Grid>
        <Image Source="/Fig/NAME.png" 
               Stretch="Uniform"
               HorizontalAlignment="Center"
               VerticalAlignment="Center"
               MaxWidth="800"
               MaxHeight="600"
               Margin="40"/>
    </Grid>
</Page>


==================================================
FILE_NAME: WelcomePage.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\Pages\WelcomePage.xaml.cs
==================================================
using System.Windows.Controls;

namespace BioSAK.Pages
{
    /// <summary>
    /// </summary>
    public partial class WelcomePage : Page
    {
        public WelcomePage()
        {
            InitializeComponent();
        }
    }
}


==================================================
FILE_NAME: GeneIdService.cs
PATH: D:\programming\BioSAK\BioSAK\Services\GeneIdService.cs
==================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;

namespace BioSAK.Services
{
    /// <summary>
    /// Gene ID 轉換服務
    /// 載入由 R script 產生的 JSON 資料庫
    /// </summary>
    public class GeneIdService
    {
        private readonly string _dataPath;
        private Dictionary<string, List<GeneEntry>> _symbolIndex;
        private Dictionary<string, GeneEntry> _ensemblIndex;
        private Dictionary<string, GeneEntry> _entrezIndex;
        private Dictionary<string, GeneEntry> _hgncIndex;
        private List<GeneEntry> _allGenes;
        private string _currentSpecies;
        private DatabaseInfo _dbInfo;

        public bool IsDatabaseLoaded => _allGenes != null && _allGenes.Count > 0;

        // 用於除錯的訊息
        public string LastError { get; private set; }

        public GeneIdService()
        {
            _dataPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Data", "GeneDB");
            System.Diagnostics.Debug.WriteLine($"[GeneIdService] Data path: {_dataPath}");
            System.Diagnostics.Debug.WriteLine($"[GeneIdService] Base directory: {AppDomain.CurrentDomain.BaseDirectory}");

            if (!Directory.Exists(_dataPath))
            {
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] Creating directory: {_dataPath}");
                Directory.CreateDirectory(_dataPath);
            }
        }

        /// <summary>
        /// 載入基因資料庫 (從 Data/GeneDB/{species}_genes.json)
        /// </summary>
        public async Task<bool> LoadDatabaseAsync(string species)
        {
            if (_currentSpecies == species && IsDatabaseLoaded)
                return true;

            _currentSpecies = species;
            var dbFile = Path.Combine(_dataPath, $"{species}_genes.json");

            System.Diagnostics.Debug.WriteLine($"[GeneIdService] Looking for: {dbFile}");
            System.Diagnostics.Debug.WriteLine($"[GeneIdService] File exists: {File.Exists(dbFile)}");

            if (!File.Exists(dbFile))
            {
                LastError = $"File not found: {dbFile}";
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] ERROR: {LastError}");

                // 列出目錄內容
                if (Directory.Exists(_dataPath))
                {
                    var files = Directory.GetFiles(_dataPath);
                    System.Diagnostics.Debug.WriteLine($"[GeneIdService] Files in directory ({files.Length}):");
                    foreach (var f in files)
                    {
                        System.Diagnostics.Debug.WriteLine($"  - {Path.GetFileName(f)}");
                    }
                }
                else
                {
                    System.Diagnostics.Debug.WriteLine($"[GeneIdService] Directory does not exist: {_dataPath}");
                }

                return false;
            }

            try
            {
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] Loading file: {dbFile}");
                var fileInfo = new FileInfo(dbFile);
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] File size: {fileInfo.Length / 1024.0 / 1024.0:F2} MB");

                var json = await File.ReadAllTextAsync(dbFile);
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] JSON length: {json.Length} chars");
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] JSON preview: {json.Substring(0, Math.Min(500, json.Length))}...");

                var db = JsonSerializer.Deserialize<GeneDatabase>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });

                if (db == null)
                {
                    LastError = "Failed to deserialize JSON (db is null)";
                    System.Diagnostics.Debug.WriteLine($"[GeneIdService] ERROR: {LastError}");
                    return false;
                }

                System.Diagnostics.Debug.WriteLine($"[GeneIdService] Deserialized. Info: {db.Info?.Species}, Genes: {db.Genes?.Count ?? 0}");

                if (db.Genes == null || db.Genes.Count == 0)
                {
                    LastError = "Database is empty or invalid (no genes)";
                    System.Diagnostics.Debug.WriteLine($"[GeneIdService] ERROR: {LastError}");
                    return false;
                }

                _allGenes = db.Genes;
                _dbInfo = db.Info ?? new DatabaseInfo
                {
                    Species = species,
                    GeneCount = _allGenes.Count,
                    Version = "unknown",
                    Sources = "Local JSON"
                };

                BuildIndices();

                System.Diagnostics.Debug.WriteLine($"[GeneIdService] Successfully loaded {_allGenes.Count} genes for {species}");
                return true;
            }
            catch (JsonException jex)
            {
                LastError = $"JSON parsing error: {jex.Message}";
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] JSON ERROR: {jex.Message}");
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] Path: {jex.Path}, Line: {jex.LineNumber}");
                return false;
            }
            catch (Exception ex)
            {
                LastError = $"Error loading database: {ex.Message}";
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] ERROR: {ex.Message}");
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] Stack: {ex.StackTrace}");
                return false;
            }
        }

        private void BuildIndices()
        {
            _symbolIndex = new Dictionary<string, List<GeneEntry>>(StringComparer.OrdinalIgnoreCase);
            _ensemblIndex = new Dictionary<string, GeneEntry>(StringComparer.OrdinalIgnoreCase);
            _entrezIndex = new Dictionary<string, GeneEntry>();
            _hgncIndex = new Dictionary<string, GeneEntry>(StringComparer.OrdinalIgnoreCase);

            foreach (var gene in _allGenes)
            {
                // Symbol index
                if (!string.IsNullOrEmpty(gene.Symbol))
                {
                    if (!_symbolIndex.ContainsKey(gene.Symbol))
                        _symbolIndex[gene.Symbol] = new List<GeneEntry>();
                    _symbolIndex[gene.Symbol].Add(gene);
                }

                // Aliases index
                if (gene.Aliases != null)
                {
                    foreach (var alias in gene.Aliases.Where(a => !string.IsNullOrEmpty(a)))
                    {
                        if (!_symbolIndex.ContainsKey(alias))
                            _symbolIndex[alias] = new List<GeneEntry>();
                        if (!_symbolIndex[alias].Contains(gene))
                            _symbolIndex[alias].Add(gene);
                    }
                }

                // Ensembl index (支援有/無版本號)
                if (!string.IsNullOrEmpty(gene.EnsemblId))
                {
                    var clean = gene.EnsemblId.Split('.')[0];
                    _ensemblIndex[clean] = gene;
                    _ensemblIndex[gene.EnsemblId] = gene;
                }

                // Entrez index
                if (!string.IsNullOrEmpty(gene.EntrezId))
                    _entrezIndex[gene.EntrezId] = gene;

                // HGNC index (支援有/無 "HGNC:" 前綴)
                if (!string.IsNullOrEmpty(gene.HgncId))
                {
                    _hgncIndex[gene.HgncId] = gene;
                    if (gene.HgncId.StartsWith("HGNC:"))
                        _hgncIndex[gene.HgncId.Substring(5)] = gene;
                }
            }

            System.Diagnostics.Debug.WriteLine($"[GeneIdService] Index built: Symbols={_symbolIndex.Count}, Ensembl={_ensemblIndex.Count}, Entrez={_entrezIndex.Count}");
        }

        /// <summary>
        /// 轉換基因 ID
        /// </summary>
        public List<GeneEntry> Convert(string query, string inputType)
        {
            if (string.IsNullOrEmpty(query))
                return new List<GeneEntry>();

            query = query.Trim();

            switch (inputType)
            {
                case "symbol":
                    if (_symbolIndex.TryGetValue(query, out var symbolMatches))
                        return symbolMatches.ToList();
                    break;

                case "ensembl":
                    var ensemblClean = query.Split('.')[0];
                    if (_ensemblIndex.TryGetValue(ensemblClean, out var ensemblMatch))
                        return new List<GeneEntry> { ensemblMatch };
                    break;

                case "entrez":
                    if (_entrezIndex.TryGetValue(query, out var entrezMatch))
                        return new List<GeneEntry> { entrezMatch };
                    break;

                case "hgnc":
                    // 嘗試有無 HGNC: 前綴
                    if (_hgncIndex.TryGetValue(query, out var hgncMatch))
                        return new List<GeneEntry> { hgncMatch };
                    if (_hgncIndex.TryGetValue("HGNC:" + query, out hgncMatch))
                        return new List<GeneEntry> { hgncMatch };
                    break;
            }

            return new List<GeneEntry>();
        }

        public DatabaseInfo GetDatabaseInfo()
        {
            return _dbInfo ?? new DatabaseInfo { Version = "Not loaded", GeneCount = 0 };
        }

        /// <summary>
        /// 取得可用的資料庫清單
        /// </summary>
        public List<string> GetAvailableDatabases()
        {
            var available = new List<string>();

            System.Diagnostics.Debug.WriteLine($"[GeneIdService] GetAvailableDatabases - checking: {_dataPath}");

            if (Directory.Exists(_dataPath))
            {
                foreach (var file in Directory.GetFiles(_dataPath, "*_genes.json"))
                {
                    var species = Path.GetFileNameWithoutExtension(file).Replace("_genes", "");
                    available.Add(species);
                    System.Diagnostics.Debug.WriteLine($"[GeneIdService] Found database: {species}");
                }
            }
            else
            {
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] Directory does not exist!");
            }

            return available;
        }

        /// <summary>
        /// 檢查資料庫是否存在
        /// </summary>
        public bool DatabaseExists(string species)
        {
            var dbFile = Path.Combine(_dataPath, $"{species}_genes.json");
            var exists = File.Exists(dbFile);
            System.Diagnostics.Debug.WriteLine($"[GeneIdService] DatabaseExists({species}): {exists} - {dbFile}");
            return exists;
        }

        /// <summary>
        /// 批次將任意 ID 轉換為 Gene Symbol
        /// 自動偵測輸入類型 (Symbol, Ensembl, Entrez, HGNC)
        /// </summary>
        /// <param name="ids">輸入的 ID 列表</param>
        /// <returns>轉換結果字典 (原始ID -> Symbol)，找不到的會保留原始值</returns>
        public Dictionary<string, string> ConvertToSymbols(IEnumerable<string> ids)
        {
            var result = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            foreach (var id in ids.Where(i => !string.IsNullOrWhiteSpace(i)))
            {
                var trimmed = id.Trim();
                var symbol = ConvertSingleToSymbol(trimmed);
                result[trimmed] = symbol ?? trimmed; // 找不到就保留原始值
            }

            return result;
        }

        /// <summary>
        /// 將單一 ID 轉換為 Gene Symbol
        /// 自動偵測輸入類型
        /// </summary>
        public string ConvertSingleToSymbol(string id)
        {
            if (string.IsNullOrWhiteSpace(id) || !IsDatabaseLoaded)
                return null;

            id = id.Trim();

            // 1. 先檢查是否已經是 Symbol
            if (_symbolIndex.TryGetValue(id, out var symbolMatches))
                return symbolMatches[0].Symbol;

            // 2. 檢查 Ensembl ID (ENSG, ENSMUSG, ENSRNOG...)
            if (id.StartsWith("ENS", StringComparison.OrdinalIgnoreCase))
            {
                var clean = id.Split('.')[0];
                if (_ensemblIndex.TryGetValue(clean, out var ensemblMatch))
                    return ensemblMatch.Symbol;
            }

            // 3. 檢查 HGNC ID
            if (id.StartsWith("HGNC:", StringComparison.OrdinalIgnoreCase) ||
                (int.TryParse(id, out _) && _hgncIndex.ContainsKey("HGNC:" + id)))
            {
                var hgncKey = id.StartsWith("HGNC:") ? id : "HGNC:" + id;
                if (_hgncIndex.TryGetValue(hgncKey, out var hgncMatch))
                    return hgncMatch.Symbol;
            }

            // 4. 檢查 Entrez ID (純數字)
            if (int.TryParse(id, out _))
            {
                if (_entrezIndex.TryGetValue(id, out var entrezMatch))
                    return entrezMatch.Symbol;
            }

            return null;
        }

        /// <summary>
        /// 偵測 ID 類型
        /// </summary>
        public string DetectIdType(string id)
        {
            if (string.IsNullOrWhiteSpace(id))
                return "unknown";

            id = id.Trim();

            if (id.StartsWith("ENS", StringComparison.OrdinalIgnoreCase))
                return "ensembl";

            if (id.StartsWith("HGNC:", StringComparison.OrdinalIgnoreCase))
                return "hgnc";

            if (int.TryParse(id, out _))
            {
                // 純數字可能是 Entrez 或 HGNC
                if (_entrezIndex.ContainsKey(id))
                    return "entrez";
                if (_hgncIndex.ContainsKey("HGNC:" + id))
                    return "hgnc";
                return "entrez"; // 預設當作 Entrez
            }

            // 其他當作 Symbol
            return "symbol";
        }

        /// <summary>
        /// 批次偵測並報告 ID 類型統計
        /// </summary>
        public Dictionary<string, int> AnalyzeIdTypes(IEnumerable<string> ids)
        {
            var stats = new Dictionary<string, int>
            {
                { "symbol", 0 },
                { "ensembl", 0 },
                { "entrez", 0 },
                { "hgnc", 0 },
                { "unknown", 0 }
            };

            foreach (var id in ids.Where(i => !string.IsNullOrWhiteSpace(i)))
            {
                var type = DetectIdType(id.Trim());
                stats[type]++;
            }

            return stats;
        }

        #region Download Functions

        /// <summary>
        /// 下載並更新指定物種的基因資料庫
        /// </summary>
        public async Task<bool> DownloadDatabaseAsync(string species, Action<int, string> progress)
        {
            try
            {
                progress(5, $"Connecting to server...");

                List<GeneEntry> genes;

                switch (species)
                {
                    case "human":
                        genes = await DownloadHumanHgncAsync(progress);
                        break;
                    case "mouse":
                        genes = await DownloadNcbiAsync(species, "Mammalia/Mus_musculus.gene_info.gz", "ENSMUSG", progress);
                        break;
                    case "rat":
                        genes = await DownloadNcbiAsync(species, "Mammalia/Rattus_norvegicus.gene_info.gz", "ENSRNOG", progress);
                        break;
                    case "zebrafish":
                        genes = await DownloadNcbiAsync(species, "Non-mammalian_vertebrates/Danio_rerio.gene_info.gz", "ENSDARG", progress);
                        break;
                    case "fly":
                        genes = await DownloadNcbiAsync(species, "Invertebrates/Drosophila_melanogaster.gene_info.gz", "FBgn", progress);
                        break;
                    case "worm":
                        genes = await DownloadNcbiAsync(species, "Invertebrates/Caenorhabditis_elegans.gene_info.gz", "WBGene", progress);
                        break;
                    default:
                        progress(0, $"Unknown species: {species}");
                        return false;
                }

                if (genes == null || genes.Count == 0)
                {
                    progress(0, "No genes downloaded");
                    return false;
                }

                progress(90, $"Saving {genes.Count:N0} genes...");
                await SaveDatabaseAsync(species, genes);

                progress(100, "Complete!");

                // 重新載入
                _currentSpecies = null;
                await LoadDatabaseAsync(species);

                return true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"[GeneIdService] Download error: {ex.Message}");
                progress(0, $"Error: {ex.Message}");
                return false;
            }
        }

        private async Task<List<GeneEntry>> DownloadHumanHgncAsync(Action<int, string> progress)
        {
            progress(10, "Downloading from HGNC...");

            using var client = new System.Net.Http.HttpClient { Timeout = TimeSpan.FromMinutes(10) };

            // Google Cloud Storage URL
            var url = "https://storage.googleapis.com/public-download-files/hgnc/tsv/tsv/hgnc_complete_set.txt";

            var response = await client.GetStringAsync(url);
            progress(50, "Parsing HGNC data...");

            var genes = new List<GeneEntry>();
            var lines = response.Split('\n');

            // 解析 header
            var header = lines[0].Split('\t').Select(h => h.Trim().ToLower()).ToList();
            int idxSymbol = header.IndexOf("symbol");
            int idxEnsembl = header.IndexOf("ensembl_gene_id");
            int idxEntrez = header.IndexOf("entrez_id");
            int idxHgnc = header.IndexOf("hgnc_id");
            int idxName = header.IndexOf("name");
            int idxLocus = header.IndexOf("locus_type");
            int idxLoc = header.IndexOf("location");
            int idxAlias = header.IndexOf("alias_symbol");
            int idxPrev = header.IndexOf("prev_symbol");

            for (int i = 1; i < lines.Length; i++)
            {
                if (string.IsNullOrWhiteSpace(lines[i])) continue;

                var parts = lines[i].Split('\t');
                if (parts.Length <= idxSymbol) continue;

                var symbol = GetField(parts, idxSymbol);
                if (string.IsNullOrEmpty(symbol)) continue;

                var gene = new GeneEntry
                {
                    Symbol = symbol,
                    EnsemblId = GetField(parts, idxEnsembl),
                    EntrezId = GetField(parts, idxEntrez),
                    HgncId = GetField(parts, idxHgnc),
                    FullName = GetField(parts, idxName),
                    Biotype = GetField(parts, idxLocus),
                    Chromosome = GetField(parts, idxLoc)
                };

                // Aliases
                var aliases = new List<string>();
                var aliasStr = GetField(parts, idxAlias);
                var prevStr = GetField(parts, idxPrev);
                if (!string.IsNullOrEmpty(aliasStr))
                    aliases.AddRange(aliasStr.Split('|').Select(a => a.Trim()).Where(a => !string.IsNullOrEmpty(a)));
                if (!string.IsNullOrEmpty(prevStr))
                    aliases.AddRange(prevStr.Split('|').Select(a => a.Trim()).Where(a => !string.IsNullOrEmpty(a)));
                if (aliases.Count > 0)
                    gene.Aliases = aliases.Distinct().ToList();

                genes.Add(gene);

                if (i % 5000 == 0)
                    progress(50 + (i * 30 / lines.Length), $"Processing {i:N0}/{lines.Length:N0}...");
            }

            return genes;
        }

        private async Task<List<GeneEntry>> DownloadNcbiAsync(string species, string filePath, string ensemblPrefix, Action<int, string> progress)
        {
            progress(10, $"Downloading {species} from NCBI...");

            using var client = new System.Net.Http.HttpClient { Timeout = TimeSpan.FromMinutes(10) };

            var url = $"https://ftp.ncbi.nlm.nih.gov/gene/DATA/GENE_INFO/{filePath}";

            // 下載 gzip 檔案
            var bytes = await client.GetByteArrayAsync(url);
            progress(40, "Decompressing...");

            // 解壓縮
            string content;
            using (var ms = new MemoryStream(bytes))
            using (var gzip = new GZipStream(ms, CompressionMode.Decompress))
            using (var reader = new StreamReader(gzip))
            {
                content = await reader.ReadToEndAsync();
            }

            progress(50, "Parsing gene data...");

            var genes = new List<GeneEntry>();
            var lines = content.Split('\n');

            // 解析 header (移除 # 開頭)
            var headerLine = lines[0];
            if (headerLine.StartsWith("#")) headerLine = headerLine.Substring(1);
            var header = headerLine.Split('\t').Select(h => h.Trim()).ToList();

            int idxGeneId = header.IndexOf("GeneID");
            int idxSymbol = header.IndexOf("Symbol");
            int idxSynonyms = header.IndexOf("Synonyms");
            int idxDbXrefs = header.IndexOf("dbXrefs");
            int idxChrom = header.IndexOf("chromosome");
            int idxDesc = header.IndexOf("description");
            int idxType = header.IndexOf("type_of_gene");

            for (int i = 1; i < lines.Length; i++)
            {
                if (string.IsNullOrWhiteSpace(lines[i])) continue;

                var parts = lines[i].Split('\t');
                if (parts.Length <= idxSymbol) continue;

                var symbol = GetField(parts, idxSymbol);
                if (string.IsNullOrEmpty(symbol) || symbol == "-") continue;

                var gene = new GeneEntry
                {
                    Symbol = symbol,
                    EntrezId = GetField(parts, idxGeneId),
                    FullName = GetFieldOrNull(parts, idxDesc),
                    Biotype = GetFieldOrNull(parts, idxType),
                    Chromosome = GetFieldOrNull(parts, idxChrom)
                };

                // 從 dbXrefs 取得 Ensembl ID
                var xrefs = GetField(parts, idxDbXrefs);
                if (!string.IsNullOrEmpty(xrefs) && xrefs != "-")
                {
                    var match = System.Text.RegularExpressions.Regex.Match(xrefs, $"Ensembl:({ensemblPrefix}[0-9]+)");
                    if (match.Success)
                        gene.EnsemblId = match.Groups[1].Value;
                }

                // Aliases
                var synonyms = GetField(parts, idxSynonyms);
                if (!string.IsNullOrEmpty(synonyms) && synonyms != "-")
                {
                    gene.Aliases = synonyms.Split('|').Select(a => a.Trim()).Where(a => !string.IsNullOrEmpty(a)).ToList();
                }

                genes.Add(gene);

                if (i % 10000 == 0)
                    progress(50 + (i * 30 / lines.Length), $"Processing {i:N0}/{lines.Length:N0}...");
            }

            return genes;
        }

        private string GetField(string[] parts, int index)
        {
            if (index < 0 || index >= parts.Length) return null;
            var val = parts[index].Trim().Trim('"');
            return string.IsNullOrEmpty(val) ? null : val;
        }

        private string GetFieldOrNull(string[] parts, int index)
        {
            var val = GetField(parts, index);
            return val == "-" ? null : val;
        }

        private async Task SaveDatabaseAsync(string species, List<GeneEntry> genes)
        {
            var db = new GeneDatabase
            {
                Info = new DatabaseInfo
                {
                    Species = species,
                    Version = DateTime.Now.ToString("yyyy.MM.dd"),
                    GeneCount = genes.Count,
                    LastUpdate = DateTime.Now,
                    Sources = species == "human" ? "HGNC" : "NCBI Gene"
                },
                Genes = genes
            };

            var dbFile = Path.Combine(_dataPath, $"{species}_genes.json");
            var json = JsonSerializer.Serialize(db, new JsonSerializerOptions
            {
                WriteIndented = false,
                DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
            });
            await File.WriteAllTextAsync(dbFile, json);

            System.Diagnostics.Debug.WriteLine($"[GeneIdService] Saved database to: {dbFile}");
        }

        #endregion
    }

    #region Models

    public class GeneDatabase
    {
        public DatabaseInfo Info { get; set; }
        public List<GeneEntry> Genes { get; set; }
    }

    public class DatabaseInfo
    {
        public string Species { get; set; }
        public string Version { get; set; }
        public int GeneCount { get; set; }
        public DateTime LastUpdate { get; set; }
        public string Sources { get; set; }
    }

    public class GeneEntry
    {
        public string Symbol { get; set; }
        public string EnsemblId { get; set; }
        public string EntrezId { get; set; }
        public string HgncId { get; set; }
        public string FullName { get; set; }
        public string Biotype { get; set; }
        public string Chromosome { get; set; }
        public List<string> Aliases { get; set; }

        // 物種特定 ID
        public string MgiId { get; set; }      // Mouse
        public string RgdId { get; set; }      // Rat
        public string ZfinId { get; set; }     // Zebrafish
    }

    #endregion
}


==================================================
FILE_NAME: KaplanMeierService.cs
PATH: D:\programming\BioSAK\BioSAK\Services\KaplanMeierService.cs
==================================================
using System;
using System.Collections.Generic;
using System.Linq;

namespace BioSAK.Services
{
    /// <summary>
    /// Kaplan-Meier 存活分析服務
    /// 提供 KM 曲線計算、統計量計算和 Log-Rank 檢定
    /// </summary>
    public static class KaplanMeierService
    {
        /// <summary>
        /// 計算 Kaplan-Meier 存活曲線
        /// </summary>
        /// <param name="data">存活資料列表 (SurvivalDays, IsEvent)</param>
        /// <returns>KM 曲線點列表</returns>
        public static List<KMPoint> CalculateSurvivalCurve(List<(int SurvivalDays, bool IsEvent)> data)
        {
            if (data == null || data.Count == 0)
                return new List<KMPoint>();

            // 按時間排序
            var sorted = data.OrderBy(d => d.SurvivalDays).ToList();
            var curve = new List<KMPoint>();

            // 初始點 (t=0, S=1.0)
            curve.Add(new KMPoint
            {
                Time = 0,
                Survival = 1.0,
                AtRisk = sorted.Count,
                Events = 0,
                Censored = 0
            });

            double survival = 1.0;
            int atRisk = sorted.Count;
            int i = 0;

            while (i < sorted.Count)
            {
                int currentTime = sorted[i].SurvivalDays;
                int events = 0;
                int censored = 0;

                // 計算同一時間點的事件數和截斷數
                while (i < sorted.Count && sorted[i].SurvivalDays == currentTime)
                {
                    if (sorted[i].IsEvent)
                        events++;
                    else
                        censored++;
                    i++;
                }

                // 如果有事件發生，更新存活率
                if (events > 0)
                {
                    survival *= (double)(atRisk - events) / atRisk;
                }

                curve.Add(new KMPoint
                {
                    Time = currentTime,
                    Survival = survival,
                    AtRisk = atRisk,
                    Events = events,
                    Censored = censored
                });

                atRisk -= (events + censored);
            }

            return curve;
        }

        /// <summary>
        /// 計算中位存活時間 (50% 存活率對應的時間)
        /// </summary>
        public static int? CalculateMedianSurvival(List<KMPoint> curve)
        {
            if (curve == null || curve.Count < 2)
                return null;

            for (int i = 1; i < curve.Count; i++)
            {
                if (curve[i].Survival <= 0.5)
                {
                    // 返回第一個存活率 <= 50% 的時間點
                    return curve[i].Time;
                }
            }

            // 如果存活率始終 > 50%，返回 null (表示中位數未達到)
            return null;
        }

        /// <summary>
        /// 計算平均存活時間 (受限平均存活時間 - RMST)
        /// 使用曲線下面積計算
        /// </summary>
        public static double CalculateMeanSurvival(List<KMPoint> curve)
        {
            if (curve == null || curve.Count < 2)
                return 0;

            double area = 0;
            for (int i = 1; i < curve.Count; i++)
            {
                // 矩形面積 (上一個存活率 × 時間間隔)
                double width = curve[i].Time - curve[i - 1].Time;
                double height = curve[i - 1].Survival;
                area += width * height;
            }

            return area;
        }

        /// <summary>
        /// Log-Rank 檢定 (比較兩組存活曲線)
        /// </summary>
        /// <param name="group1">第一組資料</param>
        /// <param name="group2">第二組資料</param>
        /// <returns>(卡方值, P值)</returns>
        public static (double ChiSquare, double PValue) LogRankTest(
            List<(int SurvivalDays, bool IsEvent)> group1,
            List<(int SurvivalDays, bool IsEvent)> group2)
        {
            if (group1 == null || group2 == null || group1.Count < 2 || group2.Count < 2)
                return (0, 1.0);

            // 合併所有獨特的事件時間點
            var allTimes = group1.Where(g => g.IsEvent).Select(g => g.SurvivalDays)
                .Union(group2.Where(g => g.IsEvent).Select(g => g.SurvivalDays))
                .Distinct()
                .OrderBy(t => t)
                .ToList();

            if (allTimes.Count == 0)
                return (0, 1.0);

            double O1 = 0; // 觀察事件數 (組1)
            double E1 = 0; // 期望事件數 (組1)
            double V = 0;  // 變異數

            // 初始化風險人數
            var group1Sorted = group1.OrderBy(g => g.SurvivalDays).ToList();
            var group2Sorted = group2.OrderBy(g => g.SurvivalDays).ToList();

            int n1 = group1.Count;  // 組1 風險人數
            int n2 = group2.Count;  // 組2 風險人數
            int idx1 = 0, idx2 = 0;

            foreach (var t in allTimes)
            {
                // 計算此時間點之前離開的人數
                while (idx1 < group1Sorted.Count && group1Sorted[idx1].SurvivalDays < t)
                {
                    n1--;
                    idx1++;
                }
                while (idx2 < group2Sorted.Count && group2Sorted[idx2].SurvivalDays < t)
                {
                    n2--;
                    idx2++;
                }

                if (n1 + n2 <= 1) continue;

                // 計算此時間點的事件數
                int d1 = group1.Count(g => g.SurvivalDays == t && g.IsEvent);
                int d2 = group2.Count(g => g.SurvivalDays == t && g.IsEvent);
                int d = d1 + d2;

                if (d == 0) continue;

                int N = n1 + n2;

                // 觀察值和期望值
                O1 += d1;
                E1 += (double)n1 * d / N;

                // 變異數 (超幾何分佈變異數)
                if (N > 1)
                {
                    V += (double)n1 * n2 * d * (N - d) / (N * N * (N - 1));
                }

                // 更新風險人數 (扣除此時間點的事件和截斷)
                while (idx1 < group1Sorted.Count && group1Sorted[idx1].SurvivalDays == t)
                {
                    n1--;
                    idx1++;
                }
                while (idx2 < group2Sorted.Count && group2Sorted[idx2].SurvivalDays == t)
                {
                    n2--;
                    idx2++;
                }
            }

            if (V <= 0)
                return (0, 1.0);

            // 卡方統計量
            double chiSquare = (O1 - E1) * (O1 - E1) / V;

            // P值 (卡方分佈, 自由度=1)
            double pValue = ChiSquaredPValue(chiSquare, 1);

            return (chiSquare, pValue);
        }

        /// <summary>
        /// 卡方分佈 P 值計算 (使用近似公式)
        /// </summary>
        private static double ChiSquaredPValue(double chiSquare, int df)
        {
            if (chiSquare <= 0) return 1.0;
            if (double.IsNaN(chiSquare) || double.IsInfinity(chiSquare)) return 1.0;

            // 使用正則化不完全 Gamma 函數
            // P(χ² > x) = 1 - P(χ² ≤ x) = 1 - γ(df/2, x/2) / Γ(df/2)
            double a = df / 2.0;
            double x = chiSquare / 2.0;

            return 1.0 - RegularizedGammaP(a, x);
        }

        /// <summary>
        /// 正則化不完全 Gamma 函數 P(a, x) = γ(a, x) / Γ(a)
        /// </summary>
        private static double RegularizedGammaP(double a, double x)
        {
            if (x < 0 || a <= 0) return 0;
            if (x == 0) return 0;
            if (x < a + 1)
            {
                // 使用級數展開
                return GammaPSeries(a, x);
            }
            else
            {
                // 使用連分數
                return 1.0 - GammaQCF(a, x);
            }
        }

        private static double GammaPSeries(double a, double x)
        {
            double sum = 1.0 / a;
            double term = sum;
            for (int n = 1; n < 200; n++)
            {
                term *= x / (a + n);
                sum += term;
                if (Math.Abs(term) < Math.Abs(sum) * 1e-15) break;
            }
            return sum * Math.Exp(-x + a * Math.Log(x) - LogGamma(a));
        }

        private static double GammaQCF(double a, double x)
        {
            double b = x + 1 - a;
            double c = 1.0 / 1e-30;
            double d = 1.0 / b;
            double h = d;
            for (int i = 1; i < 200; i++)
            {
                double an = -i * (i - a);
                b += 2;
                d = an * d + b;
                if (Math.Abs(d) < 1e-30) d = 1e-30;
                c = b + an / c;
                if (Math.Abs(c) < 1e-30) c = 1e-30;
                d = 1.0 / d;
                double delta = d * c;
                h *= delta;
                if (Math.Abs(delta - 1) < 1e-15) break;
            }
            return Math.Exp(-x + a * Math.Log(x) - LogGamma(a)) * h;
        }

        private static double LogGamma(double x)
        {
            // Lanczos approximation
            double[] c = { 76.18009172947146, -86.50532032941677, 24.01409824083091,
                          -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5 };
            double y = x;
            double tmp = x + 5.5;
            tmp -= (x + 0.5) * Math.Log(tmp);
            double ser = 1.000000000190015;
            for (int j = 0; j < 6; j++)
            {
                y += 1;
                ser += c[j] / y;
            }
            return -tmp + Math.Log(2.5066282746310005 * ser / x);
        }
    }

    #region Kaplan-Meier Models

    /// <summary>
    /// KM 曲線上的一個點
    /// </summary>
    public class KMPoint
    {
        public int Time { get; set; }
        public double Survival { get; set; }
        public int AtRisk { get; set; }
        public int Events { get; set; }
        public int Censored { get; set; }

        public double TimeMonths => Time / 30.44;
        public double TimeYears => Time / 365.25;
        public double SurvivalPercent => Survival * 100;
    }

    /// <summary>
    /// 單組 KM 分析結果
    /// </summary>
    public class KMAnalysisResult
    {
        public string GroupName { get; set; }
        public List<KMPoint> Curve { get; set; }
        public int TotalSamples { get; set; }
        public int Events { get; set; }
        public int Censored { get; set; }
        public int? MedianSurvival { get; set; }  // days
        public double MeanSurvival { get; set; }  // days

        public double? MedianSurvivalMonths => MedianSurvival.HasValue ? MedianSurvival.Value / 30.44 : null;
        public double MeanSurvivalMonths => MeanSurvival / 30.44;
    }

    /// <summary>
    /// 高表現 vs 低表現的 KM 比較結果
    /// </summary>
    public class KMComparisonResult
    {
        public KMAnalysisResult LowExpression { get; set; }
        public KMAnalysisResult HighExpression { get; set; }
        public double LogRankChiSquare { get; set; }
        public double LogRankPValue { get; set; }
        public double CutoffPercentile { get; set; }
        public double CutoffValue { get; set; }

        public string PValueDisplay => LogRankPValue < 0.001 ? $"{LogRankPValue:E2}" : $"{LogRankPValue:F4}";
        public bool IsSignificant => LogRankPValue < 0.05;
    }

    #endregion
}


==================================================
FILE_NAME: RebaseParser.cs
PATH: D:\programming\BioSAK\BioSAK\Services\RebaseParser.cs
==================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using BioSAK.Models;

namespace BioSAK.Services
{
    /// <summary>
    /// ??嗉??圾?
    /// </summary>
    public static class RebaseParser
    {
        private static List<RestrictionEnzyme> _cachedEnzymes = null;
        private static readonly object _lock = new object();

        /// <summary>
        /// 敺撱箄???頛????園
        /// </summary>
        public static List<RestrictionEnzyme> LoadEnzymes()
        {
            lock (_lock)
            {
                if (_cachedEnzymes != null)
                    return _cachedEnzymes;

                _cachedEnzymes = new List<RestrictionEnzyme>();

                // ?岫敺??亥?皞?瑼?頛
                string dataPath = GetDataFilePath();
                
                if (File.Exists(dataPath))
                {
                    _cachedEnzymes = ParseEnzymeFile(dataPath);
                }
                else
                {
                    // 雿輻?批遣??祇?”
                    _cachedEnzymes = GetBuiltInEnzymes();
                }

                return _cachedEnzymes;
            }
        }

        /// <summary>
        /// 敺?獢圾???園鞈?
        /// </summary>
        public static List<RestrictionEnzyme> ParseEnzymeFile(string filePath)
        {
            var enzymes = new List<RestrictionEnzyme>();

            foreach (var line in File.ReadAllLines(filePath))
            {
                // 頝喲?閮餉圾?征銵?                if (string.IsNullOrWhiteSpace(line) || line.TrimStart().StartsWith("#"))
                    continue;

                var enzyme = ParseEnzymeLine(line);
                if (enzyme != null)
                {
                    // 瑼Ｘ?臬撌脣??典??嚗??銴?
                    if (!enzymes.Any(e => e.Name.Equals(enzyme.Name, StringComparison.OrdinalIgnoreCase)))
                    {
                        enzymes.Add(enzyme);
                    }
                }
            }

            return enzymes.OrderBy(e => e.Name).ToList();
        }

        /// <summary>
        /// 閫???株??嗉???        /// Format: Name;RecognitionSequence;CutPosition5;CutPosition3
        /// </summary>
        private static RestrictionEnzyme ParseEnzymeLine(string line)
        {
            try
            {
                var parts = line.Split(';');
                if (parts.Length < 4)
                    return null;

                return new RestrictionEnzyme
                {
                    Name = parts[0].Trim(),
                    RecognitionSequence = parts[1].Trim().ToUpper(),
                    CutPosition5 = int.Parse(parts[2].Trim()),
                    CutPosition3 = int.Parse(parts[3].Trim())
                };
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// ??鞈?瑼楝敺?        /// </summary>
        private static string GetDataFilePath()
        {
            // ?岫憭?賜?頝臬?
            var possiblePaths = new[]
            {
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Data", "common_enzymes.txt"),
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "common_enzymes.txt"),
                Path.Combine(Environment.CurrentDirectory, "Data", "common_enzymes.txt"),
                "Data/common_enzymes.txt"
            };

            foreach (var path in possiblePaths)
            {
                if (File.Exists(path))
                    return path;
            }

            return possiblePaths[0]; // 餈??身頝臬?
        }

        /// <summary>
        /// ?批遣??祇??園?”
        /// </summary>
        private static List<RestrictionEnzyme> GetBuiltInEnzymes()
        {
            return new List<RestrictionEnzyme>
            {
                // 撣貊 6-cutters (5' overhang)
                new RestrictionEnzyme { Name = "EcoRI", RecognitionSequence = "GAATTC", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "BamHI", RecognitionSequence = "GGATCC", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "HindIII", RecognitionSequence = "AAGCTT", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "XhoI", RecognitionSequence = "CTCGAG", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "SalI", RecognitionSequence = "GTCGAC", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "XbaI", RecognitionSequence = "TCTAGA", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "NcoI", RecognitionSequence = "CCATGG", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "NheI", RecognitionSequence = "GCTAGC", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "NdeI", RecognitionSequence = "CATATG", CutPosition5 = 2, CutPosition3 = 4 },
                new RestrictionEnzyme { Name = "BglII", RecognitionSequence = "AGATCT", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "ClaI", RecognitionSequence = "ATCGAT", CutPosition5 = 2, CutPosition3 = 4 },
                new RestrictionEnzyme { Name = "MfeI", RecognitionSequence = "CAATTG", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "AgeI", RecognitionSequence = "ACCGGT", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "SpeI", RecognitionSequence = "ACTAGT", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "AflII", RecognitionSequence = "CTTAAG", CutPosition5 = 1, CutPosition3 = 5 },
                new RestrictionEnzyme { Name = "MluI", RecognitionSequence = "ACGCGT", CutPosition5 = 1, CutPosition3 = 5 },

                // 撣貊 6-cutters (3' overhang)
                new RestrictionEnzyme { Name = "SacI", RecognitionSequence = "GAGCTC", CutPosition5 = 5, CutPosition3 = 1 },
                new RestrictionEnzyme { Name = "KpnI", RecognitionSequence = "GGTACC", CutPosition5 = 5, CutPosition3 = 1 },
                new RestrictionEnzyme { Name = "SphI", RecognitionSequence = "GCATGC", CutPosition5 = 5, CutPosition3 = 1 },
                new RestrictionEnzyme { Name = "PstI", RecognitionSequence = "CTGCAG", CutPosition5 = 5, CutPosition3 = 1 },
                new RestrictionEnzyme { Name = "ApaI", RecognitionSequence = "GGGCCC", CutPosition5 = 5, CutPosition3 = 1 },
                new RestrictionEnzyme { Name = "NsiI", RecognitionSequence = "ATGCAT", CutPosition5 = 5, CutPosition3 = 1 },

                // 撣貊 6-cutters (blunt)
                new RestrictionEnzyme { Name = "EcoRV", RecognitionSequence = "GATATC", CutPosition5 = 3, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "SmaI", RecognitionSequence = "CCCGGG", CutPosition5 = 3, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "StuI", RecognitionSequence = "AGGCCT", CutPosition5 = 3, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "NruI", RecognitionSequence = "TCGCGA", CutPosition5 = 3, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "PvuII", RecognitionSequence = "CAGCTG", CutPosition5 = 3, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "HpaI", RecognitionSequence = "GTTAAC", CutPosition5 = 3, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "ScaI", RecognitionSequence = "AGTACT", CutPosition5 = 3, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "DraI", RecognitionSequence = "TTTAAA", CutPosition5 = 3, CutPosition3 = 3 },

                // 撣貊 4-cutters
                new RestrictionEnzyme { Name = "MboI", RecognitionSequence = "GATC", CutPosition5 = 0, CutPosition3 = 4 },
                new RestrictionEnzyme { Name = "Sau3AI", RecognitionSequence = "GATC", CutPosition5 = 0, CutPosition3 = 4 },
                new RestrictionEnzyme { Name = "DpnI", RecognitionSequence = "GATC", CutPosition5 = 2, CutPosition3 = 2 },
                new RestrictionEnzyme { Name = "DpnII", RecognitionSequence = "GATC", CutPosition5 = 0, CutPosition3 = 4 },
                new RestrictionEnzyme { Name = "HaeIII", RecognitionSequence = "GGCC", CutPosition5 = 2, CutPosition3 = 2 },
                new RestrictionEnzyme { Name = "AluI", RecognitionSequence = "AGCT", CutPosition5 = 2, CutPosition3 = 2 },
                new RestrictionEnzyme { Name = "RsaI", RecognitionSequence = "GTAC", CutPosition5 = 2, CutPosition3 = 2 },
                new RestrictionEnzyme { Name = "TaqI", RecognitionSequence = "TCGA", CutPosition5 = 1, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "MspI", RecognitionSequence = "CCGG", CutPosition5 = 1, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "HpaII", RecognitionSequence = "CCGG", CutPosition5 = 1, CutPosition3 = 3 },

                // 撣貊 8-cutters
                new RestrictionEnzyme { Name = "NotI", RecognitionSequence = "GCGGCCGC", CutPosition5 = 2, CutPosition3 = 6 },
                new RestrictionEnzyme { Name = "PacI", RecognitionSequence = "TTAATTAA", CutPosition5 = 5, CutPosition3 = 3 },
                new RestrictionEnzyme { Name = "AscI", RecognitionSequence = "GGCGCGCC", CutPosition5 = 2, CutPosition3 = 6 },
                new RestrictionEnzyme { Name = "FseI", RecognitionSequence = "GGCCGGCC", CutPosition5 = 6, CutPosition3 = 2 },
                new RestrictionEnzyme { Name = "SwaI", RecognitionSequence = "ATTTAAAT", CutPosition5 = 4, CutPosition3 = 4 },
                new RestrictionEnzyme { Name = "PmeI", RecognitionSequence = "GTTTAAAC", CutPosition5 = 4, CutPosition3 = 4 },
                new RestrictionEnzyme { Name = "SbfI", RecognitionSequence = "CCTGCAGG", CutPosition5 = 6, CutPosition3 = 2 },

                // Type IIS enzymes
                new RestrictionEnzyme { Name = "BsaI", RecognitionSequence = "GGTCTC", CutPosition5 = 7, CutPosition3 = 11 },
                new RestrictionEnzyme { Name = "BsmBI", RecognitionSequence = "CGTCTC", CutPosition5 = 7, CutPosition3 = 11 },
                new RestrictionEnzyme { Name = "BbsI", RecognitionSequence = "GAAGAC", CutPosition5 = 8, CutPosition3 = 12 },
                new RestrictionEnzyme { Name = "SapI", RecognitionSequence = "GCTCTTC", CutPosition5 = 8, CutPosition3 = 11 },
            };
        }

        /// <summary>
        /// ?寞??迂????        /// </summary>
        public static List<RestrictionEnzyme> SearchByName(string searchText)
        {
            var enzymes = LoadEnzymes();
            if (string.IsNullOrWhiteSpace(searchText))
                return enzymes;

            return enzymes
                .Where(e => e.Name.IndexOf(searchText, StringComparison.OrdinalIgnoreCase) >= 0)
                .ToList();
        }

        /// <summary>
        /// ?寞?霅摨??瑕漲蝭拚
        /// </summary>
        public static List<RestrictionEnzyme> FilterByCutterType(int length)
        {
            var enzymes = LoadEnzymes();
            return enzymes
                .Where(e => e.RecognitionSequence.Length == length)
                .ToList();
        }

        /// <summary>
        /// ?寞??怎垢憿?蝭拚
        /// </summary>
        public static List<RestrictionEnzyme> FilterByOverhangType(OverhangType type)
        {
            var enzymes = LoadEnzymes();
            return enzymes
                .Where(e => e.OverhangType == type)
                .ToList();
        }

        /// <summary>
        /// ??????
        /// </summary>
        public static List<RestrictionEnzyme> GetPalindromicEnzymes()
        {
            var enzymes = LoadEnzymes();
            return enzymes
                .Where(e => e.IsPalindromic)
                .ToList();
        }
    }
}


==================================================
FILE_NAME: RestrictionEnzymeCutter.cs
PATH: D:\programming\BioSAK\BioSAK\Services\RestrictionEnzymeCutter.cs
==================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using BioSAK.Models;

namespace BioSAK.Services
{
    /// <summary>
    /// ??嗅??脫???    /// </summary>
    public class RestrictionEnzymeCutter
    {
        /// <summary>
        /// 撠????脖?暺?        /// </summary>
        /// <param name="sequence">DNA 摨?</param>
        /// <param name="enzyme">???/param>
        /// <param name="isCircular">?臬?箇? DNA</param>
        /// <returns>?雿??”</returns>
        public List<CutSite> FindCutSites(string sequence, RestrictionEnzyme enzyme, bool isCircular = false)
        {
            var cutSites = new List<CutSite>();
            string cleanSequence = CleanSequence(sequence);
            
            if (string.IsNullOrEmpty(cleanSequence))
                return cutSites;

            // ??甇????            string pattern = enzyme.GetRegexPattern();
            var matches = Regex.Matches(cleanSequence, pattern, RegexOptions.IgnoreCase);

            foreach (Match match in matches)
            {
                cutSites.Add(new CutSite
                {
                    Position = match.Index + enzyme.CutPosition5,
                    RecognitionStart = match.Index,
                    Enzyme = enzyme,
                    IsReverseStrand = false
                });
            }

            // 憒?銝??摨?嚗??閬?撠???鋆
            if (!enzyme.IsPalindromic)
            {
                string revPattern = enzyme.GetReverseComplementRegexPattern();
                var revMatches = Regex.Matches(cleanSequence, revPattern, RegexOptions.IgnoreCase);

                foreach (Match match in revMatches)
                {
                    // ???∠??雿蔭?閬矽??                    int cutPos = match.Index + (enzyme.RecognitionSequence.Length - enzyme.CutPosition3);
                    cutSites.Add(new CutSite
                    {
                        Position = cutPos,
                        RecognitionStart = match.Index,
                        Enzyme = enzyme,
                        IsReverseStrand = true
                    });
                }
            }

            return cutSites.OrderBy(c => c.Position).ToList();
        }

        /// <summary>
        /// 雿輻憭撠????脖?暺?        /// </summary>
        public List<CutSite> FindCutSites(string sequence, IEnumerable<RestrictionEnzyme> enzymes, bool isCircular = false)
        {
            var allCutSites = new List<CutSite>();

            foreach (var enzyme in enzymes)
            {
                var sites = FindCutSites(sequence, enzyme, isCircular);
                allCutSites.AddRange(sites);
            }

            return allCutSites.OrderBy(c => c.Position).ToList();
        }

        /// <summary>
        /// ?瑁??銝西???畾?        /// </summary>
        /// <param name="sequence">DNA 摨?</param>
        /// <param name="enzyme">???/param>
        /// <param name="isCircular">?臬?箇? DNA</param>
        /// <returns>DNA ?挾?”嚗?憭批???</returns>
        public List<DnaFragment> DigestSequence(string sequence, RestrictionEnzyme enzyme, bool isCircular = false)
        {
            return DigestSequence(sequence, new[] { enzyme }, isCircular);
        }

        /// <summary>
        /// 雿輻憭?瑁??銝西???畾?        /// </summary>
        public List<DnaFragment> DigestSequence(string sequence, IEnumerable<RestrictionEnzyme> enzymes, bool isCircular = false)
        {
            var fragments = new List<DnaFragment>();
            string cleanSequence = CleanSequence(sequence);

            if (string.IsNullOrEmpty(cleanSequence))
                return fragments;

            // ??????脖?暺?            var cutSites = FindCutSites(cleanSequence, enzymes, isCircular);

            if (cutSites.Count == 0)
            {
                // 瘝??雿?嚗璇??銝??畾?                fragments.Add(new DnaFragment
                {
                    Size = cleanSequence.Length,
                    StartPosition = 0,
                    EndPosition = cleanSequence.Length - 1,
                    Sequence = cleanSequence,
                    Enzyme5End = null,
                    Enzyme3End = null
                });
                return fragments;
            }

            // ???臭????脖?蝵桐蒂??
            var cutPositions = cutSites
                .Select(c => c.Position)
                .Distinct()
                .OrderBy(p => p)
                .ToList();

            // 撱箇?雿蔭?圈????            var positionToEnzyme = cutSites
                .GroupBy(c => c.Position)
                .ToDictionary(g => g.Key, g => g.First().Enzyme);

            if (isCircular)
            {
                // ?啁? DNA ?
                fragments = DigestCircular(cleanSequence, cutPositions, positionToEnzyme);
            }
            else
            {
                // 蝺?DNA ?
                fragments = DigestLinear(cleanSequence, cutPositions, positionToEnzyme);
            }

            // 靘之撠?摨??勗之?啣?嚗?            return fragments.OrderByDescending(f => f.Size).ToList();
        }

        /// <summary>
        /// 蝺?DNA ?
        /// </summary>
        private List<DnaFragment> DigestLinear(string sequence, List<int> cutPositions, 
            Dictionary<int, RestrictionEnzyme> positionToEnzyme)
        {
            var fragments = new List<DnaFragment>();
            int prevPosition = 0;

            for (int i = 0; i < cutPositions.Count; i++)
            {
                int currentPosition = cutPositions[i];
                
                if (currentPosition > prevPosition && currentPosition <= sequence.Length)
                {
                    int fragLength = currentPosition - prevPosition;
                    fragments.Add(new DnaFragment
                    {
                        Size = fragLength,
                        StartPosition = prevPosition,
                        EndPosition = currentPosition - 1,
                        Sequence = sequence.Substring(prevPosition, fragLength),
                        Enzyme5End = i == 0 ? null : positionToEnzyme.GetValueOrDefault(cutPositions[i - 1]),
                        Enzyme3End = positionToEnzyme.GetValueOrDefault(currentPosition)
                    });
                }
                prevPosition = currentPosition;
            }

            // ?敺???畾蛛?敺?敺??脖??啣??蝡荔?
            if (prevPosition < sequence.Length)
            {
                int lastFragLength = sequence.Length - prevPosition;
                fragments.Add(new DnaFragment
                {
                    Size = lastFragLength,
                    StartPosition = prevPosition,
                    EndPosition = sequence.Length - 1,
                    Sequence = sequence.Substring(prevPosition),
                    Enzyme5End = positionToEnzyme.GetValueOrDefault(cutPositions.Last()),
                    Enzyme3End = null
                });
            }

            return fragments;
        }

        /// <summary>
        /// ?啁? DNA ?
        /// </summary>
        private List<DnaFragment> DigestCircular(string sequence, List<int> cutPositions,
            Dictionary<int, RestrictionEnzyme> positionToEnzyme)
        {
            var fragments = new List<DnaFragment>();

            if (cutPositions.Count == 0)
            {
                fragments.Add(new DnaFragment
                {
                    Size = sequence.Length,
                    StartPosition = 0,
                    EndPosition = sequence.Length - 1,
                    Sequence = sequence
                });
                return fragments;
            }

            if (cutPositions.Count == 1)
            {
                // ?芣?銝???脖?暺?蝺批?敺璇停?臭???畾?                int cutPos = cutPositions[0];
                string linearized = sequence.Substring(cutPos) + sequence.Substring(0, cutPos);
                fragments.Add(new DnaFragment
                {
                    Size = sequence.Length,
                    StartPosition = cutPos,
                    EndPosition = cutPos - 1, // ?啁?
                    Sequence = linearized,
                    Enzyme5End = positionToEnzyme.GetValueOrDefault(cutPos),
                    Enzyme3End = positionToEnzyme.GetValueOrDefault(cutPos)
                });
                return fragments;
            }

            // 憭??脖?暺?            for (int i = 0; i < cutPositions.Count; i++)
            {
                int startPos = cutPositions[i];
                int endPos = cutPositions[(i + 1) % cutPositions.Count];

                string fragSequence;
                int fragSize;

                if (endPos > startPos)
                {
                    // 甇?虜??嚗?畾萎?頝刻???
                    fragSize = endPos - startPos;
                    fragSequence = sequence.Substring(startPos, fragSize);
                }
                else
                {
                    // 頝刻?????畾?                    fragSize = (sequence.Length - startPos) + endPos;
                    fragSequence = sequence.Substring(startPos) + sequence.Substring(0, endPos);
                }

                fragments.Add(new DnaFragment
                {
                    Size = fragSize,
                    StartPosition = startPos,
                    EndPosition = endPos == 0 ? sequence.Length - 1 : endPos - 1,
                    Sequence = fragSequence,
                    Enzyme5End = positionToEnzyme.GetValueOrDefault(startPos),
                    Enzyme3End = positionToEnzyme.GetValueOrDefault(endPos)
                });
            }

            return fragments;
        }

        /// <summary>
        /// 皜?摨?嚗宏?斤征?賢??詨?嚗?        /// </summary>
        private string CleanSequence(string sequence)
        {
            if (string.IsNullOrEmpty(sequence))
                return string.Empty;

            // 蝘駁蝛箇?摮???DNA 摮?
            var cleaned = new System.Text.StringBuilder();
            foreach (char c in sequence.ToUpper())
            {
                if ("ATGCRYKMSWBDHVN".Contains(c))
                {
                    cleaned.Append(c);
                }
            }
            return cleaned.ToString();
        }

        /// <summary>
        /// ??摨?銝剜?????脫?瘜?        /// </summary>
        /// <param name="sequence">DNA 摨?</param>
        /// <param name="enzymes">閬????嗅?銵?/param>
        /// <param name="isCircular">?臬?箇?</param>
        /// <returns>??蝯?</returns>
        public List<EnzymeAnalysisResult> AnalyzeAllEnzymes(string sequence, 
            IEnumerable<RestrictionEnzyme> enzymes, bool isCircular = false)
        {
            var results = new List<EnzymeAnalysisResult>();
            string cleanSequence = CleanSequence(sequence);

            foreach (var enzyme in enzymes)
            {
                var cutSites = FindCutSites(cleanSequence, enzyme, isCircular);
                
                results.Add(new EnzymeAnalysisResult
                {
                    Enzyme = enzyme,
                    CutCount = cutSites.Count,
                    CutPositions = cutSites.Select(c => c.Position).ToList(),
                    CutSites = cutSites
                });
            }

            return results.OrderBy(r => r.Enzyme.Name).ToList();
        }
    }

    /// <summary>
    /// ?嗅?????    /// </summary>
    public class EnzymeAnalysisResult
    {
        public RestrictionEnzyme Enzyme { get; set; }
        public int CutCount { get; set; }
        public List<int> CutPositions { get; set; }
        public List<CutSite> CutSites { get; set; }

        /// <summary>
        /// ?澆????雿蔭摮葡
        /// </summary>
        public string PositionsString => CutPositions.Count > 0 
            ? string.Join(", ", CutPositions) 
            : "None";

        /// <summary>
        /// ?怎垢憿??膩
        /// </summary>
        public string OverhangDescription
        {
            get
            {
                switch (Enzyme.OverhangType)
                {
                    case OverhangType.FivePrime:
                        return "5' overhang";
                    case OverhangType.ThreePrime:
                        return "3' overhang";
                    case OverhangType.Blunt:
                        return "Blunt end";
                    default:
                        return "Unknown";
                }
            }
        }
    }

    /// <summary>
    /// Dictionary ?游??寞?
    /// </summary>
    public static class DictionaryExtensions
    {
        public static TValue GetValueOrDefault<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, TKey key)
        {
            return dictionary.TryGetValue(key, out TValue value) ? value : default;
        }
    }
}


==================================================
FILE_NAME: StatisticsService.cs
PATH: D:\programming\BioSAK\BioSAK\Services\StatisticsService.cs
==================================================
using System;
using System.Collections.Generic;
using System.Linq;

namespace BioSAK.Services
{
    /// <summary>
    /// 統計分析服務
    /// 提供各種生物統計分析所需的統計函數
    /// </summary>
    public static class StatisticsService
    {
        #region T-Tests

        /// <summary>
        /// Welch's t-test (不假設相等變異數)
        /// </summary>
        /// <param name="sample1">樣本1</param>
        /// <param name="sample2">樣本2</param>
        /// <returns>P值</returns>
        public static double WelchTTest(List<double> sample1, List<double> sample2)
        {
            if (sample1 == null || sample2 == null || sample1.Count < 2 || sample2.Count < 2)
                return 1.0;

            int n1 = sample1.Count;
            int n2 = sample2.Count;
            double mean1 = sample1.Average();
            double mean2 = sample2.Average();

            double var1 = sample1.Sum(x => (x - mean1) * (x - mean1)) / (n1 - 1);
            double var2 = sample2.Sum(x => (x - mean2) * (x - mean2)) / (n2 - 1);

            if (var1 + var2 == 0) return 1.0;

            // Welch's t-statistic
            double se = Math.Sqrt(var1 / n1 + var2 / n2);
            if (se == 0) return 1.0;

            double t = (mean1 - mean2) / se;

            // Welch-Satterthwaite 自由度
            double v1n = var1 / n1;
            double v2n = var2 / n2;
            double df = (v1n + v2n) * (v1n + v2n) /
                       (v1n * v1n / (n1 - 1) + v2n * v2n / (n2 - 1));

            // 計算雙尾 P 值
            return TDistributionPValue(Math.Abs(t), df) * 2;
        }

        /// <summary>
        /// Student's t-test (假設相等變異數)
        /// </summary>
        public static double StudentTTest(List<double> sample1, List<double> sample2)
        {
            if (sample1 == null || sample2 == null || sample1.Count < 2 || sample2.Count < 2)
                return 1.0;

            int n1 = sample1.Count;
            int n2 = sample2.Count;
            double mean1 = sample1.Average();
            double mean2 = sample2.Average();

            double ss1 = sample1.Sum(x => (x - mean1) * (x - mean1));
            double ss2 = sample2.Sum(x => (x - mean2) * (x - mean2));

            // Pooled variance
            double sp = Math.Sqrt((ss1 + ss2) / (n1 + n2 - 2));
            if (sp == 0) return 1.0;

            double t = (mean1 - mean2) / (sp * Math.Sqrt(1.0 / n1 + 1.0 / n2));
            double df = n1 + n2 - 2;

            return TDistributionPValue(Math.Abs(t), df) * 2;
        }

        #endregion

        #region Correlation

        /// <summary>
        /// Pearson 相關係數
        /// </summary>
        /// <param name="x">X 變數</param>
        /// <param name="y">Y 變數</param>
        /// <returns>(r, pValue, n)</returns>
        public static (double r, double pValue, int n) PearsonCorrelation(List<double> x, List<double> y)
        {
            if (x == null || y == null || x.Count != y.Count || x.Count < 3)
                return (0, 1.0, 0);

            int n = x.Count;
            double meanX = x.Average();
            double meanY = y.Average();

            double sumXY = 0, sumX2 = 0, sumY2 = 0;
            for (int i = 0; i < n; i++)
            {
                double dx = x[i] - meanX;
                double dy = y[i] - meanY;
                sumXY += dx * dy;
                sumX2 += dx * dx;
                sumY2 += dy * dy;
            }

            if (sumX2 == 0 || sumY2 == 0)
                return (0, 1.0, n);

            double r = sumXY / Math.Sqrt(sumX2 * sumY2);

            // Fisher's z transformation for p-value
            if (Math.Abs(r) >= 1) return (r, r == 1 ? 0 : 1, n);

            double t = r * Math.Sqrt((n - 2) / (1 - r * r));
            double pValue = TDistributionPValue(Math.Abs(t), n - 2) * 2;

            return (r, pValue, n);
        }

        /// <summary>
        /// Spearman 秩相關係數
        /// </summary>
        public static (double rho, double pValue) SpearmanCorrelation(List<double> x, List<double> y)
        {
            if (x == null || y == null || x.Count != y.Count || x.Count < 3)
                return (0, 1.0);

            int n = x.Count;
            var rankX = GetRanks(x);
            var rankY = GetRanks(y);
            var result = PearsonCorrelation(rankX, rankY);
            return (result.r, result.pValue);
        }

        private static List<double> GetRanks(List<double> values)
        {
            var indexed = values.Select((v, i) => (Value: v, Index: i))
                               .OrderBy(x => x.Value)
                               .ToList();

            var ranks = new double[values.Count];
            int i = 0;
            while (i < indexed.Count)
            {
                int j = i;
                // 找出相同值的範圍
                while (j < indexed.Count && indexed[j].Value == indexed[i].Value)
                    j++;

                // 平均秩
                double avgRank = (i + j + 1) / 2.0;
                for (int k = i; k < j; k++)
                    ranks[indexed[k].Index] = avgRank;

                i = j;
            }

            return ranks.ToList();
        }

        #endregion

        #region Linear Regression

        /// <summary>
        /// 線性迴歸
        /// </summary>
        /// <returns>(slope, intercept, r2)</returns>
        public static (double slope, double intercept, double r2) LinearRegression(
            List<double> x, List<double> y)
        {
            if (x == null || y == null || x.Count != y.Count || x.Count < 3)
                return (0, 0, 0);

            int n = x.Count;
            double meanX = x.Average();
            double meanY = y.Average();

            double sumXY = 0, sumX2 = 0, sumY2 = 0;
            for (int i = 0; i < n; i++)
            {
                double dx = x[i] - meanX;
                double dy = y[i] - meanY;
                sumXY += dx * dy;
                sumX2 += dx * dx;
                sumY2 += dy * dy;
            }

            if (sumX2 == 0)
                return (0, meanY, 0);

            double slope = sumXY / sumX2;
            double intercept = meanY - slope * meanX;

            double r = sumY2 == 0 ? 0 : sumXY / Math.Sqrt(sumX2 * sumY2);
            double r2 = r * r;

            return (slope, intercept, r2);
        }

        /// <summary>
        /// 線性迴歸 (完整版，含 P 值)
        /// </summary>
        /// <returns>(slope, intercept, r, r2, pValue)</returns>
        public static (double slope, double intercept, double r, double r2, double pValue) LinearRegressionFull(
            List<double> x, List<double> y)
        {
            if (x == null || y == null || x.Count != y.Count || x.Count < 3)
                return (0, 0, 0, 0, 1.0);

            int n = x.Count;
            double meanX = x.Average();
            double meanY = y.Average();

            double sumXY = 0, sumX2 = 0, sumY2 = 0;
            for (int i = 0; i < n; i++)
            {
                double dx = x[i] - meanX;
                double dy = y[i] - meanY;
                sumXY += dx * dy;
                sumX2 += dx * dx;
                sumY2 += dy * dy;
            }

            if (sumX2 == 0)
                return (0, meanY, 0, 0, 1.0);

            double slope = sumXY / sumX2;
            double intercept = meanY - slope * meanX;

            double r = sumY2 == 0 ? 0 : sumXY / Math.Sqrt(sumX2 * sumY2);
            double r2 = r * r;

            // P-value for slope
            double residualSS = sumY2 - slope * sumXY;
            double se = Math.Sqrt(residualSS / (n - 2) / sumX2);
            if (se == 0) return (slope, intercept, r, r2, 0);

            double t = slope / se;
            double pValue = TDistributionPValue(Math.Abs(t), n - 2) * 2;

            return (slope, intercept, r, r2, pValue);
        }

        #endregion

        #region Multiple Testing Correction

        /// <summary>
        /// Benjamini-Hochberg FDR 校正
        /// </summary>
        /// <param name="pValues">原始 P 值列表</param>
        /// <returns>FDR 校正後的 Q 值列表</returns>
        public static List<double> BenjaminiHochbergFDR(List<double> pValues)
        {
            if (pValues == null || pValues.Count == 0)
                return new List<double>();

            int n = pValues.Count;
            var indexed = pValues.Select((p, i) => (PValue: p, Index: i))
                                .OrderBy(x => x.PValue)
                                .ToList();

            var qValues = new double[n];
            double minQ = 1.0;

            // 從最大到最小遍歷
            for (int i = n - 1; i >= 0; i--)
            {
                int rank = i + 1;
                double q = indexed[i].PValue * n / rank;
                q = Math.Min(q, minQ);
                minQ = q;
                qValues[indexed[i].Index] = Math.Min(q, 1.0);
            }

            return qValues.ToList();
        }

        /// <summary>
        /// Bonferroni 校正
        /// </summary>
        public static List<double> BonferroniCorrection(List<double> pValues)
        {
            if (pValues == null || pValues.Count == 0)
                return new List<double>();

            int n = pValues.Count;
            return pValues.Select(p => Math.Min(p * n, 1.0)).ToList();
        }

        #endregion

        #region Distribution Functions

        /// <summary>
        /// t 分佈的上尾機率 (單尾)
        /// </summary>
        private static double TDistributionPValue(double t, double df)
        {
            if (t <= 0) return 0.5;
            if (double.IsNaN(t) || double.IsInfinity(t)) return 0;
            if (df <= 0) return 1.0;

            // 使用 Beta 分佈關係
            // P(T > t) = 0.5 * I(df/(df+t²), df/2, 1/2)
            double x = df / (df + t * t);
            return 0.5 * RegularizedBeta(x, df / 2, 0.5);
        }

        /// <summary>
        /// 正則化不完全 Beta 函數
        /// </summary>
        private static double RegularizedBeta(double x, double a, double b)
        {
            if (x <= 0) return 0;
            if (x >= 1) return 1;

            // 使用連分數展開
            double bt = Math.Exp(LogGamma(a + b) - LogGamma(a) - LogGamma(b) +
                                a * Math.Log(x) + b * Math.Log(1 - x));

            if (x < (a + 1) / (a + b + 2))
            {
                return bt * BetaCF(x, a, b) / a;
            }
            else
            {
                return 1.0 - bt * BetaCF(1 - x, b, a) / b;
            }
        }

        private static double BetaCF(double x, double a, double b)
        {
            const int maxIterations = 200;
            const double eps = 1e-15;

            double qab = a + b;
            double qap = a + 1;
            double qam = a - 1;
            double c = 1;
            double d = 1 - qab * x / qap;
            if (Math.Abs(d) < 1e-30) d = 1e-30;
            d = 1 / d;
            double h = d;

            for (int m = 1; m <= maxIterations; m++)
            {
                int m2 = 2 * m;
                double aa = m * (b - m) * x / ((qam + m2) * (a + m2));
                d = 1 + aa * d;
                if (Math.Abs(d) < 1e-30) d = 1e-30;
                c = 1 + aa / c;
                if (Math.Abs(c) < 1e-30) c = 1e-30;
                d = 1 / d;
                h *= d * c;

                aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
                d = 1 + aa * d;
                if (Math.Abs(d) < 1e-30) d = 1e-30;
                c = 1 + aa / c;
                if (Math.Abs(c) < 1e-30) c = 1e-30;
                d = 1 / d;
                double delta = d * c;
                h *= delta;

                if (Math.Abs(delta - 1) < eps) break;
            }

            return h;
        }

        private static double LogGamma(double x)
        {
            // Lanczos approximation
            double[] c = { 76.18009172947146, -86.50532032941677, 24.01409824083091,
                          -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5 };
            double y = x;
            double tmp = x + 5.5;
            tmp -= (x + 0.5) * Math.Log(tmp);
            double ser = 1.000000000190015;
            for (int j = 0; j < 6; j++)
            {
                y += 1;
                ser += c[j] / y;
            }
            return -tmp + Math.Log(2.5066282746310005 * ser / x);
        }

        #endregion

        #region Descriptive Statistics

        /// <summary>
        /// 計算標準差
        /// </summary>
        public static double StandardDeviation(List<double> values)
        {
            if (values == null || values.Count < 2) return 0;

            double mean = values.Average();
            double sumSquares = values.Sum(x => (x - mean) * (x - mean));
            return Math.Sqrt(sumSquares / (values.Count - 1));
        }

        /// <summary>
        /// 計算標準誤差
        /// </summary>
        public static double StandardError(List<double> values)
        {
            if (values == null || values.Count < 2) return 0;
            return StandardDeviation(values) / Math.Sqrt(values.Count);
        }

        /// <summary>
        /// 計算四分位數
        /// </summary>
        public static (double Q1, double Median, double Q3) Quartiles(List<double> values)
        {
            if (values == null || values.Count == 0)
                return (0, 0, 0);

            var sorted = values.OrderBy(v => v).ToList();
            int n = sorted.Count;

            double median = n % 2 == 0 ?
                (sorted[n / 2 - 1] + sorted[n / 2]) / 2 :
                sorted[n / 2];

            double q1 = sorted[(int)(n * 0.25)];
            double q3 = sorted[(int)(n * 0.75)];

            return (q1, median, q3);
        }

        /// <summary>
        /// 計算百分位數
        /// </summary>
        public static double Percentile(List<double> values, double percentile)
        {
            if (values == null || values.Count == 0) return 0;
            if (percentile <= 0) return values.Min();
            if (percentile >= 100) return values.Max();

            var sorted = values.OrderBy(v => v).ToList();
            double index = (percentile / 100.0) * (sorted.Count - 1);
            int lower = (int)Math.Floor(index);
            int upper = (int)Math.Ceiling(index);

            if (lower == upper) return sorted[lower];

            return sorted[lower] + (index - lower) * (sorted[upper] - sorted[lower]);
        }

        #endregion
    }
}


==================================================
FILE_NAME: TcgaDataService.cs
PATH: D:\programming\BioSAK\BioSAK\Services\TcgaDataService.cs
==================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;

namespace BioSAK.Services
{
    /// <summary>
    /// TCGA 資料服務 - 二進位格式版本 (含生存資訊)
    /// </summary>
    public class TcgaDataService
    {
        private readonly string _dataPath;
        private List<TcgaProjectIndex> _projectIndex;
        private readonly Dictionary<string, TcgaProjectData> _dataCache = new();

        public TcgaDataService()
        {
            _dataPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Data", "TCGA");
        }

        public TcgaDataService(string dataPath)
        {
            _dataPath = dataPath;
        }

        public bool IsDataAvailable()
        {
            return Directory.Exists(_dataPath) &&
                   File.Exists(Path.Combine(_dataPath, "projects_index.json"));
        }

        #region 專案索引

        public async Task<List<TcgaProjectIndex>> GetProjectIndexAsync()
        {
            if (_projectIndex != null) return _projectIndex;

            var indexPath = Path.Combine(_dataPath, "projects_index.json");
            if (!File.Exists(indexPath))
                throw new FileNotFoundException("projects_index.json not found");

            var json = await File.ReadAllTextAsync(indexPath);
            _projectIndex = JsonSerializer.Deserialize<List<TcgaProjectIndex>>(json);
            return _projectIndex;
        }

        #endregion

        #region 載入專案資料

        private async Task<TcgaProjectData> LoadProjectDataAsync(string projectId)
        {
            if (_dataCache.TryGetValue(projectId, out var cached))
                return cached;

            var metaPath = Path.Combine(_dataPath, $"{projectId}_meta.json");
            var matrixPath = Path.Combine(_dataPath, $"{projectId}_matrix.bin");

            if (!File.Exists(metaPath) || !File.Exists(matrixPath))
                return null;

            var metaJson = await File.ReadAllTextAsync(metaPath);
            var meta = JsonSerializer.Deserialize<TcgaMetadata>(metaJson);

            var matrixBytes = await File.ReadAllBytesAsync(matrixPath);
            int totalValues = meta.n_genes * meta.n_samples;
            var matrix = new float[totalValues];
            Buffer.BlockCopy(matrixBytes, 0, matrix, 0, matrixBytes.Length);

            var geneIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < meta.gene_ids.Length; i++)
            {
                var geneIdClean = meta.gene_ids[i].Split('.')[0];
                if (!geneIndex.ContainsKey(geneIdClean))
                    geneIndex[geneIdClean] = i;

                if (meta.gene_names != null && i < meta.gene_names.Length &&
                    !string.IsNullOrEmpty(meta.gene_names[i]))
                {
                    var geneName = meta.gene_names[i];
                    if (!geneIndex.ContainsKey(geneName))
                        geneIndex[geneName] = i;
                }
            }

            var tumorIndices = new List<int>();
            var normalIndices = new List<int>();
            for (int i = 0; i < meta.sample_conditions.Length; i++)
            {
                if (meta.sample_conditions[i] == "Tumor")
                    tumorIndices.Add(i);
                else if (meta.sample_conditions[i] == "Normal")
                    normalIndices.Add(i);
            }

            var projectData = new TcgaProjectData
            {
                Meta = meta,
                Matrix = matrix,
                GeneIndex = geneIndex,
                TumorIndices = tumorIndices.ToArray(),
                NormalIndices = normalIndices.ToArray()
            };

            _dataCache[projectId] = projectData;
            return projectData;
        }

        #endregion

        #region 基因表達查詢

        public async Task<GeneExpressionResult> GetGeneExpressionAsync(string projectId, string geneQuery)
        {
            var data = await LoadProjectDataAsync(projectId);
            if (data == null) return null;

            var queryClean = geneQuery.ToUpper().Split('.')[0];
            if (!data.GeneIndex.TryGetValue(queryClean, out int geneIdx))
            {
                if (!data.GeneIndex.TryGetValue(geneQuery, out geneIdx))
                    return null;
            }

            var meta = data.Meta;
            int nSamples = meta.n_samples;
            int rowStart = geneIdx * nSamples;

            var result = new GeneExpressionResult
            {
                GeneId = meta.gene_ids[geneIdx],
                GeneName = meta.gene_names?[geneIdx],
                TumorValues = new List<double>(data.TumorIndices.Length),
                NormalValues = new List<double>(data.NormalIndices.Length),
                TumorSampleIds = new List<string>(data.TumorIndices.Length),
                NormalSampleIds = new List<string>(data.NormalIndices.Length)
            };

            foreach (int sampleIdx in data.TumorIndices)
            {
                result.TumorValues.Add(data.Matrix[rowStart + sampleIdx]);
                result.TumorSampleIds.Add(meta.sample_ids[sampleIdx]);
            }

            foreach (int sampleIdx in data.NormalIndices)
            {
                result.NormalValues.Add(data.Matrix[rowStart + sampleIdx]);
                result.NormalSampleIds.Add(meta.sample_ids[sampleIdx]);
            }

            return result;
        }

        public async Task<TwoGeneExpressionResult> GetTwoGeneExpressionAsync(
            string projectId, string gene1, string gene2)
        {
            var data = await LoadProjectDataAsync(projectId);
            if (data == null) return null;

            if (!data.GeneIndex.TryGetValue(gene1.ToUpper().Split('.')[0], out int idx1) &&
                !data.GeneIndex.TryGetValue(gene1, out idx1))
                return null;

            if (!data.GeneIndex.TryGetValue(gene2.ToUpper().Split('.')[0], out int idx2) &&
                !data.GeneIndex.TryGetValue(gene2, out idx2))
                return null;

            var meta = data.Meta;
            int nSamples = meta.n_samples;
            int row1Start = idx1 * nSamples;
            int row2Start = idx2 * nSamples;

            var result = new TwoGeneExpressionResult
            {
                Gene1Id = meta.gene_ids[idx1],
                Gene1Name = meta.gene_names?[idx1],
                Gene2Id = meta.gene_ids[idx2],
                Gene2Name = meta.gene_names?[idx2],
                TumorPairs = new List<(double X, double Y, string SampleId)>(data.TumorIndices.Length),
                NormalPairs = new List<(double X, double Y, string SampleId)>(data.NormalIndices.Length)
            };

            foreach (int sampleIdx in data.TumorIndices)
            {
                result.TumorPairs.Add((
                    data.Matrix[row1Start + sampleIdx],
                    data.Matrix[row2Start + sampleIdx],
                    meta.sample_ids[sampleIdx]
                ));
            }

            foreach (int sampleIdx in data.NormalIndices)
            {
                result.NormalPairs.Add((
                    data.Matrix[row1Start + sampleIdx],
                    data.Matrix[row2Start + sampleIdx],
                    meta.sample_ids[sampleIdx]
                ));
            }

            return result;
        }

        public async Task<MultiGeneExpressionResult> GetMultiGeneExpressionAsync(
            string projectId, List<string> geneQueries, string condition = "Both")
        {
            var data = await LoadProjectDataAsync(projectId);
            if (data == null) return null;

            var meta = data.Meta;
            int nSamples = meta.n_samples;

            int[] sampleIndices = condition switch
            {
                "Tumor" => data.TumorIndices,
                "Normal" => data.NormalIndices,
                _ => data.TumorIndices.Concat(data.NormalIndices).ToArray()
            };

            var result = new MultiGeneExpressionResult
            {
                GeneIds = new List<string>(),
                GeneNames = new List<string>(),
                Expressions = new List<List<double>>()
            };

            foreach (var query in geneQueries)
            {
                var q = query.ToUpper().Split('.')[0];
                if (!data.GeneIndex.TryGetValue(q, out int geneIdx) &&
                    !data.GeneIndex.TryGetValue(query, out geneIdx))
                    continue;

                result.GeneIds.Add(meta.gene_ids[geneIdx]);
                result.GeneNames.Add(meta.gene_names?[geneIdx] ?? meta.gene_ids[geneIdx]);

                int rowStart = geneIdx * nSamples;
                var values = new List<double>(sampleIndices.Length);
                foreach (int sampleIdx in sampleIndices)
                {
                    values.Add(data.Matrix[rowStart + sampleIdx]);
                }
                result.Expressions.Add(values);
            }

            return result;
        }

        #endregion

        #region 生存分析相關方法

        public async Task<bool> HasSurvivalDataAsync(string projectId)
        {
            var data = await LoadProjectDataAsync(projectId);
            if (data?.Meta?.vital_status == null) return false;

            int validCount = data.Meta.vital_status.Count(s => !string.IsNullOrEmpty(s));
            return validCount > 10;
        }

        public async Task<GeneSurvivalResult> GetGeneSurvivalDataAsync(string projectId, string geneQuery)
        {
            var data = await LoadProjectDataAsync(projectId);
            if (data == null) return null;

            var meta = data.Meta;
            if (meta.vital_status == null || meta.days_to_death == null || meta.days_to_last_follow_up == null)
                return null;

            var queryClean = geneQuery.ToUpper().Split('.')[0];
            if (!data.GeneIndex.TryGetValue(queryClean, out int geneIdx))
            {
                if (!data.GeneIndex.TryGetValue(geneQuery, out geneIdx))
                    return null;
            }

            int nSamples = meta.n_samples;
            int rowStart = geneIdx * nSamples;

            var result = new GeneSurvivalResult
            {
                GeneId = meta.gene_ids[geneIdx],
                GeneName = meta.gene_names?[geneIdx] ?? meta.gene_ids[geneIdx],
                Samples = new List<SurvivalSample>()
            };

            foreach (int sampleIdx in data.TumorIndices)
            {
                var vitalStatus = meta.vital_status[sampleIdx];
                if (string.IsNullOrEmpty(vitalStatus)) continue;

                bool isDead = vitalStatus.Equals("Dead", StringComparison.OrdinalIgnoreCase);
                int? survivalDays = null;

                if (isDead && meta.days_to_death[sampleIdx].HasValue)
                    survivalDays = meta.days_to_death[sampleIdx].Value;
                else if (!isDead && meta.days_to_last_follow_up[sampleIdx].HasValue)
                    survivalDays = meta.days_to_last_follow_up[sampleIdx].Value;

                if (!survivalDays.HasValue || survivalDays.Value <= 0) continue;

                result.Samples.Add(new SurvivalSample
                {
                    SampleId = meta.sample_ids[sampleIdx],
                    Expression = data.Matrix[rowStart + sampleIdx],
                    SurvivalDays = survivalDays.Value,
                    IsEvent = isDead,
                    VitalStatus = vitalStatus
                });
            }

            return result;
        }

        public async Task<VolcanoPlotResult> GetVolcanoDataAsync(string projectId, IProgress<int> progress = null)
        {
            var data = await LoadProjectDataAsync(projectId);
            if (data == null) return null;

            var meta = data.Meta;
            int nSamples = meta.n_samples;
            int nGenes = meta.n_genes;

            if (data.TumorIndices.Length < 3 || data.NormalIndices.Length < 3)
                return null;

            var result = new VolcanoPlotResult
            {
                ProjectId = projectId,
                Points = new List<VolcanoPoint>(nGenes)
            };

            for (int geneIdx = 0; geneIdx < nGenes; geneIdx++)
            {
                if (progress != null && geneIdx % 1000 == 0)
                    progress.Report((geneIdx * 100) / nGenes);

                int rowStart = geneIdx * nSamples;

                var tumorVals = new List<double>(data.TumorIndices.Length);
                var normalVals = new List<double>(data.NormalIndices.Length);

                foreach (int i in data.TumorIndices)
                    tumorVals.Add(data.Matrix[rowStart + i]);
                foreach (int i in data.NormalIndices)
                    normalVals.Add(data.Matrix[rowStart + i]);

                double tumorMean = tumorVals.Average();
                double normalMean = normalVals.Average();
                double log2FC = tumorMean - normalMean;

                double pValue = StatisticsService.WelchTTest(tumorVals, normalVals);

                if (double.IsNaN(pValue) || double.IsInfinity(pValue) || pValue <= 0)
                    continue;

                result.Points.Add(new VolcanoPoint
                {
                    GeneId = meta.gene_ids[geneIdx],
                    GeneName = meta.gene_names?[geneIdx] ?? meta.gene_ids[geneIdx],
                    Log2FoldChange = log2FC,
                    PValue = pValue,
                    NegLog10PValue = -Math.Log10(pValue),
                    TumorMean = tumorMean,
                    NormalMean = normalMean
                });
            }

            if (result.Points.Count > 0)
            {
                var pValues = result.Points.Select(p => p.PValue).ToList();
                var fdrs = StatisticsService.BenjaminiHochbergFDR(pValues);
                for (int i = 0; i < result.Points.Count; i++)
                {
                    result.Points[i].FDR = fdrs[i];
                }
            }

            progress?.Report(100);
            return result;
        }

        #endregion

        public void ClearCache()
        {
            _dataCache.Clear();
            _projectIndex = null;
            GC.Collect();
        }

        public int CachedProjectCount => _dataCache.Count;
    }

    #region Models

    public class TcgaProjectIndex
    {
        public string project_id { get; set; }
        public int n_genes { get; set; }
        public int n_samples { get; set; }
        public int n_tumor { get; set; }
        public int n_normal { get; set; }
        public int n_survival_available { get; set; }
        public int n_alive { get; set; }
        public int n_dead { get; set; }

        public string CancerCode => project_id?.Replace("TCGA-", "") ?? "";
        public string DisplayName => $"{CancerCode} (T:{n_tumor}, N:{n_normal})";
        public string CancerFullName => CancerCode;
        public bool HasSurvivalData => n_survival_available > 0;
    }

    public class TcgaMetadata
    {
        public string project_id { get; set; }
        public int n_genes { get; set; }
        public int n_samples { get; set; }
        public int n_tumor { get; set; }
        public int n_normal { get; set; }
        public string[] gene_ids { get; set; }
        public string[] gene_names { get; set; }
        public string[] sample_ids { get; set; }
        public string[] sample_conditions { get; set; }
        public string matrix_format { get; set; }
        public string matrix_layout { get; set; }
        public int[] matrix_shape { get; set; }
        // 生存資訊
        public string[] patient_ids { get; set; }
        public string[] vital_status { get; set; }
        public int?[] days_to_death { get; set; }
        public int?[] days_to_last_follow_up { get; set; }
        public int?[] age_at_diagnosis { get; set; }
        public string[] gender { get; set; }
    }

    internal class TcgaProjectData
    {
        public TcgaMetadata Meta { get; set; }
        public float[] Matrix { get; set; }
        public Dictionary<string, int> GeneIndex { get; set; }
        public int[] TumorIndices { get; set; }
        public int[] NormalIndices { get; set; }
    }

    public class GeneExpressionResult
    {
        public string GeneId { get; set; }
        public string GeneName { get; set; }
        public List<double> TumorValues { get; set; }
        public List<double> NormalValues { get; set; }
        public List<string> TumorSampleIds { get; set; }
        public List<string> NormalSampleIds { get; set; }
    }

    public class TwoGeneExpressionResult
    {
        public string Gene1Id { get; set; }
        public string Gene1Name { get; set; }
        public string Gene2Id { get; set; }
        public string Gene2Name { get; set; }
        public List<(double X, double Y, string SampleId)> TumorPairs { get; set; }
        public List<(double X, double Y, string SampleId)> NormalPairs { get; set; }
    }

    public class MultiGeneExpressionResult
    {
        public List<string> GeneIds { get; set; }
        public List<string> GeneNames { get; set; }
        public List<List<double>> Expressions { get; set; }
    }

    #endregion

    #region Survival Models

    public class SurvivalSample
    {
        public string SampleId { get; set; }
        public double Expression { get; set; }
        public int SurvivalDays { get; set; }
        public bool IsEvent { get; set; }
        public string VitalStatus { get; set; }
        public double SurvivalMonths => SurvivalDays / 30.44;
    }

    public class GeneSurvivalResult
    {
        public string GeneId { get; set; }
        public string GeneName { get; set; }
        public List<SurvivalSample> Samples { get; set; }
        public int TotalSamples => Samples?.Count ?? 0;
        public int EventCount => Samples?.Count(s => s.IsEvent) ?? 0;
    }

    #endregion

    #region Volcano Models

    public class VolcanoPoint
    {
        public string GeneId { get; set; }
        public string GeneName { get; set; }
        public double Log2FoldChange { get; set; }
        public double PValue { get; set; }
        public double NegLog10PValue { get; set; }
        public double FDR { get; set; }
        public double TumorMean { get; set; }
        public double NormalMean { get; set; }

        public string PValueDisplay => PValue < 0.001 ? $"{PValue:E2}" : $"{PValue:F4}";
        public string FDRDisplay => FDR < 0.001 ? $"{FDR:E2}" : $"{FDR:F4}";

        public bool IsSignificant(double fdrThreshold = 0.05, double fcThreshold = 1.0)
            => FDR < fdrThreshold && Math.Abs(Log2FoldChange) > fcThreshold;

        public string Regulation
        {
            get
            {
                if (!IsSignificant()) return "NS";
                return Log2FoldChange > 0 ? "Up" : "Down";
            }
        }
    }

    public class VolcanoPlotResult
    {
        public string ProjectId { get; set; }
        public List<VolcanoPoint> Points { get; set; }

        public int UpRegulated(double fdr = 0.05, double fc = 1.0) =>
            Points?.Count(p => p.FDR < fdr && p.Log2FoldChange > fc) ?? 0;

        public int DownRegulated(double fdr = 0.05, double fc = 1.0) =>
            Points?.Count(p => p.FDR < fdr && p.Log2FoldChange < -fc) ?? 0;
    }

    #endregion
}


==================================================
FILE_NAME: TcgaGeneHelpr.cs
PATH: D:\programming\BioSAK\BioSAK\Services\TcgaGeneHelpr.cs
==================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace BioSAK.Services
{
    /// <summary>
    /// TCGA Gene Helper - 為 TCGA Analysis 提供基因 ID 轉換功能
    /// 支援輸入：Symbol, Ensembl ID, Entrez ID, HGNC ID
    /// 自動轉換為 Gene Symbol 以匹配 TCGA 資料
    /// </summary>
    public class TcgaGeneHelper
    {
        private readonly GeneIdService _geneService;
        private bool _isInitialized = false;

        public TcgaGeneHelper()
        {
            _geneService = new GeneIdService();
        }

        /// <summary>
        /// 初始化基因資料庫 (Human)
        /// </summary>
        public async Task<bool> InitializeAsync()
        {
            if (_isInitialized && _geneService.IsDatabaseLoaded)
                return true;

            _isInitialized = await _geneService.LoadDatabaseAsync("human");
            return _isInitialized;
        }

        /// <summary>
        /// 檢查資料庫是否已載入
        /// </summary>
        public bool IsReady => _geneService.IsDatabaseLoaded;

        /// <summary>
        /// 將任意 ID 轉換為 Gene Symbol
        /// 自動偵測輸入類型
        /// </summary>
        /// <param name="geneId">輸入的基因 ID (Symbol, Ensembl, Entrez, 或 HGNC)</param>
        /// <returns>Gene Symbol，找不到則返回原始輸入</returns>
        public string ToSymbol(string geneId)
        {
            if (string.IsNullOrWhiteSpace(geneId))
                return geneId;

            var symbol = _geneService.ConvertSingleToSymbol(geneId.Trim());
            return symbol ?? geneId.Trim();
        }

        /// <summary>
        /// 批次轉換多個 ID 為 Gene Symbol
        /// </summary>
        /// <param name="geneIds">輸入的 ID 列表</param>
        /// <returns>轉換結果字典 (原始ID -> Symbol)</returns>
        public Dictionary<string, string> ToSymbols(IEnumerable<string> geneIds)
        {
            return _geneService.ConvertToSymbols(geneIds);
        }

        /// <summary>
        /// 解析使用者輸入的基因清單
        /// 支援多種分隔符號：換行、逗號、Tab、分號
        /// 自動轉換為 Symbol
        /// </summary>
        /// <param name="input">使用者輸入的文字</param>
        /// <returns>Gene Symbol 列表</returns>
        public List<string> ParseAndConvert(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                return new List<string>();

            var separators = new[] { '\n', '\r', ',', '\t', ';', ' ' };
            var ids = input.Split(separators, StringSplitOptions.RemoveEmptyEntries)
                          .Select(g => g.Trim())
                          .Where(g => !string.IsNullOrEmpty(g))
                          .Distinct()
                          .ToList();

            var symbols = new List<string>();
            foreach (var id in ids)
            {
                var symbol = ToSymbol(id);
                if (!string.IsNullOrEmpty(symbol))
                    symbols.Add(symbol);
            }

            return symbols.Distinct().ToList();
        }

        /// <summary>
        /// 解析並轉換，同時返回轉換報告
        /// </summary>
        public (List<string> symbols, ConversionReport report) ParseAndConvertWithReport(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                return (new List<string>(), new ConversionReport());

            var separators = new[] { '\n', '\r', ',', '\t', ';' };
            var ids = input.Split(separators, StringSplitOptions.RemoveEmptyEntries)
                          .Select(g => g.Trim())
                          .Where(g => !string.IsNullOrEmpty(g))
                          .Distinct()
                          .ToList();

            var report = new ConversionReport
            {
                TotalInput = ids.Count
            };

            var symbols = new List<string>();
            foreach (var id in ids)
            {
                var detectedType = _geneService.DetectIdType(id);
                var symbol = _geneService.ConvertSingleToSymbol(id);

                if (symbol != null)
                {
                    symbols.Add(symbol);
                    report.Converted++;

                    // 統計輸入類型
                    if (!report.InputTypes.ContainsKey(detectedType))
                        report.InputTypes[detectedType] = 0;
                    report.InputTypes[detectedType]++;
                }
                else
                {
                    // 找不到的保留原始值
                    symbols.Add(id);
                    report.NotFound.Add(id);
                }
            }

            return (symbols.Distinct().ToList(), report);
        }

        /// <summary>
        /// 驗證基因是否存在於資料庫中
        /// </summary>
        public bool ValidateGene(string geneId)
        {
            if (string.IsNullOrWhiteSpace(geneId))
                return false;

            var symbol = _geneService.ConvertSingleToSymbol(geneId.Trim());
            return symbol != null;
        }

        /// <summary>
        /// 取得基因的完整資訊
        /// </summary>
        public GeneEntry GetGeneInfo(string geneId)
        {
            if (string.IsNullOrWhiteSpace(geneId))
                return null;

            var inputType = _geneService.DetectIdType(geneId.Trim());
            var matches = _geneService.Convert(geneId.Trim(), inputType);
            return matches.FirstOrDefault();
        }
    }

    /// <summary>
    /// 轉換報告
    /// </summary>
    public class ConversionReport
    {
        public int TotalInput { get; set; }
        public int Converted { get; set; }
        public List<string> NotFound { get; set; } = new List<string>();
        public Dictionary<string, int> InputTypes { get; set; } = new Dictionary<string, int>();

        public int NotFoundCount => NotFound.Count;
        public double SuccessRate => TotalInput > 0 ? (double)Converted / TotalInput * 100 : 0;

        public string GetSummary()
        {
            var typeInfo = string.Join(", ", InputTypes.Select(kv => $"{kv.Key}: {kv.Value}"));
            return $"Converted: {Converted}/{TotalInput} ({SuccessRate:F1}%) | Types: {typeInfo}";
        }
    }
}


==================================================
FILE_NAME: App.xaml
PATH: D:\programming\BioSAK\BioSAK\App.xaml
==================================================
<Application x:Class="BioSAK.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:BioSAK"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>


==================================================
FILE_NAME: App.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\App.xaml.cs
==================================================
using System.Configuration;
using System.Data;
using System.Windows;

namespace BioSAK
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }

}


==================================================
FILE_NAME: AssemblyInfo.cs
PATH: D:\programming\BioSAK\BioSAK\AssemblyInfo.cs
==================================================
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]


==================================================
FILE_NAME: MainWindow.xaml
PATH: D:\programming\BioSAK\BioSAK\MainWindow.xaml
==================================================
<Window x:Class="BioSAK.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BioSAK"
        mc:Ignorable="d"
        Title="BioXAK - Biology X Analysis Kit" 
        Height="700" Width="1200" 
        Background="#F5F5F5"
        WindowStartupLocation="CenterScreen"
        Icon="/Fig/ICON.png">

    <Window.Resources>
        <Style x:Key="CategoryHeaderStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="12"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Foreground" Value="#888888"/>
            <Setter Property="Margin" Value="10,15,10,5"/>
        </Style>

        <Style x:Key="NavButtonStyle" TargetType="Button">
            <Setter Property="Height" Value="40"/>
            <Setter Property="Margin" Value="5,2"/>
            <Setter Property="Padding" Value="10,5"/>
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="HorizontalContentAlignment" Value="Left"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" 
                                Background="{TemplateBinding Background}"
                                CornerRadius="5"
                                Padding="{TemplateBinding Padding}">
                            <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                              VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#E8E8E8"/>
                            </Trigger>
                            <Trigger Property="IsPressed" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#D0D0D0"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <!-- ?訾葉???撠??璅?? -->
        <Style x:Key="NavButtonActiveStyle" TargetType="Button" BasedOn="{StaticResource NavButtonStyle}">
            <Setter Property="Background" Value="#DBEAFE"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="border" 
                                Background="{TemplateBinding Background}"
                                CornerRadius="5"
                                Padding="{TemplateBinding Padding}"
                                BorderBrush="#3B82F6"
                                BorderThickness="0,0,3,0">
                            <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                              VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#BFDBFE"/>
                            </Trigger>
                            <Trigger Property="IsPressed" Value="True">
                                <Setter TargetName="border" Property="Background" Value="#93C5FD"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <Style x:Key="IconStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="16"/>
            <Setter Property="Width" Value="25"/>
            <Setter Property="VerticalAlignment" Value="Center"/>
        </Style>
    </Window.Resources>

    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="220"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <Border Grid.Column="0" Background="White" BorderBrush="#E0E0E0" BorderThickness="0,0,1,0">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <Border Grid.Row="0" Padding="15" BorderBrush="#E0E0E0" BorderThickness="0,0,0,1">
                    <StackPanel Orientation="Horizontal" VerticalAlignment="Center">
                        <Image Source="/Fig/ICON.png" Width="32" Height="32" RenderOptions.BitmapScalingMode="HighQuality"/>
                        <TextBlock Text="BioXAK" FontSize="22" FontWeight="Bold" Foreground="#333" 
                                   VerticalAlignment="Center" Margin="10,0,0,0"/>
                    </StackPanel>
                </Border>

                <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto">
                    <StackPanel>

                        <!-- TCGA DATABASE -->
                        <TextBlock Text="TCGA DATABASE" Style="{StaticResource CategoryHeaderStyle}"/>

                        <Button x:Name="BtnTcgaAnalysis" Style="{StaticResource NavButtonStyle}" Click="TcgaAnalysis_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="?妞" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="TCGA Analysis" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>
                        <Button x:Name="BtnGeneIdConverter" Style="{StaticResource NavButtonStyle}" Click="GeneIdConverter_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="??" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="Gene ID Converter" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>

                        <!-- Flow Cytometry -->
                        <TextBlock Text="FLOW CYTOMETRY" Style="{StaticResource CategoryHeaderStyle}"/>

                        <Button x:Name="BtnFlowCytometry" Style="{StaticResource NavButtonStyle}" Click="Flow_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="??" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="Flow Cytometry Analyzer" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>

                        <!-- Graphs -->
                        <TextBlock Text="GRAPHS" Style="{StaticResource CategoryHeaderStyle}"/>

                        <Button x:Name="BtnGraphsGenerator" Style="{StaticResource NavButtonStyle}" Click="GraphsGenerator_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="??" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="Graphs Generator" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>

                        <!-- DNA Tools -->
                        <TextBlock Text="DNA TOOLS" Style="{StaticResource CategoryHeaderStyle}"/>

                        <Button x:Name="BtnNucleotide" Style="{StaticResource NavButtonStyle}" Click="NucleotideComplementary_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="??" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="Nucleotide Complementary" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>

                        <!-- CRISPR -->
                        <TextBlock Text="CRISPR / GENE EDITING" Style="{StaticResource CategoryHeaderStyle}"/>

                        <Button x:Name="BtnSgRNA" Style="{StaticResource NavButtonStyle}" Click="sgRNADesigner_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="??" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="sgRNA Designer" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>

                        <!-- Restriction Enzyme -->
                        <TextBlock Text="RESTRICTION ENZYME" Style="{StaticResource CategoryHeaderStyle}"/>

                        <Button x:Name="BtnREPattern" Style="{StaticResource NavButtonStyle}" Click="RestrictionEnzymePattern_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="??" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="RE Pattern Predictor" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>

                        <Button x:Name="BtnREPredictor" Style="{StaticResource NavButtonStyle}" Click="RestrictionEnzymePredictor_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="??" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="RE Cutting Site Detcetor" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>

                        <!-- Protein -->
                        <TextBlock Text="PROTEIN" Style="{StaticResource CategoryHeaderStyle}"/>

                        <Button x:Name="BtnProteinBCA" Style="{StaticResource NavButtonStyle}" Click="ProteinConcentrationCalculator_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="??" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="BCA Conc. Calculator" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>

                        <!-- Chemical -->
                        <TextBlock Text="CHEMICAL" Style="{StaticResource CategoryHeaderStyle}"/>

                        <Button x:Name="BtnMWCalc" Style="{StaticResource NavButtonStyle}" Click="MWCalculator_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="??" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="M.W. Calculator" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>

                        <Button x:Name="BtnConcCalc" Style="{StaticResource NavButtonStyle}" Click="Concalculator_Click">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="?妒" Style="{StaticResource IconStyle}"/>
                                <TextBlock Text="Concentration Calculator" VerticalAlignment="Center"/>
                            </StackPanel>
                        </Button>
                    </StackPanel>
                </ScrollViewer>

                <Border Grid.Row="2" Padding="10" BorderBrush="#E0E0E0" BorderThickness="0,1,0,0">
                    <Button Style="{StaticResource NavButtonStyle}" Click="About_Click">
                        <StackPanel Orientation="Horizontal">
                            <TextBlock Text="?對?" Style="{StaticResource IconStyle}"/>
                            <TextBlock Text="About" VerticalAlignment="Center"/>
                        </StackPanel>
                    </Button>
                </Border>
            </Grid>
        </Border>

        <!-- 蝘駁鈭筑?? Welcome Image嚗??WelcomePage 撠 -->
        <Frame x:Name="MainFrame" 
               Grid.Column="1"
               NavigationUIVisibility="Hidden"/>
    </Grid>
</Window>


==================================================
FILE_NAME: MainWindow.xaml.cs
PATH: D:\programming\BioSAK\BioSAK\MainWindow.xaml.cs
==================================================
using System;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Navigation;
using BioSAK.Pages;

namespace BioSAK
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        // ?敹怠?嚗????嚗蝙?刻?頛詨鞈?/?怠???雿輻敹怠?嚗????鞈??箏仃
        private readonly Dictionary<Type, Page> _pageCache = new Dictionary<Type, Page>();

        // ?閬翰????蝝??ａ???
        private static readonly HashSet<Type> _cachedPageTypes = new HashSet<Type>
        {
            typeof(TcgaAnalysisPage),
            typeof(FlowCytometryAnalyzer),
            typeof(GraphGen),
            typeof(sgRNADesignerPage),
            typeof(ProteinBCA),
            typeof(RestrictionEnzymePatternPage),
            typeof(RestrictionEnzymePredictorPage)
        };

        // ?嗅??訾葉?????冽擃漁憿舐內嚗?
        private Button _currentActiveButton;

        public MainWindow()
        {
            InitializeComponent();

            // ?????芸甇∟??嚗?隞?筑?? Welcome Image
            MainFrame.Navigate(new WelcomePage());
        }

        /// <summary>
        /// 蝯曹?撠?寞?嚗????雿輻敹怠?嚗????瘥活?啣遣
        /// </summary>
        private void NavigateToPage<T>(Button clickedButton) where T : Page, new()
        {
            Page page;

            if (_cachedPageTypes.Contains(typeof(T)))
            {
                // ??蝝??ｇ?敹怠?撖虫?嚗??蝙?刻?雿???
                if (!_pageCache.TryGetValue(typeof(T), out page))
                {
                    page = new T();
                    _pageCache[typeof(T)] = page;
                }
            }
            else
            {
                // 頛?蝝??ｇ?閮??函?嚗?瘥活?啣遣嚗????園?
                page = new T();
            }

            MainFrame.Navigate(page);
            SetActiveButton(clickedButton);
        }

        /// <summary>
        /// 閮剖??嗅??訾葉????鈭桃???
        /// </summary>
        private void SetActiveButton(Button button)
        {
            // ??銝?????璅??
            if (_currentActiveButton != null)
            {
                _currentActiveButton.Style = (Style)FindResource("NavButtonStyle");
            }

            // 閮剖??唳???訾葉???
            if (button != null)
            {
                button.Style = (Style)FindResource("NavButtonActiveStyle");
                _currentActiveButton = button;
            }
        }

        // ===== TCGA DATABASE =====
        private void TcgaAnalysis_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<TcgaAnalysisPage>(BtnTcgaAnalysis);
        }

        private void GeneIdConverter_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<GeneIdConverterPage>(BtnGeneIdConverter);
        }

        // ===== Flow Cytometry =====
        private void Flow_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<FlowCytometryAnalyzer>(BtnFlowCytometry);
        }

        // ===== Graphs =====
        private void GraphsGenerator_Click(object sender, RoutedEventArgs e)
        {
            var selector = new GraphTypeSelector();
            selector.Owner = this;
            if (selector.ShowDialog() == true)
            {
                // TODO: 撠?selector.SelectedType ?喳 GraphGen
                // ?桀?銝??舫撱箇??詨???GraphGen嚗??寧嚗?
                //   MainFrame.Navigate(new GraphGen(selector.SelectedType));
                // 敺?GraphGen ?舀撱箸?摮??詨??銝?神瘜?

                // ?”?蝙?典翰????
                // 瘜冽?嚗?????銵券???閬??祕靘????key = $"GraphGen_{selector.SelectedType}"
                Page page;
                if (!_pageCache.TryGetValue(typeof(GraphGen), out page))
                {
                    page = new GraphGen();
                    _pageCache[typeof(GraphGen)] = page;
                }
                MainFrame.Navigate(page);
                SetActiveButton(BtnGraphsGenerator);
            }
        }

        // ===== DNA Tools =====
        private void NucleotideComplementary_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<NucleotideComplementary>(BtnNucleotide);
        }

        // ===== CRISPR / Gene Editing =====
        private void sgRNADesigner_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<sgRNADesignerPage>(BtnSgRNA);
        }

        // ===== Restriction Enzyme =====
        private void RestrictionEnzymePattern_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<RestrictionEnzymePatternPage>(BtnREPattern);
        }

        private void RestrictionEnzymePredictor_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<RestrictionEnzymePredictorPage>(BtnREPredictor);
        }

        // ===== Protein =====
        private void ProteinConcentrationCalculator_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<ProteinBCA>(BtnProteinBCA);
        }

        // ===== Chemical =====
        
        private void MWCalculator_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<MWCal>(BtnMWCalc);
        }

        private void Concalculator_Click(object sender, RoutedEventArgs e)
        {
            NavigateToPage<ConcCal>(BtnConcCalc);
        }

        // ===== Help =====
        private void About_Click(object sender, RoutedEventArgs e)
        {
            var aboutWindow = new AboutWindow();
            aboutWindow.Owner = this;
            aboutWindow.ShowDialog();
        }
    }
}


==================================================
FILE_NAME: README.md
PATH: D:\programming\BioSAK\BioSAK\README.md
==================================================
# BioSAK - Biological Swiss Army Knife

## 瑼?蝯?

```
BioSAK/
??? Models/
??  ??? RestrictionEnzyme.cs       # 鞈?璅∪? (RestrictionEnzyme, CutSite, DnaFragment)
??? Services/
??  ??? RebaseParser.cs            # REBASE 鞈?閫??????  ??? RestrictionEnzymeCutter.cs # ??摩??
??? Pages/
??  ??? RestrictionEnzymePatternPage.xaml/.cs    # ?餅陶??????  ??? RestrictionEnzymePredictorPage.xaml/.cs  # ???葫?
??? Controls/
??  ??? ElectrophoresisGelControl.xaml/.cs       # ?餅陶?隞???? Data/
??  ??? common_enzymes.txt         # ?嗉??澈
??? MainWindow.xaml/.cs            # 銝餉?蝒?????隞嚗???? README.md                      # ?祈牧??
```

## ?游?甇仿?

### 1. 銴ˊ瑼??唬???獢?
撠誑銝??冗銴ˊ?唬???BioSAK 撠?嚗?- `Models/`
- `Services/`
- `Controls/`
- `Data/`
- `Pages/`

### 2. ?湔 MainWindow.xaml

??DNA ?詨銝哨?撠??祉? `Restriction Enzyme Patten Pridictor` ?寧嚗?```xml
<MenuItem Header="DNA">
    <!-- ?暹??... -->
    <Separator/>
    <MenuItem Header="Restriction Enzyme Pattern Predictor" Click="RestrictionEnzymePattern_Click"/>
    <MenuItem Header="Restriction Enzyme Predictor" Click="RestrictionEnzymePredictor_Click"/>
</MenuItem>
```

### 3. ?湔 MainWindow.xaml.cs

? using ??隞嗉???
```csharp
using BioSAK.Pages;

// ???瘜?private void RestrictionEnzymePattern_Click(object sender, RoutedEventArgs e)
{
    MainFrame.Navigate(new RestrictionEnzymePatternPage());
}

private void RestrictionEnzymePredictor_Click(object sender, RoutedEventArgs e)
{
    MainFrame.Navigate(new RestrictionEnzymePredictorPage());
}
```

### 4. 閮剖? Data 瑼?

?典?獢葉撠?`Data/common_enzymes.txt` 閮剔嚗?- **Build Action**: Content
- **Copy to Output Directory**: Copy if newer

? `.csproj` ?嚗?```xml
<ItemGroup>
  <Content Include="Data\common_enzymes.txt">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
</ItemGroup>
```

### 5. 蝣箄? namespace

蝣箔????獢? namespace ????獢??湛??身??`BioSAK`嚗?
## ?隤芣?

### Restriction Enzyme Pattern Predictor
- 頛詨 DNA 摨?嚗??circular/linear嚗?- ?豢??桐????- 憿舐內?雿?
- ?餅陶??閬箏?嚗芋?祈?????
- ?挾憭批???銵冽
- Marker ?舀?拍車憿?嚗?  - Standard: 10K, 9K, 8K, 7K, 6K, 5K, 4K, 3K, 2K, 1K, 500, 250
  - High Resolution: 10K, 5K, 3K, 1K, 900, 800, 700, 600, 500, 400, 300, 200, 100

### Restriction Enzyme Predictor
- 頛詨 DNA 摨?嚗??circular/linear嚗?- ????嚗蝭拚嚗?- 憿舐內瘥??
  - ?甈⊥
  - ?雿蔭
  - ?怎垢憿?嚗?' overhang, 3' overhang, Blunt嚗?  - ?臬?箏?????- 蝭拚?嚗?  - 靘??亙??摨佗?4-cutter, 6-cutter, 8-cutter嚗?  - 靘蝡舫???  - 靘??脫活??
## ?舀??IUPAC 蝪∩蔥蝣?
| Code | Nucleotides | Description |
|------|-------------|-------------|
| R | A/G | Purine |
| Y | C/T | Pyrimidine |
| M | A/C | Amino |
| K | G/T | Keto |
| S | G/C | Strong |
| W | A/T | Weak |
| H | A/C/T | Not G |
| B | C/G/T | Not A |
| V | A/C/G | Not T |
| D | A/G/T | Not C |
| N | A/C/G/T | Any |

## ?銵敦蝭

### ??摩
- 雿輻甇??銵券?撘?撠??亙???- ?舀??????摨?
- ?啁? DNA ?迤蝣箄??楊頞?暺??挾
- ?餅陶?蝙?典??詨摨行芋??DNA ?瑞宏??
### 鞈?靘?
?批遣?嗉????REBASE 鞈?摨恬??蝝?100+ 撣貊??嗚??航銵??`common_enzymes.txt` ??游??嗚?
## ?游?

### ??圈
??`Data/common_enzymes.txt` ??啗?嚗?```
EnzymeName;RecognitionSequence;CutPosition5;CutPosition3
```

蝭?嚗?```
EcoRI;GAATTC;1;5     # G^AATTC (5' overhang)
SmaI;CCCGGG;3;3      # CCC^GGG (blunt)
KpnI;GGTACC;5;1      # GGTAC^C (3' overhang)
```

### 銝?摰 REBASE
?臬? http://rebase.neb.com/rebase/rebase.files.html 銝?摰鞈?嚗?雿輻 `bairoch.txt` ?澆??靽格 `RebaseParser.cs` ?圾??頛胯?
## 靘陷??- .NET Framework 4.7.2+ ??.NET 6+
- WPF (Windows Presentation Foundation)
- ?⊿?憿? NuGet 憟辣

## ??
MIT License


==================================================
FILE_NAME: Statistics_README.md
PATH: D:\programming\BioSAK\BioSAK\Statistics_README.md
==================================================
# Statistical Analysis Methods - BioSAK GraphGen

This document explains the statistical methods implemented in the BioSAK GraphGen statistical analysis module.

---

## Table of Contents
1. [T-Test](#t-test)
2. [One-Way ANOVA](#one-way-anova)
3. [Two-Way ANOVA](#two-way-anova)
4. [Post-hoc Tests](#post-hoc-tests)
5. [Decision Logic Summary](#decision-logic-summary)

---

## T-Test

### Overview
The t-test compares means between two groups to determine if they are statistically different.

### Available Options

#### 1. Comparison Mode
- **All Pairs**: Automatically computes t-tests for all possible pairwise combinations of selected groups
- **Select Two**: Manually select exactly two groups to compare

#### 2. Test Type Selection

**Paired vs Independent:**
- **Paired t-test**: Use when samples are related (e.g., before/after measurements on the same subjects)
  - Requires equal sample sizes in both groups
  - Calculates differences between paired observations
  - Formula: t = (mean of differences) / (SE of differences)
  
- **Independent t-test**: Use when samples are from different, unrelated groups

**Variance Equality (for Independent t-test only):**

When "Auto-detect variance equality" is checked:
1. **F-test** is performed to test H?: ???= ???2. If F-test p > 0.05: **Student's t-test** (assumes equal variances)
   - Uses pooled variance estimate
   - df = n??+ n??- 2
3. If F-test p ??0.05: **Welch's t-test** (does not assume equal variances)
   - Uses Welch-Satterthwaite degrees of freedom approximation
   - More robust for unequal variances and sample sizes

**Default Behavior:**
- If F-test cannot be computed (e.g., zero variance): defaults to **Welch's t-test**

#### 3. Tail Selection
- **Two-tailed**: Tests H?: 弮??= 弮??vs H?? 弮????弮??- **One-tailed (>)**: Tests H?: 弮????弮??vs H?? 弮??> 弮??- **One-tailed (<)**: Tests H?: 弮????弮??vs H?? 弮??< 弮??
For one-tailed tests, the p-value is halved in the direction of the alternative hypothesis.

---

## One-Way ANOVA

### Overview
One-Way ANOVA tests whether there are statistically significant differences among three or more groups.

### Variance Homogeneity Testing

**Levene's Test** is automatically performed:
- Tests H?: All group variances are equal
- Uses absolute deviations from group medians (more robust than using means)

### ANOVA Type Selection

Based on Levene's test result:

| Levene's p-value | ANOVA Type | Assumption |
|------------------|------------|------------|
| > 0.05 | Standard One-Way ANOVA | Equal variances |
| ??0.05 | Welch's ANOVA | Unequal variances |

**Welch's ANOVA:**
- Does not assume equal variances
- Uses weighted means and adjusted degrees of freedom
- More robust for heteroscedastic data

**Default Behavior:**
- If Levene's test cannot be computed: defaults to **Standard ANOVA** (assumes equal variances)

### Post-hoc Tests

Post-hoc tests are performed only if:
1. Post-hoc option is checked
2. ANOVA p-value < 0.05

**Method Selection (automatic based on Levene's test):**

| Levene's p-value | Post-hoc Method |
|------------------|-----------------|
| > 0.05 | Tukey's HSD |
| ??0.05 | Games-Howell |

**Tukey's HSD (Honestly Significant Difference):**
- Assumes equal variances
- Controls family-wise error rate
- Uses studentized range distribution

**Games-Howell:**
- Does not assume equal variances
- Uses Welch-Satterthwaite degrees of freedom
- Appropriate for unequal sample sizes and variances

---

## Two-Way ANOVA

### Overview
Two-Way ANOVA examines the effects of two independent variables (factors) and their interaction.

- **Factor A**: Series (groups)
- **Factor B**: X values (conditions)
- **Interaction (A ? B)**: Whether the effect of one factor depends on the level of the other

### Options

#### 1. Include Interaction Term
- **Checked (default)**: Tests main effects A, B, and interaction A?B
- **Unchecked**: Tests only main effects A and B

#### 2. Sum of Squares Type

| Type | Name | Description | When to Use |
|------|------|-------------|-------------|
| Type I | Sequential | Effects tested in order; each adjusted for previous | Balanced designs with ordered factors |
| Type II | Hierarchical | Each main effect adjusted for other main effects only | No interaction expected |
| Type III | Marginal (default) | Each effect adjusted for all other effects | Unbalanced designs, general use |

**Automatic Selection:**
- For unbalanced designs, Type III is always used regardless of selection

### Post-hoc Analysis

**Based on Interaction Significance:**

| Interaction p-value | Analysis Type | Description |
|---------------------|---------------|-------------|
| < 0.05 | Simple Main Effects | Tests effect of each factor at each level of the other factor |
| ??0.05 | Main Effects Tests | Pairwise comparisons for significant main effects |

**Simple Main Effects:**
When interaction is significant, the effect of one factor depends on the other. Therefore:
- Effect of Factor A is tested separately at each level of Factor B
- Effect of Factor B is tested separately at each level of Factor A

**Main Effects Tests:**
When interaction is not significant:
- If Factor A is significant: Pairwise comparisons between series
- If Factor B is significant: Pairwise comparisons between X values

---

## Post-hoc Tests

### Tukey's HSD
```
q = |Mean??- Mean? / SE

where SE = ??MSE ? (1/n??+ 1/n?? / 2)
```
- Uses studentized range distribution
- Controls Type I error across all comparisons

### Games-Howell
```
t = |Mean??- Mean? / SE

where SE = ??s??n??+ s??n??
df = Welch-Satterthwaite approximation
```
- Does not assume equal variances
- Adjusts degrees of freedom for each comparison

---

## Decision Logic Summary

### T-Test Decision Tree
```
Is comparison paired?
?? YES ??Paired t-test
?? NO ??Independent t-test
         ?? Can F-test be computed?
         ??  ?? YES ??F-test p > 0.05?
         ??  ??       ?? YES ??Student's t-test
         ??  ??       ?? NO ??Welch's t-test
         ??  ?? NO ??Welch's t-test (default)
         ?? Apply tail correction if one-tailed
```

### One-Way ANOVA Decision Tree
```
Perform Levene's test for variance homogeneity
?? Can Levene's test be computed?
??  ?? YES ??Levene's p > 0.05?
??  ??       ?? YES ??Standard ANOVA, Tukey's HSD
??  ??       ?? NO ??Welch's ANOVA, Games-Howell
??  ?? NO ??Standard ANOVA (default)
?? ANOVA p < 0.05?
    ?? YES ??Perform selected post-hoc test
    ?? NO ??No post-hoc (no significant differences)
```

### Two-Way ANOVA Decision Tree
```
Check design balance
?? Balanced ??Use selected SS Type
?? Unbalanced ??Force Type III

Include interaction?
?? YES ??Test A, B, and A?B
??       ?? Interaction p < 0.05?
??           ?? YES ??Simple Main Effects
??           ?? NO ??Main Effects Tests
?? NO ??Test A and B only
         ?? Main Effects Tests for significant factors
```

---

## Statistical Formulas

### F-test for Variance Equality
```
F = s??/ s?? (larger / smaller)
df??= n??- 1, df??= n??- 1
```

### Levene's Test
```
1. Calculate |X廘Ｔ掉 - Median(X漹?| for each observation
2. Perform ANOVA on absolute deviations
```

### Welch-Satterthwaite Degrees of Freedom
```
df = (s??n??+ s??n??簡 / [(s??n??簡/(n??1) + (s??n??簡/(n??1)]
```

### Welch's ANOVA
```
F = 峉w廘?X?廘?- X?廘丟等)簡 / (k-1) / [1 + 2(k-2)弇/(k簡-1)]

where:
  w廘?= n廘?/ s廘Ⅹ?  X?廘丟等 = 峉w廘?X?廘?/ 峉w廘?  弇 = 3峉[(1 - w廘?峉w廘?簡/(n廘?1)] / (k簡-1)
```

---

## Significance Levels

| p-value | Significance | Symbol |
|---------|--------------|--------|
| p < 0.001 | Highly significant | *** |
| p < 0.01 | Very significant | ** |
| p < 0.05 | Significant | * |
| p ??0.05 | Not significant | ns |

---

## References

1. Welch, B. L. (1947). The generalization of "Student's" problem when several different population variances are involved. Biometrika, 34(1/2), 28-35.

2. Games, P. A., & Howell, J. F. (1976). Pairwise multiple comparison procedures with unequal n's and/or variances: a Monte Carlo study. Journal of Educational Statistics, 1(2), 113-125.

3. Levene, H. (1960). Robust tests for equality of variances. In Contributions to Probability and Statistics (pp. 278-292).

4. Brown, M. B., & Forsythe, A. B. (1974). The small sample behavior of some statistics which test the equality of several means. Technometrics, 16(1), 129-132.

---

*BioSAK GraphGen Statistical Module - Version 1.0*

